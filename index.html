<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SYSU 计算机专业大二在读">
<meta property="og:type" content="website">
<meta property="og:title" content="reeeeeeeeeein的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="reeeeeeeeeein的博客">
<meta property="og:description" content="SYSU 计算机专业大二在读">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reeeeeeeeeein">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>reeeeeeeeeein的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
<div class="bg_content">
<canvas id="canvas"></canvas>
</div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">reeeeeeeeeein的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">加载用户程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 18:14:34" itemprop="dateCreated datePublished" datetime="2020-04-27T18:14:34+08:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h1><p>众所周知，引导扇区程序会将操作系统加载到内存中，并把计算机的控制权交给操作系统。问题来了，引导扇区程序是怎么加载用户程序的？</p>
<p>这是一个复杂的问题，为了回答这个问题，首先我们需要了解用户程序的内容有什么样的格式，其次我们需要知道处理器与硬盘交互的方式，最后还要知道引导扇区程序怎么把控制权交给用户程序。</p>
<h2 id="用户程序header段"><a href="#用户程序header段" class="headerlink" title="用户程序header段"></a>用户程序header段</h2><p>在引导扇区程序中，处理器从0x7c00处开始执行代码。然而，对于引导扇区程序会把用户程序加载到哪一个位置，用户程序是不知道的。那就有问题了，如果我在用户程序中要访问数据段中的一个数据，却连这个数据在内存中的位置都不知道，还怎么访问呢？</p>
<p>分段的方法能很好的解决这个问题。用户程序被分为几段，每一段有一个起始地址，如果我们要访问一个数据，只需给出它在段中的偏移地址即可。用户程序会告诉引导扇区程序自己有几个段，每个段相对于程序开始处的偏移是多少，引导扇区程序会给用户程序在内存中分配一个位置，比如说，0xd000，然后假设用户程序的数据段相对于程序开始处偏移为0x100，则数据段会被加载到内存中的0xd100处。然后，引导扇区程序把ds置为0xd10，这样，用户程序就可以用段地址和偏移地址访问内存了。</p>
<p>为了告诉引导扇区程序一些必要的信息，用户程序会有一个header段，里面包含了程序的长度、第一条指令的位置、其他段的个数和其他段的相对偏移量。如图所示:</p>
<p><img src="https://i.loli.net/2020/04/27/WtKF7V15MsSwuJQ.png" alt="image-20200427172648671.png"></p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart&#x3D;0 align&#x3D;16 ;SECTION表明这是一个段的开头，vstart&#x3D;0表明这个段里的所有标号</span><br><span class="line">;都用的是偏移地址，align&#x3D;16表明这个段的起始位置要为16的倍数</span><br><span class="line">length dd program_end;program_end标号在程序的尾部，可以用来得到程序的长度</span><br><span class="line">codeentry dw start;start标号指向程序的第一条指令的位置</span><br><span class="line">          dd section.code_1.start;section.code_1.start指的是code_1这个段的开始位置，第一条指令在这个段里面</span><br><span class="line">          ;根据上面两行，可以知道用户程序的第一条指令的位置</span><br><span class="line">segment_table dw (header_end-code_1_segment)&#x2F;4;段表的长度，即这个程序还有几个段</span><br><span class="line">code_1_segment dd section.code_1.start;code_1段的开始位置</span><br><span class="line">data_1_segment dd section.data_1.start;data_1段的开始位置</span><br><span class="line">stack_segment dd section.stack.start;stack段的开始位置</span><br><span class="line">header_end:</span><br></pre></td></tr></table></figure>

<p>有了这个header段，引导扇区程序就能得到加载用户程序所必须的信息。由于引导扇区程序要将用户程序加载进内存，我们也成引导扇区程序为<strong>加载器</strong>。</p>
<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p>我们来看一下加载器会做些什么。</p>
<p>首先，我们默认加载器知道用户程序在磁盘中的哪一个扇区，也明确了用户程序会被加载到哪一个位置。在加载器的开头，会有一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_sector equ 100</span><br></pre></td></tr></table></figure>

<p>这是一个伪指令，相当于%define first_sector 100。</p>
<p>然后，加载器像其他程序一样，会有一个段声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align&#x3D;16 vstart&#x3D;0x7c00</span><br></pre></td></tr></table></figure>

<p>注意这里vstart=0x7c00。也就是说，后面的标号的值都要加上0x7c00。接下来是正常的设置堆栈段和栈指针的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure>

<p>然后要处理的是用户程序在内存中的起始位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[cs:start_loc]</span><br><span class="line">mov dx,[cs:start_loc+2]</span><br><span class="line">mov bx,16</span><br><span class="line">div bx</span><br><span class="line">mov es,ax</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>一开始时cs寄存器是0，start_loc标号在程序的尾部，内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_loc: dd 0x10000</span><br></pre></td></tr></table></figure>

<p>这个值就是用户程序会被加载到的位置。</p>
<p>由于0x10000是一个20位的数，于是只能用dx:ax两个寄存器来存储。我们将dx:ax除以16，商保存在ax中，将它赋值给es和ds。这样，ds和es就是用户程序的起始段地址。接下来我们读入第一个扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor bx,bx</span><br><span class="line">xor di,di</span><br><span class="line">mov si,first_sector</span><br><span class="line">call read_disk</span><br></pre></td></tr></table></figure>

<p>call指令意思是过程调用，它会先将ip的值保存至栈中，转而取执行read_disk位置的指令。事实上，它就相当于高级语言中的函数。向这个”函数”传递参数的方式是把要用到值放在其他寄存器中。</p>
<p>既然我们要读磁盘，我们得知道把要读哪一个扇区和读出来的内容放在哪里告诉磁盘。这里我们把扇区的位置放置在di:si中，读出来的内容放在[ds:bx]里 。做完这些工作，就可以调用read_disk了，它的内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">read_disk:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,1</span><br><span class="line">out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f3</span><br><span class="line">mov ax,si</span><br><span class="line">out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f4</span><br><span class="line">mov al,ah</span><br><span class="line">out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f5</span><br><span class="line">mov ax,di</span><br><span class="line">out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f6</span><br><span class="line">mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">or al,ah                        ;LBA地址27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f7</span><br><span class="line">mov al,0x20                     ;读命令</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">disk_ok?:</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88</span><br><span class="line">cmp al,0x08</span><br><span class="line">jne disk_ok?</span><br><span class="line"></span><br><span class="line">mov cx,256</span><br><span class="line">mov dx,0x1f0</span><br><span class="line"></span><br><span class="line">read_content:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne read_content</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>看起来很复杂，但只要一条条分析，还是能分析清楚的。首先是把ax,bx,cx,dx 4个寄存器push到栈中。因为我们要修改它们的值，得先把它们保护起来，等这个过程要返回了，就把它们pop回去。</p>
<p>从第7行到第30行，是在向I/O端口读写信息，这些端口是独立编址的。从I/O端口读入信息用in指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,dx</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in ax,dx</span><br></pre></td></tr></table></figure>

<p>dx是要访问的端口号，al、ax是用来保存读入的值。注意不能用其他的寄存器。</p>
<p>相应的，向I/O端口写入信息，要用out指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,al</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,ax</span><br></pre></td></tr></table></figure>

<p>dx是访问的端口号，al、ax是要写入的值。</p>
<p>in、out指令的dx参数也可以用立即数代替。</p>
<p>主硬盘端口分配的端口号是0x1f0-0x1f7。</p>
<p>其中，0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<p>0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。</p>
<p>0x1f2端口用于设置要读取的扇区数量，0x1f3-0x1f6端口用于设置起始扇区号。扇区号有28个字节，0-7字节要放在0x1f3里，8-15字节要放在0x1f4里，16-23字节要放在0x1f5里，24-27字节要放在0x1f6里。0x1f6的高4位置为1110。</p>
<p>端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送 读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第 7 位置 “1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第 3 位置“1”，意思是准备好了，请求主机发送或者接收数据。</p>
<p>了解了这些后，第7-30行的代码也就很容易理解了。</p>
<p>第32-36行是在不断判断硬盘是否准备好，如果没有则继续循环。</p>
<p>第38行将cx置为256，因为一个扇区是512个字节，一次读出2个字节。第39行将dx置为0x1f0，即从0x1f0读入数据。</p>
<p>第41-47行不断将数据读入到[ds:bx]处，然后将bx+=2。</p>
<p>最后恢复ax,bx,cx,dx寄存器，注意顺序要反过来。</p>
<p>第一次读完磁盘后，用户程序的第一个扇区就已经在内存里了。接下来要进行一些很重要的工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov dx,[bx+2]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov bx,512</span><br><span class="line">div bx</span><br><span class="line">cmp dx,0</span><br><span class="line">je tem1</span><br><span class="line">inc ax</span><br></pre></td></tr></table></figure>

<p>用户程序的前4个字节是用户程序的大小，先把它读入到ds:ax中，然后除以512，得到用户程序在磁盘中的扇区数。注意，如果用户程序的大小恰好为512的倍数，则除法指令结束后，ax的值就是用户程序占的扇区数，此时dx为0；否则，这个数字要加1。</p>
<p>接下来要读入其他扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tem1:</span><br><span class="line">dec ax</span><br><span class="line">mov cx,ax</span><br><span class="line">cmp cx,0</span><br><span class="line">je tem3</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">tem2:</span><br><span class="line">xor bx,bx</span><br><span class="line">inc si</span><br><span class="line">mov ax,ds</span><br><span class="line">add ax,0x20</span><br><span class="line">mov ds,ax</span><br><span class="line">call read_disk</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne tem2</span><br></pre></td></tr></table></figure>

<p>首先将ax减1(刚才已经读了一个扇区了)。如果ax==0，则跳过下面的工作；否则进入tem2这个循环。</p>
<p>循环里每次将si加1(ds:si是要读的扇区号)，将ds+=0x20(写入内存的位置每次往后推512个字节)，将bx置为0，然后调用read_disk过程读入扇区。</p>
<p>把扇区读完了，接下来要确定用户程序的第一条指令的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tem3:</span><br><span class="line">mov dx,[0x08]</span><br><span class="line">mov ax,[0x06]</span><br><span class="line">call segment_reloc</span><br></pre></td></tr></table></figure>

<p>回忆一下，第一条指令的位置是通过 段地址(第一条指令所在段的首地址)+偏移地址(第一条指令相对于段地址的差值) 给出的。在[ds:bx+0x06]到[ds:bx+0x09]之间的是段地址。我们把它的值与用户程序在内存中的首地址相加，就得到了这个段的真实地址，再把它右移4位，送到ax寄存器中。上述过程会被执行很多次（有好几个段），所以我们把它写成一个segment_reloc过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push dx</span><br><span class="line"></span><br><span class="line">add ax,[cs:start_loc]</span><br><span class="line">add dx,[cs:start_loc+0x02]</span><br><span class="line">shr ax,4</span><br><span class="line">shl dx,12</span><br><span class="line">or ax,dx</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>shr指令是右移4位，shl指令是左移12位，or指令把ax和dx合起来（ax的高4位为0，dx的低12位为0）。</p>
<p>得到真实段地址右移4位的值后，把它送回[ds:0x06]处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x06],ax</span><br></pre></td></tr></table></figure>

<p>接下来要读段表。首先从[ds:0x0a]处取出一个字放到cx中，表示段表的大小，然后将bx置为0x0c，这是段表的首地址相对用户程序起始处的偏移地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov cx,[0x0a]</span><br><span class="line">mov bx,0x0c</span><br></pre></td></tr></table></figure>

<p>接下来要一个个读:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">segment_table_reloc:</span><br><span class="line">mov dx,[bx+0x02]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">call segment_reloc</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,4</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne segment_table_reloc</span><br></pre></td></tr></table></figure>

<p>这部分内容跟开始时读段表差不多，不再赘述。</p>
<p>折腾完这些，加载器的工作差不多完成了，可以把控制权交给用户程序了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far [0x04]</span><br></pre></td></tr></table></figure>

<p>jmp far是 16 位间接绝对远转移。上面一条指令会从 ds:0x04 处取出6个字节，把前两个字节作为一个字，它是指令的偏移地址；后4个字节被当成一个双字，是指令所在段的地址（这个地址已经被我们重定位过了）。这样就能跳到用户程序的第一条指令了。注意，此时ds,es的值都是用户程序在内存中的首地址右移4位的值。</p>
<h2 id="用户程序其他内容"><a href="#用户程序其他内容" class="headerlink" title="用户程序其他内容"></a>用户程序其他内容</h2><p>看看用户程序会做什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SECTION code_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">start:</span><br><span class="line">mov ax,[stack_segment]</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,stack_end</span><br><span class="line"></span><br><span class="line">mov ax,[data_1_segment]</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,msg</span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">xor ax,ax</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">do:</span><br><span class="line">mov al,[bx]</span><br><span class="line">inc bx</span><br><span class="line">mov [es:di],al</span><br><span class="line">inc di</span><br><span class="line">mov byte [es:di],0x07</span><br><span class="line">inc di</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne do</span><br><span class="line"></span><br><span class="line">jmp near $</span><br><span class="line"></span><br><span class="line">SECTION data_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">msg db &#39;hello world!&#39;</span><br><span class="line"></span><br><span class="line">SECTION stack align&#x3D;16 vstart&#x3D;0</span><br><span class="line">resb 256</span><br><span class="line">stack_end:</span><br><span class="line">SECTION trail align&#x3D;16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>

<p>第1行声明了一个段，第3行就是我们期待已经的第一条指令。前3条指令用于设置段指针和段寄存器的值。</p>
<p>第7，8行两行设置数据段寄存器ds的值，第9,10行两行设置附加段寄存器es的值。</p>
<p>从第12行开始是一个很正常的显示字符串的工作，不再赘述。</p>
<p>第32行声明了数据段，里面只有一个字符串。</p>
<p>第35行声明了堆栈段，里面用resb指令保留了256个字节。注意，stack_end标号是在resb指令的后面，因为栈指针的值是不断减小的。</p>
<p>最后，第38行声明了一个trail段，它没什么用，值得注意的是它没有vstart=0这个定义，所以标号program_end的值是从0开始算的，所以它的值就是用户程序的大小。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>用bochs运行，结果如下:</p>
<p><img src="https://i.loli.net/2020/04/27/j79IMNP2pcyd46C.png" alt="image-20200427174119405.png"></p>
<p>效果拨群。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">pytorch学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 00:19:35" itemprop="dateCreated datePublished" datetime="2020-04-22T00:19:35+08:00">2020-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tensor与Autograd详解"><a href="#Tensor与Autograd详解" class="headerlink" title="Tensor与Autograd详解"></a>Tensor与Autograd详解</h1><p>参考自《深度学习框架PyTorch入门与实践》</p>
<h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><h3 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h3><p>创建Tensor的方法有很多:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Tensor(*size)</td>
<td>基础构造函数</td>
</tr>
<tr>
<td>ones(*size)</td>
<td>全为 1 Tensor</td>
</tr>
<tr>
<td>zeros(*size)</td>
<td>全为 0 Tensor</td>
</tr>
<tr>
<td>eyes(*size)</td>
<td>对角线为1，其他为0</td>
</tr>
<tr>
<td>arange(s,e,step)</td>
<td>从s到e，步长为step</td>
</tr>
<tr>
<td>linspace(s,e,step)</td>
<td>从s到e，均分为step份</td>
</tr>
<tr>
<td>rand/randn(*sizes)</td>
<td>均匀/标准分布</td>
</tr>
<tr>
<td>normal(mean,std)/uniform(from,to)</td>
<td>正态分布/均匀分布</td>
</tr>
<tr>
<td>randperm(m)</td>
<td>随机排列</td>
</tr>
</tbody></table>
<p>用Tensor()函数创建tensor时，可以有很多方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=t.Tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])<span class="comment">#用一个list来创建</span></span><br><span class="line">y=t.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">z=t.Tensor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#用几个值来确定Tensor的维度</span></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(y.tolist())</span><br><span class="line">print(z)</span><br><span class="line">a=x</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/bh1INsQH2CDZJui.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">print(x.numel())</span><br><span class="line">y=t.Tensor(x.size())</span><br><span class="line">z=t.Tensor((<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#Tensor的元素是2和3</span></span><br><span class="line">a=t.Tensor(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#Tensor的大小是2*3</span></span><br><span class="line">y,z,a</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/FHmz64MwnYik3U1.png" alt="image.png"></p>
<p>tensor.shape和tensor.size()是一样的:<br><img src="https://i.loli.net/2020/04/21/t1bwdZcOvEFT3hV.png" alt="image.png"></p>
<p>一些其他的创建方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x=t.ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.zeros(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.arange(<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>)<span class="comment">#注意，第二个参数是取不到的</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.arange(<span class="number">1</span>,<span class="number">7.00000000000001</span>,<span class="number">2</span>)<span class="comment">#注意，第二个参数是取不到的</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.linspace(<span class="number">1</span>,<span class="number">10.7</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.randn(<span class="number">3</span>,<span class="number">3</span>)<span class="comment">#均值为0，方差为1的正态分布</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.randperm(<span class="number">20</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.eye(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/2IY1rnLE3aWm98i.png" alt="image.png"></p>
<h2 id="改变形状的操作"><a href="#改变形状的操作" class="headerlink" title="改变形状的操作"></a>改变形状的操作</h2><p>用 view()，squeeze(),unsqueeze(),resize_()等方法可以改变tensor的形状</p>
<h3 id="view"><a href="#view" class="headerlink" title="view()"></a>view()</h3><p>view()用于直接改变形状，但不能改变tensor的大小。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b=t.arange(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">print(b.view(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(b.view(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)) <span class="comment"># -1表示自动计算其大小</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/ErYxRC1MD7Pi5dF.png" alt="image.png"></p>
<h3 id="unsqueeze"><a href="#unsqueeze" class="headerlink" title="unsqueeze()"></a>unsqueeze()</h3><p>unsqueeze()用于增加tensor的维度。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(b)</span><br><span class="line">print(b.unsqueeze(<span class="number">1</span>))<span class="comment">#从 6 变成 6*1</span></span><br><span class="line">print(b.unsqueeze(<span class="number">-2</span>))<span class="comment">#-2 的意思是，增加的那个维度是增加了维度之后的tensor的倒数第二个维度。</span></span><br><span class="line"><span class="comment">#也就是说，从 6 增加成 1*6</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/rSDs8YauxeB5CFb.png" alt="image.png"></p>
<h3 id="squeeze"><a href="#squeeze" class="headerlink" title="squeeze()"></a>squeeze()</h3><p>squeeze()用于压缩大小为一的维度。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.Tensor(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">print(x.squeeze(<span class="number">0</span>))<span class="comment">#第0个维度大小是2，不能压缩</span></span><br><span class="line">print(x.squeeze())<span class="comment">#压缩所有大小为1的维度</span></span><br><span class="line">x.squeeze(<span class="number">2</span>)<span class="comment">#第二个维度大小是1，被压缩</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/s8hv6XkiAx1Ofc2.png" alt="image.png"></p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize_"></a>resize_</h3><p>resize_也可以用来修改形状。不同的是，如果新尺寸超过了原来的尺寸，会自动分配新的内存空间。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.resize_(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">x.resize_(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/Mf1PgbTLKvAqWl8.png" alt="image.png"></p>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>Tensor可以按下标索引:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=t.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a[<span class="number">0</span>])<span class="comment">#第0行</span></span><br><span class="line">print(a[:,<span class="number">2</span>])<span class="comment">#第2列</span></span><br><span class="line">print(a[<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#第1,2行和第2,3列的交叉</span></span><br><span class="line">print(a[:<span class="number">2</span>])<span class="comment">#前两行</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">2</span>])<span class="comment">#前两行</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">1</span>,:<span class="number">2</span>])<span class="comment">#第0行，前两列。形状是1*2</span></span><br><span class="line">print(a[<span class="number">0</span>,:<span class="number">2</span>])<span class="comment">#第0行，前两列。形状是2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/3M8SQftLEpv2UHA.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">print(a&gt;<span class="number">1</span>)</span><br><span class="line">print(a[a&gt;<span class="number">1</span>])<span class="comment">#形状不同</span></span><br><span class="line">print(a*(a&gt;<span class="number">1</span>))<span class="comment">#形状相同</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/93ay4eobRnSIPVs.png" alt="image.png"></p>
<h2 id="选择函数"><a href="#选择函数" class="headerlink" title="选择函数"></a>选择函数</h2><p>选择函数用于从Tensor中选出一部分。</p>
<h3 id="index-select"><a href="#index-select" class="headerlink" title="index_select()"></a>index_select()</h3><p>index_select()用于选出tensor特定维度特定下表的部分。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.linspace(<span class="number">1</span>, <span class="number">12</span>, steps=<span class="number">12</span>).view(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = torch.index_select(a, <span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">2</span>]))<span class="comment">#0表示第0个维度，0,2表示这一维度下表为0和2的会被选出来。</span></span><br><span class="line">print(b)</span><br><span class="line">print(a.index_select(<span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">2</span>])))</span><br><span class="line">c = a.index_select(<span class="number">1</span>, torch.tensor([<span class="number">1</span>, <span class="number">3</span>]))<span class="comment">#1表示第一个维度</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/3qwKlU4OPgGTNLF.png" alt="image.png"></p>
<h3 id="mask-select"><a href="#mask-select" class="headerlink" title="mask_select()"></a>mask_select()</h3><p>a.mask_select(b)=a[b],没啥好用的</p>
<h3 id="nonzero"><a href="#nonzero" class="headerlink" title="nonzero()"></a>nonzero()</h3><p>用于获得非0元素的下标，用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=t.Tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">print(a.nonzero())</span><br><span class="line">a[a.nonzero()]</span><br></pre></td></tr></table></figure>

<h3 id="gather-和scatter"><a href="#gather-和scatter" class="headerlink" title="gather()和scatter()"></a>gather()和scatter()</h3><p>太复杂了，等用到的时候再搞。</p>
<h2 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h2><p>x[[],[]……[]] 其中第1个列表表示第0个维度要选的东西，第2个列表表示第1个维度要选的东西，以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.arange(<span class="number">0</span>,<span class="number">27</span>).view(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]])<span class="comment">#相当于x[1,1,2]和x[2,2,1]</span></span><br><span class="line">print(x[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>],[<span class="number">0</span>]])<span class="comment">#相当于x[1,0,0]和x[2,0,0]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/QqLorfhP7dNG5MU.png" alt="image.png"></p>
<h2 id="Tensor类型"><a href="#Tensor类型" class="headerlink" title="Tensor类型"></a>Tensor类型</h2><p>tensor的元素默认类型是FloatTensor,可以通过t.set_default_tensor_type()修改默认类型。</p>
<p>常见类型有:</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>CPU tensor</th>
<th>GPU tensor</th>
</tr>
</thead>
<tbody><tr>
<td>32bit浮点</td>
<td>torch.FloatTensor</td>
<td>torch.cuda.FloatTensor</td>
</tr>
<tr>
<td>64bit浮点</td>
<td>torch.DoubleTensor</td>
<td>torch.cuda.DoubleTensor</td>
</tr>
<tr>
<td>16bit浮点</td>
<td>16bit浮点只能在GPU里用</td>
<td>torch.cuda.HaltTensor</td>
</tr>
<tr>
<td>8bit无符号整型</td>
<td>torch.ByteTensor</td>
<td>torch.cuda.ByteTensor</td>
</tr>
<tr>
<td>8bit有符号整型</td>
<td>torch.CharTensor</td>
<td>torch.cuda.CharTensor</td>
</tr>
<tr>
<td>16bit有符号整型</td>
<td>torch.ShortTensor</td>
<td>torch.cuda.ShortTensor</td>
</tr>
<tr>
<td>32bit有符号整型</td>
<td>torch.IntTensor</td>
<td>torch.cuda.IntTensor</td>
</tr>
<tr>
<td>64bit有符号整型</td>
<td>torch.LongTensor</td>
<td>torch.cuda.LongTensor</td>
</tr>
</tbody></table>
<p>还可以用type()函数指定类型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t.set_default_tensor_type(<span class="string">"torch.FloatTensor"</span>)</span><br><span class="line">a=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">b=a.int()</span><br><span class="line">print(b)</span><br><span class="line">b=b.type(<span class="string">"torch.DoubleTensor"</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h2 id="逐元素操作"><a href="#逐元素操作" class="headerlink" title="逐元素操作"></a>逐元素操作</h2><p>这些函数会对tensor的每一个元素进行操作，如下表所示:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>abs/sqrt/div/exp/fmod/log/pow</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">pytorch学习笔记1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 10:53:51" itemprop="dateCreated datePublished" datetime="2020-04-21T10:53:51+08:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pytorch-快速入门"><a href="#pytorch-快速入门" class="headerlink" title="pytorch 快速入门"></a>pytorch 快速入门</h1><p>参考自《深度学习框架PyTorch入门与实践》</p>
<h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><p>Tensor是pytorch里最基础的数据结构，可以认为是一个高级数组。它可以包含一个数，一个一维数组，一个二维矩阵或更高维的数组。</p>
<h3 id="Tensor的创建"><a href="#Tensor的创建" class="headerlink" title="Tensor的创建"></a>Tensor的创建</h3><p>创建一个Tensor的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="keyword">as</span> t</span><br><span class="line">x=t.Tensor(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>这种情况下，会生成一个内容全为0的Tensor:<br><img src="https://i.loli.net/2020/04/19/WtVqcS1Re8uTBkY.png" alt="image.png"></p>
<p>随机生成Tensor的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>这样，Tensor里的每一个值都是一个0到1之间的随机数:<br><img src="https://i.loli.net/2020/04/19/VXACsqmWzt1eySY.png" alt="image.png"></p>
<p>用t.ones()能生成全为1的Tensor，用t.zeros()能生成全为0的Tensor:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.zeros(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/S5RCF4BJg9xXPNn.png" alt="image.png"></p>
<p>得到Tensor的大小:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">x.size(<span class="number">0</span>),x.size(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/RtMaVJzdsASTm2W.png" alt="image.png"></p>
<h3 id="Tensor运算"><a href="#Tensor运算" class="headerlink" title="Tensor运算"></a>Tensor运算</h3><p>Tensor之间的运算可以用 ‘+’、’-‘、’*’、’/‘等符号实现，也可以用add,sub等函数实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(x+y)</span><br><span class="line">print(x.add(y))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/pHzPvm9Z23ngUxb.png" alt="image.png"></p>
<p>值得注意的是，add函数并不会修改x的值，要实现x+=y,要用add_()函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(x+y)</span><br><span class="line">print(x.add_(y))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/T5GEgdj9xseiNrC.png" alt="image.png"></p>
<h3 id="Tensor与numpy的关系"><a href="#Tensor与numpy的关系" class="headerlink" title="Tensor与numpy的关系"></a>Tensor与numpy的关系</h3><p>Tensor的很多操作跟numpy差不多，它们也可以互相转换:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.ones(<span class="number">3</span>)</span><br><span class="line">y=t.from_numpy(x)</span><br><span class="line">print(y)</span><br><span class="line">z=y.numpy()</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/sNmATBf4jkZvKor.png" alt="image.png"></p>
<p>值得注意的是，Tensor与nump对象的内存是共享的，因此其中一个改变的时候，另一个也会改变:<br><img src="https://i.loli.net/2020/04/19/ihVlkI1KHtDRNBb.png" alt="image.png"></p>
<h3 id="将Tensor转移到cuda上"><a href="#将Tensor转移到cuda上" class="headerlink" title="将Tensor转移到cuda上"></a>将Tensor转移到cuda上</h3><p>可以通过.cuda方法把Tensor转移到GPU上:<br><img src="https://i.loli.net/2020/04/19/ohkZBf2L4yNX7v1.png" alt="image.png"></p>
<h2 id="Autograd"><a href="#Autograd" class="headerlink" title="Autograd"></a>Autograd</h2><p>pytorch的Autograd模块提供了反向传播的功能。</p>
<p>autograd.Variable是Autograd中的核心类，它可以理解为Tensor的升级版。它的backward()方法能够自动计算梯度，提供了反向传播的功能。<br><img src="https://i.loli.net/2020/04/19/cjLrkSo37uFNYxd.png" alt="image.png"><br><img src="https://i.loli.net/2020/04/19/Nq4dSk1gPAbuyYa.png" alt="image.png"></p>
<p>由于y对x的每一个元素的偏导数都是1，所以x.grad是一个2*2的全为1的矩阵。<br>如果我们在调用一次y.backward(),会怎么样？<br><img src="https://i.loli.net/2020/04/19/LhJGUiXtSzNsVP5.png" alt="image.png"></p>
<p>我们发现grad在反向传播的过程中是累加的，所以我们要将grad清零:<br><img src="https://i.loli.net/2020/04/19/PFeDHjOtIfwJ4GM.png" alt="image.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>torch.nn是专门为神经网络设计的模块化接口，可以用来定义和运行神经网络。nn.Module是nn中最重要的类，可以看成是神经网络的封装。</p>
<h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><p>一个网络需要继承nn.Module，并实现它的forward方法，并把具有可学习参数的层放在构造函数<strong>init</strong>中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1=nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>)<span class="comment">#第一个参数是输入通道数，</span></span><br><span class="line">        <span class="comment">#第二个参数是输出通道数，第三个参数是卷积核的大小。</span></span><br><span class="line">        self.conv2=nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        self.fc1=nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>)</span><br><span class="line">        self.fc2=nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3=nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),<span class="number">2</span>)<span class="comment"># 这里的2跟(2,2)的效果是一样的</span></span><br><span class="line">        x=x.view(x.size()[<span class="number">0</span>],<span class="number">-1</span>)</span><br><span class="line">        x=F.relu(self.fc1(x))</span><br><span class="line">        x=F.relu(self.fc2(x))</span><br><span class="line">        x=self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net=Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/2BUZDOilLbWQK9z.png" alt="image.png"></p>
<p>只要实现了forward方法，backward方法就会被自动实现。<br>网络的可学习参数可以通过net.parameters()得到:<br><img src="https://i.loli.net/2020/04/19/jvrHShXGe5PJNa6.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/04/19/SaGqQTxindgX7Ls.png" alt="image.png"></p>
<p>forward函数的输入和输出都是Variable，因此在输入的时候要把Tensor变成Variable:<br><img src="https://i.loli.net/2020/04/19/6Sz2rVmIsYRKj7A.png" alt="image.png"></p>
<p>注意，input是一个4维的向量，其中第一维是batch的大小，神经网络的输入是一个batch，里面可以有很多张图像。第二维是图像的通道数。第三维第四维是图像的大小。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>nn里定义了很多损失函数，如MSELoss用来计算均方误差，CrossEntropyLoss用来计算交叉熵损失。<br><img src="https://i.loli.net/2020/04/19/zpnGxdiSQDK18bX.png" alt="image.png"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>torch.optim 中实现了很多优化方法，可以用它们来对网络的参数进行更新:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.01</span>)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output=net(input)</span><br><span class="line">loss=criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>

<h3 id="CIFAR-10-分类"><a href="#CIFAR-10-分类" class="headerlink" title="CIFAR-10 分类"></a>CIFAR-10 分类</h3><p>CIFAR-10是一个常用的彩色图片数据集，共有10个类别，每张图片的大小都是3<em>32</em>32。<br>我们利用torchvision提供的CIFAR-10数据集来训练一个神经网络，并让它对测试图片进行预测。</p>
<p>首先进行一些准备工作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">import</span> torchvision <span class="keyword">as</span> tv</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToPILImage</span><br><span class="line">show=ToPILImage()</span><br><span class="line"><span class="comment">#show用于将Tensor对象转化为图片，以便于观察结果</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>))])</span><br><span class="line"><span class="comment">#transform 用于对输入图像进行预处理</span></span><br><span class="line">trainset=tv.datasets.CIFAR10(root=<span class="string">'/home/cy/data/'</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">trainloader=t.utils.data.DataLoader(trainset,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#用trainloader加载训练数据，batch_size=4说明一个batch是4张图片,num_worker=2说明用两个线程</span></span><br><span class="line">testset=tv.datasets.CIFAR10(<span class="string">'/home/cy/data/'</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">testloader=t.utils.data.DataLoader(testset,batch_size=<span class="number">4</span>,shuffle=<span class="literal">False</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">classes=(<span class="string">'plane'</span>,<span class="string">'car'</span>,<span class="string">'bird'</span>,<span class="string">'cat'</span>,<span class="string">'deer'</span>,<span class="string">'dog'</span>,<span class="string">'frog'</span>,<span class="string">'horse'</span>,<span class="string">'ship'</span>,<span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>

<p>查看某一张照片:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(data,label)=trainset[<span class="number">100</span>]</span><br><span class="line">print(classes[label])</span><br><span class="line">show((data+<span class="number">1</span>)/<span class="number">2</span>).resize((<span class="number">100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/Z5s9chJX4d1YtxC.png" alt="image.png"></p>
<p>定义一个网络:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1=nn.Conv2d(<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)<span class="comment">#第一个参数是输入通道数，</span></span><br><span class="line">        <span class="comment">#第二个参数是输出通道数，第三个参数是卷积核的大小。</span></span><br><span class="line">        self.conv2=nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        self.fc1=nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>)</span><br><span class="line">        self.fc2=nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3=nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv2(x)),<span class="number">2</span>)<span class="comment"># 这里的2跟(2,2)的效果是一样的</span></span><br><span class="line">        x=x.view(x.size()[<span class="number">0</span>],<span class="number">-1</span>)</span><br><span class="line">        x=F.relu(self.fc1(x))</span><br><span class="line">        x=F.relu(self.fc2(x))</span><br><span class="line">        x=self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net=Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>

<p>定义一个损失函数和优化器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.001</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>开始训练:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    runnint_loss=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i,data <span class="keyword">in</span> enumerate(trainloader,<span class="number">0</span>):</span><br><span class="line">        inputs,labels=data</span><br><span class="line">        inputs,labels=Variable(inputs),Variable(labels)</span><br><span class="line">        <span class="comment">#注意要将输入数据转化成Variable类型，不然无法训练</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs=net(inputs)</span><br><span class="line">        loss=criterion(outputs,labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        runnint_loss+=loss.item()</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2000</span>==<span class="number">1999</span>:</span><br><span class="line">            print(<span class="string">"[%d,%5d] loss: %3f"</span>%(epoch+<span class="number">1</span>,i+<span class="number">1</span>,runnint_loss/<span class="number">2000</span>))</span><br><span class="line">            runnint_loss=<span class="number">0.0</span></span><br><span class="line">print(<span class="string">"Finish trainning"</span>)</span><br></pre></td></tr></table></figure>

<p>查看第一个batch的数据和标签:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataiter=iter(testloader)</span><br><span class="line">images,labels=dataiter.next()</span><br><span class="line">print(<span class="string">"实际的label:"</span>,<span class="string">" "</span>.join(<span class="string">"%08s"</span>%classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br><span class="line">show(tv.utils.make_grid(images/<span class="number">2</span><span class="number">-0.5</span>)).resize((<span class="number">400</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/eHPAQtow1Cqi8kM.png" alt="image.png"></p>
<p>查看它们的预测结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outputs=net(Variable(images))</span><br><span class="line">_,predicted=t.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"预测结果:"</span>,<span class="string">""</span>.join(<span class="string">"%8s"</span>%classes[predicted[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<p>查看总正确率:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">correct=<span class="number">0</span></span><br><span class="line">total=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">    images,labels=data</span><br><span class="line">    outputs=net(Variable(images))</span><br><span class="line">    _,predicted=t.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#output.data是一个数组，max返回两个值，第一个是最大值，第二个是最大值所在的位置</span></span><br><span class="line">    total+=labels.size(<span class="number">0</span>)</span><br><span class="line">    correct+=(predicted==labels).sum()</span><br><span class="line">    <span class="comment">#根据最大值所在的位置是否跟labels相等可以判断分类是否正确</span></span><br><span class="line">print(<span class="string">"正确率为:%d %%"</span>%(<span class="number">100</span>*correct/total))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">Pthread学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 10:29:25" itemprop="dateCreated datePublished" datetime="2020-04-21T10:29:25+08:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pthread学习笔记2"><a href="#Pthread学习笔记2" class="headerlink" title="Pthread学习笔记2"></a>Pthread学习笔记2</h1><h2 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h2><p>当多个线程同时修改同一个内存地址时，可能会出现奇奇怪怪的问题。我们根据下面的公式编写一个计算π的程序:<img src="https://i.loli.net/2020/04/21/dVu27OrsI835mlX.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %f\n"</span>,sum);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，当线程数大于1的时候会发现，程序输出的结果是不确定的，而且误差也较1个线程的情况大，甚至运行时间也是较长:<br><img src="https://i.loli.net/2020/04/20/A7KSVsQU3rCmfB9.png" alt="image.png"></p>
<p>这种情况被称为临界区问题，当0号线程把sum取到寄存器并执行运算的时候，1号进程也可能同时把sum取到寄存器，然后0号进程把结果写回内存，随后1号进程也把结果写回内存。这样就导致0号进程的计算结果被覆盖掉了，我们称</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样更新共享资源的语句为一个<strong>临界区</strong>。当多个线程尝试更新一个共享资源时，结果可能是无法预测的。更一般地，当多个线程都要访问共享变量或共享文件这样的共享资源时，如果有一个线程执行了更新操作，就可能产生错误，我们称之为<strong>竞争条件</strong>。</p>
<p>临界区问题可以用忙等待、互斥量和信号量等方法来解决。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>一种解决方法是设置一个标记变量，用于指明临界区可以被哪个线程执行，该执行完之后修改这个标记变量，而不能执行临界区的线程必须一直处于忙等待状态。<br>我们可以将代码修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">flag=(flag+<span class="number">1</span>)%thread_count;</span><br></pre></td></tr></table></figure>

<p>flag是我们说到的标记变量，当flag==当前线程号时，可以执行临界区，否则必须处于忙等待状态。执行完之后要修改flag。</p>
<p>运行结果如下:<br><img src="https://i.loli.net/2020/04/20/C9bXnD8ULhNYq5Q.png" alt="image.png"><br>可以看到，结果是正确了，但运行速度满了很多，甚至比单线程的情况还慢。</p>
<p>当然，由于临界区只能被串行执行，我们应该尽量减少临界区执行的次数，比如，我们可以把Thread_sum函数修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  flag=(flag+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个局部变量来代替sum变量，这样循环的过程中就不会有临界区。<br><img src="https://i.loli.net/2020/04/20/dwGW8O47tUgKjS9.png" alt="image.png"><br>运行结果正确，速度上也有提升。</p>
<p>使用忙等待还会有一个问题:</p>
<p>考虑一个最多可以同时执行2个线程的计算机，我们使用忙等待的方法编写一个5个线程的pthreads程序。假设开始时，操作系统运行0号线程和1号线程，这是没有问题的，此时2,3,4三个线程被挂起。然后假设0号线程运行结束，操作系统将其挂起，然后调度3号线程。由于操作系统的线程调度是随机的，它完全不知道此时只有2号线程能进入临界区，所以3号线程只能一直处于忙等待状态，浪费了时间。</p>
<p>所以，当线程数量大于计算机能同时运行的线程数时，使用忙等待的方法可能会产生问题。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>由于处于忙等待的线程会持续地占用CPU资源，所以忙等待并不是一个特别理想的解决临界区问题的方案。我们可以使用互斥量和信号量。</p>
<p>互斥量是互斥锁的简称，是一个特殊类型的变量，它可以保证每次只有一个线程能进入临界区。</p>
<p>互斥量的变量类型是pthread_mutex_t,必须调用 pthread_mutex_init()函数进行初始化。</p>
<p>当线程执行到临界区前面时，应该调用pthread_mutex_lock()函数。如果此时临界区已经被加了锁(即已经有其他线程执行到了这里)，则它会被卡在临界区外等待；否则它会进入临界区，并把临界区加锁。</p>
<p>当临界区被执行完，线程要用pthread_mutex_unlock函数把临界区解锁。此时，系统会从其他等待的线程选出一个进入临界区。如果有多个等待的线程，操作系统选择哪个线程是随机的的。</p>
<p>互斥量使用完之后要用pthread_mutex_destroy函数将其销毁。</p>
<p>互斥量的示例如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://i.loli.net/2020/04/20/NW65oQeM3yJRjTf.png" alt="image.png"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量(semaphore)可以认为是一种特殊类型的unsigned int，它的类型是sem_t。信号量可以赋值为0,1,……。大多数情况下，我们只用0和1两个值。这种只有0和1值的信号量也称为二元信号量。0对应上了锁的互斥量，1对应没上锁的互斥量。</p>
<p>初始化信号量的方法是调用sem_init(),它的原型是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中第二个参数直接置为0就可以了，第三个参数是初始值。</p>
<p>如果我们要用信号量来解决临界区问题，可以先创建一个全局信号量，初始值为1。在临界区前调用sem_wait()函数,这个函数的意义是:如果信号量为0则阻塞；如果是非0值则减1然后进入临界区。临界区执行完之后，调用sem_post()函数将信号量置为1。</p>
<p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;//注意要加这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">sem_t</span> my_semaphore;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sem_wait(&amp;my_semaphore);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %d\n"</span>,my_rank);</span><br><span class="line">  sem_post(&amp;my_semaphore);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  sem_init(&amp;my_semaphore,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用信号量还可以控制线程执行的顺序，如发送消息问题。我们可以给每个线程分配一个信号量，初始化为0，给每个线程一个char*，指向收到的消息。每一个线程把消息放到下一个线程后将下一个线程的信号量置为1，然后等待上一个线程的消息。代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MAX 100</span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">char</span>** messages;</span><br><span class="line"><span class="keyword">sem_t</span>* semaphores;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">long</span> dest=(my_rank+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">char</span>* my_msg=<span class="built_in">malloc</span>(MSG_MAX*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(my_msg,<span class="string">"Hello to %ld from %ld"</span>,dest,my_rank);</span><br><span class="line">  messages[dest]=my_msg;</span><br><span class="line">  sem_post(&amp;semaphores[dest]);</span><br><span class="line">  sem_wait(&amp;semaphores[my_rank]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %ld &gt; %s\n"</span>,my_rank,messages[my_rank]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">2</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  semaphores=(<span class="keyword">sem_t</span>*)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>));</span><br><span class="line">  messages=(<span class="keyword">char</span>**)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示:<br><img src="https://i.loli.net/2020/04/20/4KqbjiQeJC1RFW7.png" alt="image.png"></p>
<p>但如果我们把sem_wait那一行去掉，会出现这样的变化:<br><img src="https://i.loli.net/2020/04/21/rf15jbtTWmpuEoZ.png" alt="image.png"><br>第0号线程没有收到消息的时候就调用printf函数，自然就得不到想要的结果。</p>
<p>像上面这种一个线程需要等待另一个线程执行某种操作的同步方式，有时称为<strong>生产者-消费者同步模型</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">Pthread学习笔记1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 19:59:47" itemprop="dateCreated datePublished" datetime="2020-04-20T19:59:47+08:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pthreads学习笔记1"><a href="#Pthreads学习笔记1" class="headerlink" title="Pthreads学习笔记1"></a>Pthreads学习笔记1</h1><p>Pthreads用共享内存模型进行并行编程。一般地，程序会启动一个主线程，执行main函数中的代码，然后由主线程启动其他的线程。</p>
<h2 id="Pthreads的hello-world程序"><a href="#Pthreads的hello-world程序" class="headerlink" title="Pthreads的hello world程序"></a>Pthreads的hello world程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> thread_count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld of %d\n"</span>,my_rank,thread_count);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">2</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Hello,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello from the main thread\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序里值得注意的是第16行至第22行。<br>第16行定义了一个pthread_t类型的指针。pthread_t用来存储线程的专有信息，可以作为线程的唯一标识，它的数据是由系统进行绑定的，用户无法访问。<br>在第17行，我们用命令行参数来得到线程数量。<br>18行给thread_handles分配了 thread_cound 个 pthread_t 对象的地址空间。<br>19行调用pthread_create()函数,它的原型为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread_p,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr_p,<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*),<span class="keyword">void</span>* arg_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是一个指向pthread_t对象的指针，且必须提前为它分配地址，以便pthread_create修改它指向的内容。第二个参数一般就是NULL，不用管。</p>
<p>第三个参数是一个指针，指向一个函数，这个函数只有一个参数，是一个指向void类型的指针，返回值也是一个指向void类型的指针。</p>
<p>第四个参数是一个指向void类型的指针，用它来给第三个参数指向的函数提供参数。</p>
<p>通过pthread_create()函数我们创建了一个线程，它要做的就是执行第三个参数指向的函数。在第19行里，我们给它的第三个参数是Hello函数，第四个参数是(void*)thread。</p>
<p>在这里，thread变量可以用来标志线程号，把它转化为(void*)指针是为了跟Hello函数的参数列表匹配。此后，在Hello函数里，我们又把它转化为long类型，这样我们就可以得到这个线程的线程号。</p>
<p>第21行调用了pthread_join()函数，顾名思义，它用来等待那个线程的结束。</p>
<p>第22行用来free掉thread_handles数组。</p>
<p>运行的结果如下:<br><img src="https://i.loli.net/2020/04/19/mG2nkLtZyCTsDXW.png" alt="image.png"><br>注意，main函数执行第20行时，其他线程已经启动，所以输出的顺序是不确定的。</p>
<h2 id="矩阵向量乘"><a href="#矩阵向量乘" class="headerlink" title="矩阵向量乘"></a>矩阵向量乘</h2><p>用pthreads编写一个矩阵向量乘的程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n,m;</span><br><span class="line"><span class="keyword">double</span>** A,*x,*y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Pth_mat_vect</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">int</span> i,j,local_m=m/thread_count;</span><br><span class="line">  <span class="keyword">int</span> my_first_row=my_rank*local_m,my_last_row=my_first_row+local_m;</span><br><span class="line">  <span class="keyword">for</span>(i=my_first_row;i&lt;my_last_row;i++)&#123;</span><br><span class="line">    <span class="keyword">double</span> tem=<span class="number">0.0</span>,*A2=A[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">      tem+=A2[j]*x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    y[i]=tem;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  freopen(<span class="string">"out2.txt"</span>,<span class="string">"a"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">4</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  m=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">3</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  A=(<span class="keyword">double</span>**)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>*));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)A[i]=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  x=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  y=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">      A[i][j]=(<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)x[i]=(<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Pth_mat_vect,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">free</span>(A[i]);</span><br><span class="line">  <span class="built_in">free</span>(A),<span class="built_in">free</span>(x),<span class="built_in">free</span>(y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均用时如下:(单位μs)<br>|矩阵大小\线程数|1|2|4|5|8|10|<br>|:-:|:-:|:-:|:-:|:-:|:-:|:-:|<br>|200|337 |282| 378 |895 |698| 969 |<br>|500|803 |562| 625 |543| 829 |956|<br>|1000|2716| 2499 |961 |1349| 1048| 1389|<br>|2000|15894 |5466 |2855 |3469 |2559| 2778|<br>|5000|65230 |30717 |26828 |20336 |13326| 14294|<br>|10000|294865| 133474| 65650 |77883 |50221| 53250|</p>
<p>加速比如下:</p>
<table>
<thead>
<tr>
<th align="center">矩阵大小\线程数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">8</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">1</td>
<td align="center">1.19504</td>
<td align="center">0.891534</td>
<td align="center">0.376536</td>
<td align="center">0.482808</td>
<td align="center">0.347781</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">1</td>
<td align="center">1.42883</td>
<td align="center">1.2848</td>
<td align="center">1.47882</td>
<td align="center">0.968637</td>
<td align="center">0.839958</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">1</td>
<td align="center">1.08683</td>
<td align="center">2.82622</td>
<td align="center">2.01334</td>
<td align="center">2.5916</td>
<td align="center">1.95536</td>
</tr>
<tr>
<td align="center">2000</td>
<td align="center">1</td>
<td align="center">2.90779</td>
<td align="center">5.56708</td>
<td align="center">4.58172</td>
<td align="center">6.21102</td>
<td align="center">5.72138</td>
</tr>
<tr>
<td align="center">5000</td>
<td align="center">1</td>
<td align="center">2.12358</td>
<td align="center">2.43141</td>
<td align="center">3.20761</td>
<td align="center">4.89494</td>
<td align="center">4.56345</td>
</tr>
<tr>
<td align="center">10000</td>
<td align="center">1</td>
<td align="center">2.20916</td>
<td align="center">4.49147</td>
<td align="center">3.786</td>
<td align="center">5.87135</td>
<td align="center">5.53737</td>
</tr>
</tbody></table>
<p>效率如下:</p>
<table>
<thead>
<tr>
<th align="center">矩阵大小\线程数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">8</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">1</td>
<td align="center">0.59752</td>
<td align="center">0.22288</td>
<td align="center">0.075307</td>
<td align="center">0.060351</td>
<td align="center">0.034778</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">1</td>
<td align="center">0.71441</td>
<td align="center">0.3212</td>
<td align="center">0.29576</td>
<td align="center">0.12108</td>
<td align="center">0.083996</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">1</td>
<td align="center">0.54342</td>
<td align="center">0.70656</td>
<td align="center">0.40267</td>
<td align="center">0.32395</td>
<td align="center">0.19554</td>
</tr>
<tr>
<td align="center">2000</td>
<td align="center">1</td>
<td align="center">1.4539</td>
<td align="center">1.3918</td>
<td align="center">0.91634</td>
<td align="center">0.77638</td>
<td align="center">0.57214</td>
</tr>
<tr>
<td align="center">5000</td>
<td align="center">1</td>
<td align="center">1.0618</td>
<td align="center">0.60785</td>
<td align="center">0.64152</td>
<td align="center">0.61187</td>
<td align="center">0.45635</td>
</tr>
<tr>
<td align="center">10000</td>
<td align="center">1</td>
<td align="center">1.1046</td>
<td align="center">1.1229</td>
<td align="center">0.7572</td>
<td align="center">0.73392</td>
<td align="center">0.55374</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/MPI%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/MPI%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">MPI入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 23:09:52" itemprop="dateCreated datePublished" datetime="2020-04-18T23:09:52+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在WSL里安装MPI非常方便，只需执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y build-essential mpich</span><br></pre></td></tr></table></figure>

<p>即可。<br>这样就可以在终端中使用mpi了，但为了方便使用，还需在VSCode中添加路径。<br>在c_cpp_properties.json的includePath中添加”/usr/include/mpich”即可。</p>
<p>用mpi编写一个helloworld程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numprocs, myid;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);<span class="comment">//</span></span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);<span class="comment">//这里myid表示这个进程是第几个进程，如果myid是0则是第一个进程</span></span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);  <span class="comment">//numprocs表示总的进程数量</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"helloworld\n"</span>;</span><br><span class="line">    MPI_Finalize();<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码由许多值得注意的地方：</p>
<p>1.注意不能使用 bits/stdc++ 这个库，否则会出错。</p>
<p>2.main函数要带命令行参数。</p>
<p>3.MPI_Init函数表示从这一行开始，后面的代码会被并行执行，即在每个进程中执行一次。其他的MPI<br>函数必须在MPI_Init函数之后。</p>
<p>4.MPI_Comm_rank函数获得本进程是第几个进程，把进程号存储在myid中。第1个进程(也称为主进程)对应的myid是0，<br>第二个进程对应的myid是1……以此类推。</p>
<p>5.MPI_Comm_size得到进程的数量。</p>
<p>6.在网上查阅资料了解到，MPI_Finalize函数将并行部分终止，除了主进程外的进程都会被终止，主进程的串行部分还可以正常执行。但事实上我在本地运行程序时，MPI_Finalize函数之后的部分还是会被并行执行，我也不知道为什么。</p>
<p>写完之后，就可以在终端执行程序了。</p>
<p><img src="https://i.loli.net/2020/02/28/ApG7uIckXLoWZKF.png" alt="image.png"></p>
<p>用mpic++编译源代码，生成一个名为hw的可执行文件。再用mpirun运行文件，4表示4个进程，所以输出时4个helloworld。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MPI学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 23:09:43" itemprop="dateCreated datePublished" datetime="2020-04-18T23:09:43+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>利用MPI可以加速排序算法。<br>调用c++标准库的sort对1e7的数据进行排序，大约需要2.2秒的时间。</p>
<p><img src="https://i.loli.net/2020/02/27/Qxu9tKsT3dfvIAL.png" alt="15826979841.jpg"></p>
<p>使用MPI将程序并行化，可以大大加快速度。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>将主进程待排序的数组分为两部分，送到两个子进程排序，排完之后再送到主进程，将它们合并起来。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_size=<span class="number">1e7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numprocs, myid, source;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);  </span><br><span class="line">    <span class="keyword">int</span> siz=MAX_size/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(myid==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> *nums=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size+<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_size;i++)&#123;</span><br><span class="line">        nums[i]=rand();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> t1=clock();</span><br><span class="line">      MPI_Send(nums,siz,MPI_INT,<span class="number">1</span>,<span class="number">1</span>,MPI_COMM_WORLD);</span><br><span class="line">      MPI_Send(nums+siz,siz,MPI_INT,<span class="number">2</span>,<span class="number">2</span>,MPI_COMM_WORLD);</span><br><span class="line">      <span class="keyword">int</span>* rec1=<span class="keyword">new</span> <span class="keyword">int</span>[siz+<span class="number">3</span>],*rec2=<span class="keyword">new</span> <span class="keyword">int</span>[siz+<span class="number">3</span>];</span><br><span class="line">      MPI_Recv(rec1,siz,MPI_INT,<span class="number">1</span>,<span class="number">1</span>,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      MPI_Recv(rec2,siz,MPI_INT,<span class="number">2</span>,<span class="number">2</span>,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,loc=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;siz&amp;&amp;j&lt;siz)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec1[i]&lt;rec2[j])nums[loc++]=rec1[i++];</span><br><span class="line">        <span class="keyword">else</span> nums[loc++]=rec2[j++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;siz)nums[loc++]=rec1[i++];</span><br><span class="line">      <span class="keyword">while</span>(j&lt;siz)nums[loc++]=rec2[j++];</span><br><span class="line">      <span class="keyword">int</span> t2=clock();</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;t2-t1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">int</span>* rec=<span class="keyword">new</span> <span class="keyword">int</span>[siz+<span class="number">3</span>];</span><br><span class="line">      MPI_Recv(rec,siz,MPI_INT,<span class="number">0</span>,myid,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      sort(rec,rec+siz);</span><br><span class="line">      MPI_Send(rec,siz,MPI_INT,<span class="number">0</span>,myid,MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概需要1.2秒的时间：<br><img src="https://i.loli.net/2020/02/27/OB5tGf1Q9z38EwJ.png" alt="1582699014283.png"></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>将数组分为4部分，在4个子进程里排序，再两个两个合并起来，最后再送到主进程里合并。总共有7个进程。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_size=<span class="number">1e7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_state</span><span class="params">(<span class="keyword">int</span> myid)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(myid==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(myid&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numprocs, myid, source;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);</span><br><span class="line">    <span class="keyword">int</span> state=get_state(myid);</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span>* nums=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size+<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">int</span> son1=(myid&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,son2=(myid&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_size;i++)nums[i]=rand();</span><br><span class="line">      <span class="keyword">int</span> t1=clock();</span><br><span class="line">      MPI_Send(nums,MAX_size/<span class="number">2</span>,MPI_INT,son1,myid*numprocs+son1,MPI_COMM_WORLD);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Send(nums+MAX_size/<span class="number">2</span>,MAX_size/<span class="number">2</span>,MPI_INT,son2,myid*numprocs+son2,MPI_COMM_WORLD);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span>* rec1=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">2</span>+<span class="number">3</span>],*rec2=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">2</span>+<span class="number">3</span>];</span><br><span class="line">      MPI_Recv(rec1,MAX_size/<span class="number">2</span>,MPI_INT,son1,myid*numprocs+son1,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Recv(rec2,MAX_size/<span class="number">2</span>,MPI_INT,son2,myid*numprocs+son2,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,size=MAX_size/<span class="number">2</span>,loc=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;size&amp;&amp;j&lt;size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec1[i]&lt;rec2[j])&#123;</span><br><span class="line">          nums[loc++]=rec1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          nums[loc++]=rec2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;size)&#123;nums[loc++]=rec1[i++];&#125;</span><br><span class="line">      <span class="keyword">while</span>(j&lt;size)&#123;nums[loc++]=rec2[j++];&#125;</span><br><span class="line"><span class="comment">//      for(int i=0;i&lt;MAX_size;i++)cout&lt;&lt;nums[i]&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span> t2=clock();</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;t2-t1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(state==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span>* nums=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">2</span>+<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">int</span>* rec1=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">4</span>+<span class="number">3</span>],*rec2=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">int</span> son1=(myid&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,son2=(myid&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>,fa=(myid<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      MPI_Recv(nums,MAX_size/<span class="number">2</span>,MPI_INT,fa,fa*numprocs+myid,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Send(nums,MAX_size/<span class="number">4</span>,MPI_INT,son1,myid*numprocs+son1,MPI_COMM_WORLD);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Send(nums+MAX_size/<span class="number">4</span>,MAX_size/<span class="number">4</span>,MPI_INT,son2,myid*numprocs+son2,MPI_COMM_WORLD);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Recv(rec1,MAX_size/<span class="number">4</span>,MPI_INT,son1,myid*numprocs+son1,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      MPI_Recv(rec2,MAX_size/<span class="number">4</span>,MPI_INT,son2,myid*numprocs+son2,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      <span class="comment">//cout&lt;&lt;myid&lt;&lt;" "&lt;&lt;son1&lt;&lt;" "&lt;&lt;son2&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,size=MAX_size/<span class="number">4</span>,loc=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;size&amp;&amp;j&lt;size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec1[i]&lt;rec2[j])&#123;</span><br><span class="line">          nums[loc++]=rec1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          nums[loc++]=rec2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;size)&#123;nums[loc++]=rec1[i++];&#125;</span><br><span class="line">      <span class="keyword">while</span>(j&lt;size)&#123;nums[loc++]=rec2[j++];&#125;</span><br><span class="line">      MPI_Send(nums,MAX_size/<span class="number">2</span>,MPI_INT,fa,fa*numprocs+myid,MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">int</span>* nums=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size/<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">int</span> fa=(myid<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      MPI_Recv(nums,MAX_size/<span class="number">4</span>,MPI_INT,fa,fa*numprocs+myid,MPI_COMM_WORLD,&amp;status)；</span><br><span class="line"><span class="comment">//      cout&lt;&lt;myid&lt;&lt;endl;</span></span><br><span class="line">      sort(nums,nums+MAX_size/<span class="number">4</span>);</span><br><span class="line">      MPI_Send(nums,MAX_size/<span class="number">4</span>,MPI_INT,fa,fa*numprocs+myid,MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;"??\n";</span></span><br><span class="line">    MPI_Finalize();</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;myid&lt;&lt;"end\n";</span></span><br><span class="line">&#125; <span class="comment">/* end main */</span></span><br></pre></td></tr></table></figure>

<p>这种方法大约需要0.87秒：<br><img src="https://i.loli.net/2020/02/27/puQ9KAsJ7VDLr2W.png" alt="1582699491051.png"></p>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>将数组分到多个进程里排序，再送回主进程，直接进行排序：<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_size=<span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numprocs, myid, source;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);  </span><br><span class="line">    <span class="keyword">int</span> sub_size=MAX_size/(numprocs<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> siz[<span class="number">104</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numprocs;i++)siz[i]=MAX_size/(numprocs<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX_size%(numprocs<span class="number">-1</span>);i++)siz[i]++;</span><br><span class="line">    <span class="keyword">if</span>(!myid)&#123;</span><br><span class="line">      <span class="keyword">int</span>* num=<span class="keyword">new</span> <span class="keyword">int</span>[MAX_size];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_size;i++)num[i]=rand();</span><br><span class="line">      <span class="keyword">int</span> t1=clock();</span><br><span class="line">      <span class="keyword">int</span> loc[numprocs]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,*tem=num;i&lt;numprocs;i++,tem+=siz[i])&#123;</span><br><span class="line">  <span class="comment">//      cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        MPI_Send(tem,siz[i],MPI_INT,i,i,MPI_COMM_WORLD);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span>** ans=<span class="keyword">new</span> <span class="keyword">int</span>*[numprocs];</span><br><span class="line"><span class="comment">//      cout&lt;&lt;"??\n";</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numprocs;i++)&#123;</span><br><span class="line">        ans[i]=<span class="keyword">new</span> <span class="keyword">int</span>[siz[i]+<span class="number">3</span>];</span><br><span class="line">        MPI_Recv(ans[i],siz[i],MPI_INT,i,i,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_size;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minval=(<span class="number">1l</span>l&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>,locc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numprocs;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(loc[i]&lt;siz[i]&amp;&amp;ans[i][loc[i]]&lt;minval)minval=ans[i][loc[i]],locc=i;</span><br><span class="line">        &#125;</span><br><span class="line">        num[i]=minval,loc[locc]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> t2=clock();</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;t2-t1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">int</span>* num=<span class="keyword">new</span> <span class="keyword">int</span>[siz[myid]+<span class="number">3</span>];</span><br><span class="line">      MPI_Recv(num,siz[myid],MPI_INT,<span class="number">0</span>,myid,MPI_COMM_WORLD,&amp;status);</span><br><span class="line">      sort(num,num+siz[myid]);</span><br><span class="line">      MPI_Send(num,siz[myid],MPI_INT,<span class="number">0</span>,myid,MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对进程数量分别为4,5,6,7,8的情况做了5次实验，结果如下(单位为μs)：</p>
<table>
<thead>
<tr>
<th>进程数</th>
<th>平均用时</th>
<th>最短用时</th>
<th>最长用时</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>996875</td>
<td>984375</td>
<td>1015625</td>
</tr>
<tr>
<td>5</td>
<td>868750</td>
<td>843750</td>
<td>890625</td>
</tr>
<tr>
<td>6</td>
<td>865625</td>
<td>843750</td>
<td>890625</td>
</tr>
<tr>
<td>7</td>
<td>890625</td>
<td>875000</td>
<td>906250</td>
</tr>
<tr>
<td>8</td>
<td>906250</td>
<td>859375</td>
<td>953125</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2020/02/27/wOnageDTA9Ktvux.png" alt="1582702015001.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">MPI学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 18:44:53" itemprop="dateCreated datePublished" datetime="2020-04-18T18:44:53+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MPI学习笔记2"><a href="#MPI学习笔记2" class="headerlink" title="MPI学习笔记2"></a>MPI学习笔记2</h1><h2 id="集合通信"><a href="#集合通信" class="headerlink" title="集合通信"></a>集合通信</h2><p>MPI_Send和MPI_Recv可以实现不同进程之间的通信，但如果要跟很多进程发消息，或者要接受很多进程发送的消息，这样就太过麻烦。为此，MPI提供了一系列称为集合通信的函数，它涉及通信子之间的所有进程的通信。</p>
<h3 id="MPI-Reduce"><a href="#MPI-Reduce" class="headerlink" title="MPI_Reduce"></a>MPI_Reduce</h3><p>MPI_Reduce用于实现高效的全局运算，如求和，求最大值等。原型如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce</span><span class="params">(<span class="keyword">void</span>* input_data_p,<span class="keyword">void</span>* output_data_p,<span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype datatype,MPI_Op <span class="keyword">operator</span>,<span class="keyword">int</span> dest_process,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于每个进程，我们调用MPI_Reduce，然后对目的进程，output_data_p指向的值会与每个进程的input_data_p指向的值进行运算。如果count参数的值大于1，则运算会在数组上进行。<br>支持的运算有:<br>|运算符值|含义|<br>|-|-|<br>|MPI_MAX|求最大值|<br>|MPI_MIN|求最小值|<br>|MPI_SUM|求累加和|<br>|MPI_PROD|求累乘值|<br>|MPI_LAND|逻辑与|<br>|MPI_BAND|按位与|<br>|MPI_LOR|逻辑或|<br>|MPI_BOR|按位或|<br>|MPI_LOR|逻辑异或|<br>|MPI_BOR|按位异或|<br>|MPI_MAXLOC|求最大值和最大值所在的位置|<br>|MPI_MINLOC|求最小值和最小值所在的位置|</p>
<p>一个示例程序如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> val=my_rank*my_rank,sum=<span class="number">0</span>;</span><br><span class="line">  MPI_Reduce(&amp;val,&amp;sum,<span class="number">1</span>,MPI_INT,MPI_SUM,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两点值得注意:<br>1.第一个参数和第二个参数的指针不能相同，否则会得到非法的结果。<br>2.对于不是目标进程的进程，第二个参数实际上是没有作用的，可以置为NULL。</p>
<h2 id="MPI-Allreduce"><a href="#MPI-Allreduce" class="headerlink" title="MPI_Allreduce"></a>MPI_Allreduce</h2><p>有时候，我们不仅需要全局运算，还需要把结果放到每个进程里，这时候可以调用MPI_Allreduce函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allreduce</span><span class="params">(<span class="keyword">void</span>* input_data_p,<span class="keyword">void</span>* output_data_p,<span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype datatype MPI_OP <span class="keyword">operator</span>,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数的意义基本与MPI_Reduce相同，不再赘述。<br>用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> val=my_rank*my_rank,sum=<span class="number">0</span>;</span><br><span class="line">  MPI_Allreduce(&amp;val,&amp;sum,<span class="number">1</span>,MPI_INT,MPI_SUM,MPI_COMM_WORLD);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MPI-Bcast"><a href="#MPI-Bcast" class="headerlink" title="MPI_Bcast"></a>MPI_Bcast</h2><p>有时候，我们需要将一个进程里的数据发送到通信子中的所有进程，这是可以调用MPI_Bcast函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Bcast</span><span class="params">(<span class="keyword">void</span>* data_p,<span class="keyword">int</span> count,MPI_Datatype datatype,<span class="keyword">int</span> souce_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，data_p在发送进程里为输入参数，在其他进程里为输出参数，用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span>* s=<span class="string">"hello world!\n"</span>;</span><br><span class="line">    MPI_Bcast(s,<span class="built_in">strlen</span>(s)+<span class="number">1</span>,MPI_CHAR,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    MPI_Bcast(s,<span class="number">14</span>,MPI_CHAR,<span class="number">0</span>,MPI_COMM_WORLD);<span class="comment">//注意，这里s还是空字符串，不能用strlen确定长度。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In process %d,s is %s"</span>,my_rank,s);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MPI-Scatter"><a href="#MPI-Scatter" class="headerlink" title="MPI_Scatter"></a>MPI_Scatter</h3><p>假如在主进程里有一个长为100的数组，要把它分到10个进程里，其中0号进程分到前10个元素，1号进程分到第10个到第19个元素……这时可以调用MPI_Scatter函数来进行分发:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Scatter</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,<span class="keyword">int</span> recv_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype recv_type,<span class="keyword">int</span> src_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>假如数组大小为n，通信子里共有comm_sz个进程，则MPI_Scatter会把数组分为comm_xz份，每份有$local_n=\frac{n}{comm_xz}$个。此时send_count和recv_count应被置为local_n，因为send_count表示的是发送到每个进程的数据量，recv_count表示每个进程接收到的数据量。</p>
<p>一个示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span>* b=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n/comm_sz*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span>* a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Scatter(a,n/comm_sz,MPI_INT,b,n/comm_sz,MPI_INT,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Scatter(<span class="literal">NULL</span>,n/comm_sz,MPI_INT,b,n/comm_sz,MPI_INT,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/comm_sz;i++)<span class="built_in">printf</span>(<span class="string">"In process %d, b[%d]=%d\n"</span>,my_rank,i,b[i]);</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，跟MPI_Reduce一样，MPI_Scatter的两个指针参数不能相同，而且非目的进程的send_buff_p可以是NULL。</p>
<h3 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a>MPI_Gather</h3><p>有了把数据发出去的方法，自然会有把数据收集起来的方法，它是MPI_Gather:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Gather</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> recv_count,MPI_Datatype recv_type,<span class="keyword">int</span> dest_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用法和注意事项 与MPI_Scatter差不多，不再赘述</p>
<h3 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a>MPI_Allgather</h3><p>MPI_Allgather与 MPI_Gather的关系有点类似MPI_allreduce与MPI_Reduce的关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Gather</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> recv_count,MPI_Datatype recv_type,<span class="keyword">int</span> dest_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于将数据串联起来，存储到每个进程的recv_buf_p参数中。</p>
<h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><p>用上述集合通信的方法实现矩阵向量乘法的并行化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_rand</span><span class="params">(<span class="keyword">double</span>* vec,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)vec[i]=(<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mat_vec_mul2</span><span class="params">(<span class="keyword">double</span>* local_A,<span class="keyword">double</span>* x,<span class="keyword">double</span>* local_y,<span class="keyword">int</span> local_m,<span class="keyword">int</span> n,<span class="keyword">int</span> local_n,MPI_Comm comm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> local_i,j,local_ok=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(local_i=<span class="number">0</span>;local_i&lt;local_m;local_i++)&#123;</span><br><span class="line">    local_y[local_i]=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)local_y[local_i]+=local_A[local_i*n+j]*x[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m,n,local_m,local_n;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">  <span class="built_in">sscanf</span>(argv[<span class="number">2</span>],<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  local_m=m/comm_sz,local_n=n/comm_sz;</span><br><span class="line">  <span class="keyword">double</span>* local_A,* local_x,* local_y;</span><br><span class="line">  local_A=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_m*n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  local_x=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  local_y=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">double</span> *x=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* A=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">double</span>* y=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>)),*y2=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    my_rand(A,m*n),my_rand(x,n);</span><br><span class="line">    MPI_Scatter(A,local_m*n,MPI_DOUBLE,local_A,local_m*n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(x,n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    Mat_vec_mul2(local_A,x,local_y,local_m,n,local_n,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Gather(local_y,local_m,MPI_DOUBLE,y,local_m,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time: %d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line">    <span class="comment">//  for(int i=0;i&lt;m;i++)cout&lt;&lt;y[i]&lt;&lt;" "&lt;&lt;y2[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">free</span>(A),<span class="built_in">free</span>(y),<span class="built_in">free</span>(y2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Scatter(<span class="literal">NULL</span>,local_m*n,MPI_DOUBLE,local_A,local_m*n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(x,n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    Mat_vec_mul2(local_A,x,local_y,local_m,n,local_n,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Gather(local_y,local_m,MPI_DOUBLE,<span class="literal">NULL</span>,local_m,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(local_A);<span class="built_in">free</span>(local_y);<span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个程序使用了多进程的方式进行了优化，但事实上运行时间远远大于串行的版本:</p>
<p>并行：<br><img src="https://i.loli.net/2020/04/18/m9ekwjVqoBa5Ylz.png" alt="image.png"></p>
<p>串行：<br><img src="https://i.loli.net/2020/04/18/G52aMcmoqxkrdhP.png" alt="image.png"></p>
<h2 id="MPI派生数据类型"><a href="#MPI派生数据类型" class="headerlink" title="MPI派生数据类型"></a>MPI派生数据类型</h2><p>显然，进程之间通信是非常非常慢的。如果主进程要往其他进程广播一个整数，两个浮点数，有没有方法能用一次通信的方法解决呢？<br>MPI为了解决这个问题，提供了用户自定义的派生数据类型。<br>我们可以用MPI_Type_create_struct函数创建由不同基本数据类型的元素所组成的派生数据类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Type_create_struct</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> array_of_clocklengths[],</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Aint array_of_displacements[],MPI_Datatype array_of_types[],MPI_Datatype* new_type_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数表明我们创建的数据类型有多少个元素；第二个参数表示每个元素是单个的数据还是一个数组；第三个参数表示每个元素相对于第一个元素的内存地址偏移量；第四个参数表示每个元素的类型；第5个参数表示创建的类型。</p>
<p>比如我们要创建一种数据类型，包含一个int，两个double，可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b,c;</span><br><span class="line">MPI_Aint a_addr,b_addr,c_addr;</span><br><span class="line">MPI_Get_address(&amp;a,&amp;a_addr);</span><br><span class="line">MPI_Get_address(&amp;b,&amp;b_addr);</span><br><span class="line">MPI_Get_address(&amp;c,&amp;c_addr);</span><br><span class="line">MPI_Aint array_of_displacements[<span class="number">3</span>]=&#123;<span class="number">0</span>,b_addr-a_addr,c_addr-a_addr&#125;;</span><br><span class="line"><span class="keyword">int</span> array_of_blocklengths[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">MPI_Datatype array_of_types[<span class="number">3</span>]=&#123;MPI_INT,MPI_DOUBLE,MPI_DOUBLE&#125;;</span><br><span class="line">MPI_Datatype <span class="keyword">input_mpi_t</span>;</span><br><span class="line">MPI_Type_create_struct(<span class="number">3</span>,array_of_blocklengths,array_of_displacements,array_of_types,&amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line">MPI_Type_commit(&amp;<span class="keyword">input_mpi_t</span>);</span><br></pre></td></tr></table></figure>

<p>MPI_Get_address()用于获得第一个指针参数的绝对地址，把这个地址赋值给第二个参数指向的地址空间。<br>再调用完MPI_Type_create_struct()函数之后，还需要调用MPI_Type_commit()函数向通信子提交这一数据类型。之后，就可以像使用普通数据类型一样使用input_mpi_t了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    a=<span class="number">1</span>,b=<span class="number">1.1</span>,c=<span class="number">2.2</span>;</span><br><span class="line">    MPI_Bcast(&amp;a,<span class="number">1</span>,<span class="keyword">input_mpi_t</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Bcast(&amp;a,<span class="number">1</span>,<span class="keyword">input_mpi_t</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In process %d: a=%d b=%f c=%f\n"</span>,my_rank,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">fat12文件系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:45:27" itemprop="dateCreated datePublished" datetime="2020-04-15T12:45:27+08:00">2020-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="fat12文件系统仿真实验报告"><a href="#fat12文件系统仿真实验报告" class="headerlink" title="fat12文件系统仿真实验报告"></a>fat12文件系统仿真实验报告</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>&#8195;&#8195;本实验目的在于学习fat12文件系统，增强编写C语言、C++语言和汇编语言程序的的能力，为进一步学习操作系统相关知识做好准备。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><h3 id="总体要求"><a href="#总体要求" class="headerlink" title="总体要求"></a>总体要求</h3><p>&#8195;&#8195;用c、c++或汇编与c组合，编写一个具有下列功能的可视化或命令操作的FAT12文件系统仿真程序</p>
<h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><p>&#8195;&#8195;用c、c++或汇编与c组合，编写一个具有下列功能的可视化或命令操作的程序:</p>
<p>&#8195;&#8195;1.查看fdd144虚拟软盘的第一个扇区内容是否符合FAT12格式。<br>&#8195;&#8195;2.检查fdd144虚拟软盘的FAT12格式各部分信息是否一致完整。<br>&#8195;&#8195;3.列出fdd144虚拟软盘中根目录文件目录内容。<br>&#8195;&#8195;4.列出fdd144虚拟软盘中目录树。<br>&#8195;&#8195;5.提供一个输入框，输入任意字符，创建一个文件保存这些输入的字符。<br>&#8195;&#8195;6.删除根目录的一个指定文件<br>&#8195;&#8195;7.实现按路径名操作文件<br>&#8195;&#8195;8.显示一个文件的内容<br>&#8195;&#8195;9.编辑文件的内容<br>&#8195;&#8195;10.复制文件，2个文件合并为一个文件。<br>&#8195;&#8195;11.建立子目录<br>&#8195;&#8195;12.删除子目录<br>&#8195;&#8195;13.其他</p>
<h2 id="实验方案与过程"><a href="#实验方案与过程" class="headerlink" title="实验方案与过程"></a>实验方案与过程</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>&#8195;&#8195;首先通过WinImage软件创建一个虚拟软盘，往里面添加文件，保存后得到一个fat12格式的软盘。为了方便验证结果是否正确，我使用了HexView工具来查看软盘的内容。编写代码时，我主要在WSL(一个可以在windows操作系统下运行的linux简化版)系统下使用VSCode编辑器，用c语言和c++语言进行编程。</p>
<h3 id="fat12文件系统相关知识"><a href="#fat12文件系统相关知识" class="headerlink" title="fat12文件系统相关知识"></a>fat12文件系统相关知识</h3><p>&#8195;&#8195;一块1.44MB的fat12格式的软盘共有2880个扇区，每个扇区512占个字节。其中第0个扇区称为主引导扇区;第1-9扇区为fat表;第10-18扇区是fat表的复制版;第19-32扇区为根目录区;从第33扇区往后为数据区。</p>
<p>&#8195;&#8195;字节和扇区在fat12文件系统中是两个相当重要的概念，为此，我们在程序中定义bt这个结构体来表示字节，sector这个结构体来表示扇区。为了方便行文，先给出它们的定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">byte</span>//用<span class="title">byte</span>和<span class="title">bt</span>来表示字节</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">9</span>];<span class="comment">//把字节用01字符串表示</span></span><br><span class="line">    <span class="keyword">char</span> h, l;<span class="comment">//把字节用16进制表示，h为高4位，l为低4位</span></span><br><span class="line">    uc ascii;<span class="comment">//这个字节的值，uc是unsigned char</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;<span class="comment">//从输入流中读取一个字节</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">from_char</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line">&#125; bt;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    bt bs[SIZE_OF_SECTOR];<span class="comment">//SIZE_OF_SECTOR默认是512</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;<span class="comment">//从输入流中读取扇区</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input_from_string</span><span class="params">(<span class="built_in">string</span> a)</span></span>;<span class="comment">//从一个长为512的字符串中读取扇区</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;<span class="comment">//打印扇区内容，方便调试</span></span><br><span class="line">    bt <span class="keyword">operator</span>[](<span class="keyword">int</span> i);<span class="comment">//按下标取出一个字节</span></span><br><span class="line">&#125; sector;</span><br></pre></td></tr></table></figure>

<h4 id="创建软盘"><a href="#创建软盘" class="headerlink" title="创建软盘"></a>创建软盘</h4><p>&#8195;&#8195;我们使用WinImage工具创建软盘。<br>&#8195;&#8195;打开WinImage，点击左上角的文件、新建，然后确定，就创建了一块软盘，我们可以往里面添加文件，我随便拖了两个文件进去，结果如下<br><img src="https://i.loli.net/2020/04/01/SsDBwxbyukm4Hvo.png" alt="image.png"><br>&#8195;&#8195;按ctrl+s，将其保存为vfd文件。<br>&#8195;&#8195;然后就可以通过HexView工具打开它。</p>
<h4 id="引导扇区"><a href="#引导扇区" class="headerlink" title="引导扇区"></a>引导扇区</h4><p>&#8195;&#8195;引导扇区主要记录了软盘的相关信息和引导扇区程序。启动计算机时，BIOS程序通过读入引导扇区中的引导扇区程序来启动操作系统。引导扇区的内容如下表所示:<br>(下表主要参考CSDN博客<a href="https://blog.csdn.net/begginghard/article/details/7284834?depth_1-utm_source=distribute.pc_relevant_right.none-task&amp;utm_source=distribute.pc_relevant_right.none-task" target="_blank" rel="noopener">https://blog.csdn.net/begginghard/article/details/7284834?depth_1-utm_source=distribute.pc_relevant_right.none-task&amp;utm_source=distribute.pc_relevant_right.none-task</a>)<br>|名称|开始字节|长度|内容|参考值|<br>|–|–|–|–|–|<br>|BS_jmpBOOT|0|3|一个短跳转指令|0xEB 0x58 0x90|<br>|BS_OEMName|3|8|厂商名|’ZGH’|<br>|BPB_BytesPerSec|11|2|每扇区字节数（Bytes/Sector）|0x200|<br>|BPB_SecPerClus|13|1|每簇扇区数（Sector/Cluster）|0x1|<br>|BPB_ResvdSecCnt|14|2|Boot记录占用多少扇区|ox1|<br>|BPB_NumFATs|16|1|共有多少FAT表|0x2|<br>|BPB_RootEntCnt|17|2|根目录区文件最大数|0xE0|<br>|BPB_TotSec16|19|2|扇区总数|0xB40|<br>|BPB_Media|21|1|介质描述符|0xF0|<br>|BPB_FATSz16|22|2|每个FAT表所占扇区数|0x9|<br>|BPB_SecPerTrk|24|2|每磁道扇区数（Sector/track）|0x12|<br>|BPB_NumHeads|26|2|磁头数（面数）|0x2|<br>|BPB_HiddSec|28|4|隐藏扇区数|0|<br>|BPB_TotSec32|32|4|如果BPB_TotSec16=0,则由这里给出扇区数|0|<br>|BS_DrvNum|36|1|INT|13H的驱动器号|<br>|0|BS_Reserved1|37|1|保留，未使用|<br>|0|BS_BootSig|38|1|扩展引导标记(29h)|<br>|0x29|BS_VolID|39|4|卷序列号|<br>|0|BS_VolLab|43|11|卷标|<br>|’ZGH’|BS_FileSysType|54|8|文件系统类型|<br>|引导扇区程序|62|448|引导代码及其他数据|引导代码（剩余空间用0填充）|<br>|结束标志0xAA55|510|2|第510字节为0x55，第511字节为0xAA|0xAA55|</p>
<p>&#8195;&#8195;BIOS程序通过识别结束标志判断该软盘是否符合fat12格式。</p>
<p>&#8195;&#8195;在程序中，我们需要将软盘中的第一个扇区读入程序中，并判断它是否符合fat12格式。由于引导扇区本身就是一个扇区，所以定义sector的子类MBR，用以表示一个扇区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MBR</span>:</span><span class="keyword">public</span> sector&#123;</span><br><span class="line">    <span class="keyword">char</span> BS_OEMName[<span class="number">8</span>]; <span class="comment">// OEM字符串，必须为8个字符，不足以空格填空 </span></span><br><span class="line">    short BPB_BytsPerSec; <span class="comment">// 每扇区字节数 </span></span><br><span class="line">    <span class="keyword">char</span> BPB_SecPerClus; <span class="comment">// 每簇占用的扇区数 </span></span><br><span class="line">    short BPB_RsvdSecCnt; <span class="comment">// Boot占用的扇区数 </span></span><br><span class="line">    <span class="keyword">char</span> BPB_NumFATs; <span class="comment">// FAT表的记录数 </span></span><br><span class="line">    short BPB_RootEntCnt; <span class="comment">// 最大根目录文件数 </span></span><br><span class="line">    short BPB_TotSec16; <span class="comment">// 扇区总数 </span></span><br><span class="line">    <span class="keyword">char</span> BPB_Media; <span class="comment">// 媒体描述符 </span></span><br><span class="line">    short BPB_FATSz16; <span class="comment">// 每个FAT占用扇区数 </span></span><br><span class="line">    short BPB_SecPerTrk; <span class="comment">// 每个磁道扇区数 </span></span><br><span class="line">    short BPB_NumHeads; <span class="comment">// 磁头数 </span></span><br><span class="line">    <span class="keyword">int</span> BPB_HiddSec; <span class="comment">// 隐藏扇区数 </span></span><br><span class="line">    <span class="keyword">int</span> BPB_TotSec32; <span class="comment">// 如果BPB_TotSec16是0，则在这里记录 </span></span><br><span class="line">    <span class="keyword">char</span> BS_DrvNum; <span class="comment">// 中断13的驱动器号 </span></span><br><span class="line">    <span class="keyword">char</span> BS_Reserved1; <span class="comment">// 未使用 </span></span><br><span class="line">    <span class="keyword">char</span> BS_BootSig; <span class="comment">// 扩展引导标志 </span></span><br><span class="line">    <span class="keyword">int</span> BS_VolID; <span class="comment">// 卷序列号 </span></span><br><span class="line">    <span class="keyword">char</span> BS_VolLab[<span class="number">11</span>]; <span class="comment">// 卷标，必须是11个字符，不足以空格填充 </span></span><br><span class="line">    <span class="keyword">char</span> BS_FileSysType[<span class="number">8</span>];<span class="comment">// 文件系统类型，8个字符，不足填充空格</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;<span class="comment">//用于读入后初始化各个变量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>;<span class="comment">//用于检查MBR是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>&amp; Byte_Per_Sector,<span class="keyword">int</span>&amp; Sector_Per_Cluster,<span class="keyword">int</span>&amp; Num_Of_Fats,<span class="keyword">int</span>&amp; Root_Entry_Count,<span class="keyword">int</span>&amp; Num_Of_Sector,<span class="keyword">int</span>&amp; Size_Of_Fat,<span class="keyword">int</span>&amp; Sector_Hidden)</span></span>;<span class="comment">//用于显示提示信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;在程序开始时，我们首先读入MBR，调用init()函数对各个变量进行赋值；再检查它的前三个字节是否为0xeb 0x58 0x90;然后检查各个变量是否符合默认值；最后看结束标志是否为 0xaa55。如果发现问题，则给出提示信息并中止程序。如果检查正确，则调用print()函数输出各项信息。</p>
<h4 id="fat区"><a href="#fat区" class="headerlink" title="fat区"></a>fat区</h4><p>&#8195;&#8195;fat区共有18个扇区，其中后9个扇区是前9个扇区的副本。fat12文件系统启动时，需要检查这两部分是否一样。我们将前9个扇区称为fat表。从名字中就可以看出，fat表是fat12文件系统的核心。</p>
<p>&#8195;&#8195;在fat12文件系统中，文件存储是以簇为单位的，一般情况下，一个簇就是一个扇区，所以下文将簇与扇区划等号。对于一个文件，如果它的大小小于512字节，则在数据区中给它分配一个簇，将它的内容写进这个簇里，然后将fat表中这个簇对应的值(下文会详述这种对应的方式)修改为一个特殊的结束标志。</p>
<p>&#8195;&#8195;如果它的大小大于等于512字节呢？首先还是分配簇a，将文件的前512个字节写进簇a里，然后再分配一个簇b，将fat表中簇a对应的值修改为一个值，通过这个值我们能找到b扇区，然后再分配一个簇c，将fat表中簇b对应的值修改为一个值，通过这个值我们能找到簇c……一直这样下去，直至文件结束，将分配的最后一个簇在fat表中对应的值修改为结束标志。</p>
<p>&#8195;&#8195;这样，读文件时，只需知道这个文件开始的簇，就可以读下一个簇，下下个簇……直到在fat表里读到结束标志为止。</p>
<p>&#8195;&#8195;下图是一个fat表的开头：(这个fat表不是刚才创建的软盘的fat表)<br><img src="https://i.loli.net/2020/03/30/NUZMQVGdKsD8uCb.png" alt="image.png"><br>&#8195;&#8195;fat12文件系统中的”12”是什么意思呢？12是指一个fat表中12个bit组成一个fat表项，而我们知道一个字节是8个bit，所以fat表中，3个字节组成两个fat表项。</p>
<p>&#8195;&#8195;既然如此，fat表该怎么读呢？如果你以为是顺着读，就太naive了。我们知道x86系统采用小端存储方式，就是说，低字节存储在高地址位中(高地址位就是地址值较小)。比如说，一个16位整数0000000011111111，在x86系统中会先存11111111(低字节),再存00000000(高字节)。<br>了解了这些，我们再来看fat表。前3个字节是 0xf0 0xff 0xff。我们把第二个字节的低四位拿出来，跟第一个字节拼在一起，组成0xff0(注意不是0xf0f)，它就是fat表的第一个表项了。再把第三个字节拿出来，和第二个字节的高四位拼在一起，组成 0xfff，它就是第二个表项了，如下图所示：<br>![CEU3__8__V6@DE2`GG9IHO1.png](<a href="https://i.loli.net/2020/03/30/7RItOHvzNwFl6D5.png" target="_blank" rel="noopener">https://i.loli.net/2020/03/30/7RItOHvzNwFl6D5.png</a>)<br>&#8195;&#8195;按这个规则读下去，第三个表项就是0xfff，第四个表项是0x004……</p>
<p>&#8195;&#8195;现在我们知道如何读这个fat表了。但问题来了，读出来的值有什么用呢？fat表中读出的第一个值表示坏簇标志，一般为0xff0，第二个值是结束标志，一般为0xfff。后续的每个值代表这个簇的下个簇的簇号。如第三个值为0x004，代表第一个簇(前两个值不算)对应的下一个簇是第二个簇，第四个值为0xfff，表示这个文件到第二个簇这里就结束了。</p>
<p>&#8195;&#8195;在程序中，我们定义一个fat结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Fat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;bt&gt; bts;<span class="comment">//存储fat表的每一个字节</span></span><br><span class="line">    bt <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> bts[i]; &#125;<span class="comment">//按下标访问fat表中的字节</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cluster_numbers;<span class="comment">//将fat表转换成一个整数数组，前三个字节没有包含在内</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(MBR mbr)</span></span>;<span class="comment">/*初始化，由于fat表的实际长度是大于数据区扇区数的，所以要将后面一部分切掉，这</span></span><br><span class="line"><span class="comment">    个长度需要MBR中的一些变量来确定*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_first_empty</span><span class="params">()</span></span>;<span class="comment">//从fat表中读出一个空的簇号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_floopy</span><span class="params">()</span></span>;<span class="comment">//将fat表写回软盘</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_empty</span><span class="params">()</span></span>;<span class="comment">//得到fat表中有多少个未被使用的簇和坏簇，用于检查是否有"孤魂野鬼"簇</span></span><br><span class="line">&#125; fat;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;程序开始时还是先把fat表读进来，并检查两个fat表是否一致，不一致就报错。然后统计空闲簇和坏簇的数量。</p>
<h4 id="根目录区与数据区"><a href="#根目录区与数据区" class="headerlink" title="根目录区与数据区"></a>根目录区与数据区</h4><p>&#8195;&#8195;根目录区占14个扇区，由于前面已经用了19个扇区(引导扇区1个，fat18个)，所以根目录区是从第19个扇区开始的，起始位置是0x2600。根目录里每32字节构成了一个文件记录，记录了这个文件的基本信息，我们可以根据这个记录来找到文件的内容。</p>
<p>&#8195;&#8195;在程序中，我们定义rootentry类来表示根目录区，它比较简单，只有一个bt类型的数组，也不需要检查什么东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RootEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;bt&gt; bts;</span><br><span class="line"></span><br><span class="line">&#125; rootentry;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;从第33个扇区往后的扇区都是数据区，每个扇区512字节。定义datas类表示数据区。数据区一般包含2847个扇区，所以定义一个sector数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Datas</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;sector&gt; secs;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_floopy</span><span class="params">(<span class="keyword">int</span> clus_num, <span class="built_in">string</span> content)</span></span>;<span class="comment">/*这个函数用于写回软盘</span></span><br><span class="line"><span class="comment">    在程序种写回软盘是以扇区为单位的。第一个参数表示写的是数据区第几个扇区，content是一个512字节的数组表示要写的内容。*/</span></span><br><span class="line">&#125; datas;</span><br></pre></td></tr></table></figure>

<h4 id="文件与文件夹"><a href="#文件与文件夹" class="headerlink" title="文件与文件夹"></a>文件与文件夹</h4><p>&#8195;&#8195;文件的读写是fat12文件系统的重点。我们先来了解文件是怎么组织的。</p>
<p>&#8195;&#8195;一个文件会有一个32个字节的文件记录，这个文件记录存储在这个文件所属的文件夹里，包含了这个文件的各种信息:</p>
<p>&#8195;&#8195;第1-8个字节是文件名，如果长度不够就用空格填充；<br>&#8195;&#8195;第9-11个字节是文件后缀名，如果长度不够或者没有后缀就用空格填充；<br>&#8195;&#8195;第12个字节是文件属性，十分重要，一般的文件的文件属性就是0x00，文件夹的文件属性一般是0x10。<br>&#8195;&#8195;第13-22个字节是保留字节，没有作用；<br>&#8195;&#8195;第23,24字节是文件的创建时间<br>&#8195;&#8195;第25,26字节是文件的创建日期，精确到分钟<br>&#8195;&#8195;第27,28字节是文件的起始簇号<br>&#8195;&#8195;第29-32字节是文件的大小<br>&#8195;&#8195;我们以根目录为例：<br><img src="https://i.loli.net/2020/04/01/lA7fVIsEn14JSBh.png" alt="image.png"></p>
<p>&#8195;&#8195;对于第一个文件，它的名字是NEW,后缀名是CPP，文件属性是0x00,说明它是一个普通文件。创建时间是0x89A4,换成二进制是</p>
<p>&#8195;&#8195;1000 1001 1010 0100。</p>
<p>&#8195;&#8195;其中前5位是小时，10001=17,说明创建时间是17点；后6位是分钟,001101=13，说明具体时间是17:13。后五位没有作用(因为5位最多表示32个数，而一分钟有60秒)</p>
<p>&#8195;&#8195;创建日期是0x507E,换成二进制是</p>
<p>&#8195;&#8195;0101 0000 0111 1110</p>
<p>&#8195;&#8195;前7位是年份与1980的差值， 01010000=40,40+1980=2020，说明文件创建于2020年；后面4位是月份，0011是3，说明是2020年的3月；后面5位11110=30说明日期是 2020-3-30<br>起始簇号是0x0002</p>
<p>&#8195;&#8195;大小是0x0000003c，说明它一共占60个字节。</p>
<p>&#8195;&#8195;现在我们知道了这个文件的基本信息，我们要怎么找到它的内容呢？这就需要我们看一下数据区了。</p>
<p>&#8195;&#8195;从第33个扇区往后的扇区都是数据区，每个扇区512字节。上文的NEW.CPP文件的起始簇号是2，由于fat表前两个值有其他用途，所以簇号2代表的是第一个簇，或者说数据区的第一个扇区。</p>
<p>&#8195;&#8195;数据区的起始位置是0x4200，我们看看这里有什么：<br><img src="https://i.loli.net/2020/04/01/56owAs1WFaBnOgf.png" alt="image.png"><br>&#8195;&#8195;是60个a。</p>
<p>&#8195;&#8195;再来看根目录下的下一个文件，起始簇号是3，代表它开始于数据区的第一个扇区，即0x4400</p>
<p><img src="https://i.loli.net/2020/04/01/qMFOnw7YvjibfNh.png" alt="image.png"></p>
<p>&#8195;&#8195;它是一些奇奇怪怪的东西。</p>
<p>&#8195;&#8195;根据前文所述的读文件方法，我们可以把整个文件读出来，在此不再赘述。</p>
<p>&#8195;&#8195;打开前面创建的软盘，点击上方的映像、创建文件夹，然后输入名字，就可以创建一个文件夹了。<br><img src="https://i.loli.net/2020/04/01/XJm7K58ohPzADF9.png" alt="image.png"><br>&#8195;&#8195;往里面拖两个文件<br><img src="https://i.loli.net/2020/04/01/XUI76AZpoPQs9uB.png" alt="image.png"><br>&#8195;&#8195;然后我们来看看根目录里发生了什么：<br><img src="https://i.loli.net/2020/04/01/yp4aPLAuk9rbUtG.png" alt="image.png"><br>&#8195;&#8195;可以看到它多了一个文件记录，名字是HOULAI，后缀是空的，文件属性是0x10，说明这是个文件夹，首簇号是0x2B，由于(0x2B-0x2)*0x200+0x4200=0x9400，我们只需要找到这个地址</p>
<p><img src="https://i.loli.net/2020/04/14/CLgk7ZFD1Q6fNmp.png" alt="image.png"></p>
<p>&#8195;&#8195;可以看到，这里也是一个个文件记录，其中有两个比较奇怪，第一个文件记录的名字是”.”,第二个文件记录的名字是”..”。事实上，除了根目录之外的每个文件夹都有这两个记录，”.”表示的是当前文件夹，”..”表示的是上一级文件夹。在程序中读取文件时它们会被忽略。</p>
<p>&#8195;&#8195;了解了文件和文件夹的存储原理，在程序中读入文件的方法也就很简单了。</p>
<p>&#8195;&#8195;在程序中，我们把文件和文件夹统一看成文件，用file类来表示它:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">File</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> content, path;<span class="comment">//分别是文件的内容和路径</span></span><br><span class="line">    <span class="built_in">string</span> name, suffix;<span class="comment">//分别是名字和后缀。文件夹没有后缀</span></span><br><span class="line">    <span class="keyword">int</span> attr, fstclus, size;<span class="comment">//分别是属性，首簇号，大小。文件夹的属性是0x10,普通文件的属性是0x00。</span></span><br><span class="line">    <span class="keyword">unsigned</span> short Time, Date;<span class="comment">//文件上一次修改的时间和日期</span></span><br><span class="line">    File *fa;<span class="comment">//它的上一级文件夹的指针。</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, File *&gt; sons;<span class="comment">/*只有文件夹才有sons这个成员。</span></span><br><span class="line"><span class="comment">    记录了它的子文件和子文件夹，用名字+"."+后缀来当索引*/</span></span><br><span class="line">    File() &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line">    File(<span class="built_in">string</span> Name, File *now);<span class="comment">/*这个构造函数用于给now这个指针指向的文件夹</span></span><br><span class="line"><span class="comment">    添加一个子文件夹，Name指定了文件夹的名字*/</span></span><br><span class="line">    File(<span class="built_in">string</span> Name, <span class="built_in">string</span> Content, File *now);<span class="comment">/*这个构造函数用于给now这个指针指向的文件夹</span></span><br><span class="line"><span class="comment">    添加一个子文件，Name指定了文件的名字和后缀*/</span></span><br><span class="line">    File(File *from);<span class="comment">/*这个构造函数用于创建于from指向的文件内容相同的文件*/</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> short <span class="title">get_Time</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span></span>;<span class="comment">//获得时间</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> short <span class="title">get_Date</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span>;<span class="comment">//获得日期</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span></span>;<span class="comment">//将时间和日期转换成string格式</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">to_file_record</span><span class="params">()</span></span>;<span class="comment">//根据文件的信息得到文件的文件记录</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">to_dir_record</span><span class="params">()</span></span>;<span class="comment">//根据文件夹的信息得到文件夹的文件记录</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_file</span><span class="params">(File *tem_file)</span></span>;<span class="comment">//给文件夹添加一个子文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_file_root</span><span class="params">(File *tem_file)</span></span>;<span class="comment">//跟根目录添加一个子文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_content</span><span class="params">()</span></span>;<span class="comment">//得到文件的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_back</span><span class="params">(<span class="keyword">int</span> loc)</span></span>;<span class="comment">//将修改后的文件内容写回软盘</span></span><br><span class="line">    <span class="function">File *<span class="title">get_son</span><span class="params">(<span class="built_in">string</span> Name, <span class="keyword">bool</span> isn_folder)</span></span>;<span class="comment">//根据名字和后缀得到一个子文件(夹)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dir</span><span class="params">()</span></span>;<span class="comment">//输出子文件的信息</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dir_recusive</span><span class="params">()</span></span>;<span class="comment">//递归得到所有子文件的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除这个文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_content_deleted</span><span class="params">(<span class="keyword">int</span> loc)</span></span>;<span class="comment">/*对文件夹里已经被删除的目录项调用这个函数，</span></span><br><span class="line"><span class="comment">    使得被删除的簇能被捕获，避免出现"孤魂野鬼"*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_string</span><span class="params">(<span class="keyword">int</span> loc, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;b, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span>;<span class="comment">/*从这个文件夹开始查找</span></span><br><span class="line"><span class="comment">    将输入的字符串转化成b,将返回的路径字符串放在ret里*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(File *tem)</span></span>;<span class="comment">//用于创建于tem指向的文件内容相同的文件//</span></span><br><span class="line">&#125; file;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>&#8195;&#8195;本系统完成了要求的所有功能，此外还增加了find功能，具体情况请看下表:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>help</td>
<td>输出提示信息</td>
<td>无</td>
</tr>
<tr>
<td>quit</td>
<td>退出系统</td>
<td>无</td>
</tr>
<tr>
<td>cd [相对路径或绝对路径]</td>
<td>进入指定的文件夹</td>
<td>“..”表示上一级文件夹，”.”表示当前文件夹,用’/‘作分隔符</td>
</tr>
<tr>
<td>dir</td>
<td>展示当前文件夹下的文件信息</td>
<td>会输出名字、后缀、修改时间和大小</td>
</tr>
<tr>
<td>dir_r</td>
<td>递归的展示当前文件夹下的所有文件</td>
<td>只能看到名字和后缀</td>
</tr>
<tr>
<td>print [相对路径或绝对路径]</td>
<td>输出文件内容</td>
<td>目标文件不能是文件夹</td>
</tr>
<tr>
<td>gedit [相对路径或绝对路径]</td>
<td>进入文本编辑器模式，编辑指定的文件</td>
<td>无</td>
</tr>
<tr>
<td>mk [文件名] [文件内容]</td>
<td>在当前路径下创建一个文件</td>
<td>文件名长度不能超过8，文件名不能包含非法字符，文件要有后缀，不能与已有文件同名</td>
</tr>
<tr>
<td>mkdir [文件夹名]</td>
<td>在当前路径下创建一个文件夹</td>
<td>文件夹名长度不能超过8，文件夹名不能包含非法字符，不能与已有文件夹重名</td>
</tr>
<tr>
<td>rm [相对路径或绝对路径]</td>
<td>删除一个文件或文件夹</td>
<td>删除操作不可逆，请谨慎操作</td>
</tr>
<tr>
<td>find [相对路径或绝对路径]</td>
<td>根据路径查找文件(夹)</td>
<td>支持通配符’<em>‘和’?’。’</em>‘可以表示任意长度的字符串，’?’可以表示任意字符。系统会输出所有可能的路径</td>
</tr>
<tr>
<td>cp [相对路径或绝对路径][文件夹的相对路径或绝对路径]</td>
<td>复制文件(夹)</td>
<td>将第一个参数复制到第二个参数指向的文件夹处</td>
</tr>
<tr>
<td>mv [相对路径或绝对路径][文件夹的相对路径或绝对路径]</td>
<td>剪切文件</td>
<td>将第一个参数剪切到第二个参数指向的文件夹处</td>
</tr>
</tbody></table>
<p>&#8195;&#8195;由于许多操作都需要按路径名找到文件，所有我们先来了解按路径名寻找文件的方法:</p>
<h4 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h4><p>&#8195;&#8195;我们在file类中定义了一个map&lt;string,file*&gt;类型的成员变量sons，不用我说也能知道它的作用是什么。</p>
<p>&#8195;&#8195;在创建一个文件时，如果它是一个文件夹，则对应它的所有子文件，往sons里加入一个(pair){文件名+”.”+后缀，指向该文件的指针}。这样，我们就能很轻松地根据文件名和后缀找到对应的文件。</p>
<p>&#8195;&#8195;我们定义path_analysis和path_analysis2函数。path_analysis2函数接受一个字符串，将它用’/‘分隔为一个字符串向量并返回。</p>
<p>&#8195;&#8195;用户输入路径可以是绝对路径或相对路径，当第一个字符为’/‘时，我们认为这是绝对路径，从根目录开始找；否则认为这是相对路径，从当前文件夹下开始找。</p>
<p>&#8195;&#8195;从根目录开始找的方法是:</p>
<p>&#8195;&#8195;设输入字符串向量为vec,根文件夹指针为f1。<br>&#8195;&#8195;遍历向量的每一个元素，查找f1的sons里是否有子文件(夹)的名字与之匹配，若有则修改f1为对应文件(夹)，否则直接返回NULL。<br>&#8195;&#8195;遍历完向量之后说明f1已经是需要的文件(夹)，返回f1即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">file *<span class="title">path_analysis</span><span class="params">(<span class="built_in">string</span> input, file *now, file *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> rt = (input[<span class="number">0</span>] == <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(i) &amp;&amp; !<span class="built_in">isdigit</span>(i) &amp;&amp; i != <span class="string">'/'</span> &amp;&amp; i != <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; folder_names = path_analysis2(input);</span><br><span class="line">    file *tem;</span><br><span class="line">    <span class="keyword">if</span> (rt)</span><br><span class="line">        tem = root;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tem = now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; folder_names.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tem = tem-&gt;get_son(folder_names[i], i + <span class="number">1</span> == folder_names.size());</span><br><span class="line">        <span class="keyword">if</span> (tem == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;从当前目录开始找的方法与此基本相同，不再赘述。</p>
<h4 id="cd操作的实现"><a href="#cd操作的实现" class="headerlink" title="cd操作的实现"></a>cd操作的实现</h4><p>&#8195;&#8195;既然了解了路径分析的方法，cd操作的实现也就呼之欲出了。我们在程序中定义两个指针，一个名为tem，指向当前所在的文件；一个名为root，指向根文件夹。只需要根据这两个指针和输入的字符串调用paht_analysis函数即可，如果函数返回NULL则报错，否则修改tem。</p>
<p>&#8195;&#8195;代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">"cd"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">    file *now = path_analysis(b, tem, root);</span><br><span class="line">    <span class="keyword">if</span> (now == <span class="literal">NULL</span> || now-&gt;attr != <span class="number">0x10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"路径"</span> &lt;&lt; b &lt;&lt; <span class="string">"不合法\n"</span>;</span><br><span class="line">        <span class="comment">//注意，cd只能进入文件夹，进入一个文件是不可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tem = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dir操作的实现"><a href="#dir操作的实现" class="headerlink" title="dir操作的实现"></a>dir操作的实现</h4><p>&#8195;&#8195;进行dir操作时，我们遍历sons，输出所有子文件(夹)的信息，包括文件名、后缀、修改时间和大小。由于这个操作十分简单，代码就不必展示了。</p>
<h4 id="dir-r操作的实现"><a href="#dir-r操作的实现" class="headerlink" title="dir_r操作的实现"></a>dir_r操作的实现</h4><p>&#8195;&#8195;这个操作的实现需要用到递归的思想。</p>
<p>&#8195;&#8195;定义dir_recusive()函数，它返回一个字符串向量。它的实现方法是:<br>&#8195;&#8195;创建一个vector<string> ret用于返回。<br>&#8195;&#8195;遍历sons的每一个键值对，如果值(即file指针)指向一个普通文件，则把对应的键放进ret里;<br>&#8195;&#8195;如果指向的是一个文件夹，则对它调用dir_recusive()，把返回的字符串向量的每一个元素加上一个前缀”  “,都放进ret里。<br>为什么要加入一个前缀呢？想一想，当前文件夹下的文件名没有前缀，下一级文件夹下的文件名有一个前缀，再下一级文件夹下的文件名有两个前缀……这样看起来不就形成了树的结构吗？</p>
<p>&#8195;&#8195;dir_recusive()函数代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">File::dir_recusive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec, tem;</span><br><span class="line">    vec.push_back(name + (attr == <span class="number">0x10</span> ? <span class="string">""</span> : <span class="string">"."</span> + suffix) + <span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : sons)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.first == <span class="string">"."</span> || i.first == <span class="string">".."</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tem = i.second-&gt;dir_recusive();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tem.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(<span class="string">"  "</span> + tem[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="print操作的实现"><a href="#print操作的实现" class="headerlink" title="print操作的实现"></a>print操作的实现</h4><p>&#8195;&#8195;这个操作很简单，根据输入的路径找到相应的文件夹，然后输出它的内容即可。</p>
<h4 id="mk操作的实现"><a href="#mk操作的实现" class="headerlink" title="mk操作的实现"></a>mk操作的实现</h4><p>&#8195;&#8195;这个操作是重点和难点。首先我们要根据第一个参数找到文件夹，根据第二个参数创建一个文件。怎么创建一个文件？</p>
<p>&#8195;&#8195;我们知道文件是保存在数据区里的，那我们要在数据区里找到一个空闲的扇区，这可以在fat表里找(也可以用已删除的文件占用的扇区，这会在下文讲解)一个空闲簇号，找到之后将内容写到对应的扇区，将fat表对应的位置修改为一个结束标志。如果文件内容不止512个字节，则继续分配一个簇号，将内容写进去，将fat表中上一个簇号对应的位置修改为一个这个簇号，将这个簇号对应的文职修改为一个结束标志。一直这样下去，直到写完为止。<br>&#8195;&#8195;这部分代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Content.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Content.size() &gt; <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        datas1.write_floopy(nowclus - <span class="number">2</span>, Content.substr(<span class="number">0</span>, <span class="number">512</span>));</span><br><span class="line">        Content = Content.substr(<span class="number">512</span>);</span><br><span class="line">        fat1.cluster_numbers[nowclus - <span class="number">2</span>] = fat1.get_first_empty() + <span class="number">2</span>;</span><br><span class="line">        nowclus = fat1.cluster_numbers[nowclus - <span class="number">2</span>];</span><br><span class="line">        fat1.cluster_numbers[nowclus - <span class="number">2</span>] = END_CLUSTER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        datas1.write_floopy(nowclus - <span class="number">2</span>, Content);</span><br><span class="line">        Content = <span class="string">""</span>;</span><br><span class="line">        fat1.cluster_numbers[nowclus - <span class="number">2</span>] = END_CLUSTER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;创建文件的其他操作就很简单了，注意要设置fa指针指向父文件夹。此外还要给文件生成一条文件记录，把它添加进父文件夹的内容里，给父文件夹的sons变量添加一个键值对。最后把fat表更新一遍。</p>
<h4 id="mkdir操作的实现"><a href="#mkdir操作的实现" class="headerlink" title="mkdir操作的实现"></a>mkdir操作的实现</h4><p>&#8195;&#8195;搞定了mk操作后，mkdir也就差不多了。区别是创建出来的文件的内容是两条文件记录，记录”.”和”..”这两个”子”文件夹。</p>
<h4 id="rm操作的实现"><a href="#rm操作的实现" class="headerlink" title="rm操作的实现"></a>rm操作的实现</h4><p>&#8195;&#8195;rm操作可能是最难的操作了。<br>&#8195;&#8195;我们定义一个queue&lt;pair&lt;file <em>, int&gt;&gt;类型的全局变量deleted_clusters。它的每一个元素是一个 file</em>,int 对。</p>
<p>&#8195;&#8195;当我们删除某个文件夹下的一个文件时，我们将它的文件记录的第一个字符变成一个删除标志，同时需要将 指向文件夹的指针 和 这个文件记录的序号 组成一个pair，push进deleted_clusters里。</p>
<p>&#8195;&#8195;这样做有什么好处呢？假设我们在删除操作完成后就退出系统，然后重新打开，读入文件夹时，我们如果读到一个首字符为删除标志的文件记录，就把指向文件夹的指针和文件记录的序号放进deleted_clusters里。</p>
<p>&#8195;&#8195;此后，如果我们需要再创建一个文件，就可以去deleted_clusters找被删除的簇。怎么找呢？我们先通过deleted_culsters的front()方法得到一个pair，根据它找到之前删除文件的文件记录，它不是记录了这个文件在数据区的位置了吗？直接将这些位置覆盖就可以了。覆盖完之后将这个pair pop掉就可以了。</p>
<p>&#8195;&#8195;这样就大功告成了吗？还没有，至少还有两个问题:</p>
<p>&#8195;&#8195;1.如果被删除的文件占用两个扇区，而我这次创建的文件只有一个扇区，那我把删除文件的首扇区覆盖了，第二个扇区不就成了孤魂野鬼了？</p>
<p>&#8195;&#8195;2.将被删除文件的内容覆盖了之后，我们并没有修改它的文件记录，这样，我们下一次启动系统，还是会将它对应的pair读到deleted_clusters里，这样就可能又把它覆盖了一遍，不是就乱套了吗？</p>
<p>&#8195;&#8195;其实解决方法也很简单。</p>
<p>&#8195;&#8195;第一个问题，只需将首扇区覆盖之后，看一下这个扇区在fat表中对应的值是否是结束标志，如果不是，就修改文件记录，使它的首扇区变成原来的第二个扇区。同时，由于这个文件还没有被完全覆盖，因此不必在deleted_clusters里把它对应的pair pop掉。</p>
<p>&#8195;&#8195;第二个问题，只需要将文件记录里的首扇区标志改为0，此后读文件时遇到这种首扇区标志位0的文件记录就跳过即可。</p>
<p>&#8195;&#8195;以上就是删除普通文件的基本方法。删除文件夹呢？也很简单，递归地把子文件都删除，再将文件夹也删除了就可以了。</p>
<p>&#8195;&#8195;为什么要这样？因为我的deleted_clusters是一个队列，由于子文件先删除，队列又是先进先出的，覆盖的时候便会先覆盖子文件，再覆盖文件夹。否则要是先把文件夹覆盖了，子文件的文件记录找不到了，就出现”孤魂野鬼”了。如果deleted_clusters是一个栈，就应该先删除文件夹，再删除文件。</p>
<p>&#8195;&#8195;删除操作的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">File::remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (attr == <span class="number">0x10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : sons)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.first == <span class="string">"."</span> || i.first == <span class="string">".."</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            i.second-&gt;remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fa-&gt;content.size(); j += <span class="number">32</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fa-&gt;content[j + <span class="number">27</span>] &lt;&lt; <span class="number">8</span>) + fa-&gt;content[j + <span class="number">26</span>] == fstclus)</span><br><span class="line">        &#123;</span><br><span class="line">            fa-&gt;content[j] = DELETED_CLUSTER_SIGN;</span><br><span class="line">            fa-&gt;sons.erase(attr == <span class="number">16</span> ? name : name + <span class="string">"."</span> + suffix);</span><br><span class="line">            fa-&gt;write_back(j / SIZE_OF_SECTOR);</span><br><span class="line">            deleted_clusters.push(&#123;fa, j / <span class="number">32</span>&#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gedit操作的实现"><a href="#gedit操作的实现" class="headerlink" title="gedit操作的实现"></a>gedit操作的实现</h4><p>&#8195;&#8195;为了实现这个操作，我设计了一个简易的编辑器。它的原理是不断相应键盘的输入，每输入一次就把控制台刷新一次，然后输出。由于这个编辑器与fat12文件系统关系不大，我就不再赘述。</p>
<p>&#8195;&#8195;这个操作也是根据输入的字符串找到相应的文件(注意这个文件不能是文件夹)，然后调用编辑器编辑它的内容，当用户按下ctrl+s则将修改后的内容保存回去。怎么保存呢？很简单，只需把原来的文件删掉，再创建一个同名而不同内容的文件即可。</p>
<h4 id="find操作的实现"><a href="#find操作的实现" class="headerlink" title="find操作的实现"></a>find操作的实现</h4><p>&#8195;&#8195;find操作本事不算复杂，但为了使我的文件系统更有特色，我给它增加了’*’和’?’这两个通配符。</p>
<p>&#8195;&#8195;’<em>‘表示任意字符串(甚至可以是空的)。比如 “houlai”和”h\</em>lai”是匹配的。<br>&#8195;&#8195;’?’表示单个字符。比如”zhiqian”和”?hi?ian”是匹配的。</p>
<p>&#8195;&#8195;怎么实现字符串的带通配符匹配呢？一种方法是暴力法，即直接枚举通配符的每一种可能。但这样效率很低，在字符串很长的情况下根本配不出来。</p>
<p>&#8195;&#8195;另一种是动态规划法，即dp(dynamic planning)，对输出长度为n和m的字符串，它的时间复杂度是O(nm)的，效率很高。由于这部分内容与fat12文件系统关系不大，具体的dp方法就不必赘述，直接给出匹配的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size(), m = b.size();</span><br><span class="line">    <span class="keyword">bool</span> ok[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            ok[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> okk[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        okk[j] = <span class="literal">false</span>;</span><br><span class="line">    okk[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ok[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ok[<span class="number">0</span>][j] == (ok[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; (b[j - <span class="number">1</span>] == <span class="string">'*'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j - <span class="number">1</span>] == <span class="string">'?'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ok[i][j] = ok[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b[j - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ok[i][j] = okk[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//         cout &lt;&lt; ok[i - 1][j - 1] &lt;&lt; " " &lt;&lt; (a[i - 1] == b[j - 1]) &lt;&lt; endl;</span></span><br><span class="line">                ok[i][j] = (ok[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            okk[j] = okk[j] || ok[i][j];</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; ok[i][j] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#8195;&#8195;搞定了单个字符串的匹配方法，find操作的实现也就简单了，只需像之间路径分析一样搜索下去，找到了就将路径放进一个vector&lt;string&gt;里。不同的是这里的find可以找到多个路径，因此需要用dfs的方法；而之前的路径分析最多只有一个结果，因此直接找就可以了。<br>&#8195;&#8195;具体代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">File::find_string</span><span class="params">(<span class="keyword">int</span> loc, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;b, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loc == b.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        cout&lt;&lt;name&lt;&lt;" "&lt;&lt;path&lt;&lt;endl;</span></span><br><span class="line">        ret.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : sons)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMatch(i.first, b[loc]))</span><br><span class="line">        &#123;</span><br><span class="line">            i.second-&gt;find_string(loc + <span class="number">1</span>, b, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cp操作和mv操作"><a href="#cp操作和mv操作" class="headerlink" title="cp操作和mv操作"></a>cp操作和mv操作</h4><p>&#8195;&#8195;在明确了如何找文件，如何删除文件之后，这两个操作也就非常简单了，没有进行解释的必要。</p>
<h3 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h3><p>&#8195;&#8195;总共有12个文件，分别是:</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>fun.cpp</td>
<td>定义了各种通用的函数</td>
</tr>
<tr>
<td>byte.h</td>
<td>定义了byte类</td>
</tr>
<tr>
<td>byte.cpp</td>
<td>byte类的实现和与之相关的函数</td>
</tr>
<tr>
<td>sector.h</td>
<td>定义了sector类和它的实现</td>
</tr>
<tr>
<td>mbr.h</td>
<td>定义了MBR类</td>
</tr>
<tr>
<td>mbr.cpp</td>
<td>MBR类的实现</td>
</tr>
<tr>
<td>file.h</td>
<td>定义了file类、fat类、rootentry类和datas类。</td>
</tr>
<tr>
<td>file.cpp</td>
<td>上述几个类的实现和相应的函数。</td>
</tr>
<tr>
<td>getch.cpp</td>
<td>定义了一个函数</td>
</tr>
<tr>
<td>my_editor.h</td>
<td>定义了my_editor类和一些函数</td>
</tr>
<tr>
<td>interface.cpp</td>
<td>给出了my_editor类的大部分实现，定义了一些与用户交互的函数</td>
</tr>
<tr>
<td>main.cpp</td>
<td>包括了程序开始时的检查和根文件夹的读入</td>
</tr>
</tbody></table>
<p>&#8195;&#8195;总计约1900行代码</p>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>&#8195;&#8195;使用dir_r可以展示目录树:<br><img src="https://i.loli.net/2020/04/15/XELPIqom6kZd8sw.png" alt="image.png"><br>&#8195;&#8195;使用print可以显示文件内容:<br><img src="https://i.loli.net/2020/04/15/RhFQNvI4Yn2kfZA.png" alt="image.png"><br>&#8195;&#8195;使用gedit可以编辑文件:<br><img src="https://i.loli.net/2020/04/15/UliEz8pGcV1tS9L.png" alt="image.png"><br><img src="https://i.loli.net/2020/04/15/GIBgNKhYoRkCXb8.png" alt="image.png"><br>&#8195;&#8195;使用dir命令可以查看当前文件夹下的内容:<br><img src="https://i.loli.net/2020/04/15/3sncS9lR1XybkoK.png" alt="image.png"><br>&#8195;&#8195;使用cd命令可以进入文件夹:<br><img src="https://i.loli.net/2020/04/15/IUi8WJgtXZH2bCR.png" alt="image.png"><br>&#8195;&#8195;使用mk命令可以创建文件,使用rm文件可以删除文件:<br><img src="https://i.loli.net/2020/04/15/KIqjTfQX3vzHZsP.png" alt="image.png"><br>&#8195;&#8195;使用mkdir命令可以创建文件夹:<br><img src="https://i.loli.net/2020/04/15/LGyKaSrANFbP497.png" alt="image.png"><br>&#8195;&#8195;使用cp命令可以复制文件:<br><img src="https://i.loli.net/2020/04/15/iDcPjqfGAby87de.png" alt="image.png"><br>&#8195;&#8195;使用mv命令可以剪切文件:<br><img src="https://i.loli.net/2020/04/15/dlXBxtUIA4VnTzH.png" alt="image.png"><br>&#8195;&#8195;使用rm命令还可以删除文件夹:<br><img src="https://i.loli.net/2020/04/15/cFNKIGk6BWAuCoH.png" alt="image.png"></p>
<p>&#8195;&#8195;详情请看演示视频。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>&#8195;&#8195;这次实验可以说是我做过最难的实验了，代码量大，编程难度高，还用到了搜索、动态规划等算法。但从最后的完成情况来看，我还是比较满意的（<del>虽然还是有很多bug</del>），实现了要求的功能，还增加了自己的创意。不过还是存在代码不够规范的问题，不同文件、不同类糅杂在一起，以至于我自己都不清楚我的代码文件是怎么组织的。</p>
<p>&#8195;&#8195;在完成这次实验的过程中，最大的困难是编写删除操作的代码。我会思考了很久才想出一种很复杂的方法，这也带来了大量的代码和bug，不过好在还是写出来了。但在跟其他同学交流之后，似乎他们的方法更为简单，而我的方法理论上在性能方面会更优秀(我也不太确定)，为了偷个懒我也没有改。</p>
<p>&#8195;&#8195;还有一个遗憾是没有用到汇编语言。事实上大部分代码是用c++编写的，还用到了stl和linux的各种头文件里的很多内容，可能会导致代码的可移植性有点差。</p>
<p>&#8195;&#8195;这次实验的收获也是很明显的，我锻炼了编写较大规模程序的能力，对文件系统和操作系统有了更深入的了解，也激发了我进一步学习操作系统的兴趣。</p>
<p>&#8195;&#8195;总的来说，这次实验完成的十分艰难，但也是收获满满，有一些做的不错的地方，也有不少改进的空间。希望在接下来的课程中也能有这么有趣的实验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CUDA学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 15:32:21" itemprop="dateCreated datePublished" datetime="2020-04-10T15:32:21+08:00">2020-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CUDA-学习笔记"><a href="#CUDA-学习笔记" class="headerlink" title="CUDA 学习笔记"></a>CUDA 学习笔记</h1><p>主要参考《GPU高性能编程CUDA实战》</p>
<p>一般将CPU及其系统的内存称为主机，将GPU及其内存称为设备。<br>在GPU设备上执行的函数通常称为核函数(Kernal);</p>
<p>一个简单的程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>global</strong>修饰符告诉编译器，函数应该被编译为在设备上而不是在主机上运行。于是，kernel()函数将被交给编译设备代码的编译器，而main()函数将被交给主机编译器。<br>尖括号表示要将一些参数传递给运行时系统，用以告诉运行时如何启动设备代码。</p>
<p>再来看一个更复杂的程序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *c )</span> </span>&#123;</span><br><span class="line">    *c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> *dev_c;</span><br><span class="line">    <span class="comment">//cudaMalloc()</span></span><br><span class="line">    cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="comment">//核函数执行</span></span><br><span class="line">    add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;( <span class="number">2</span>, <span class="number">7</span>, dev_c );</span><br><span class="line">    <span class="comment">//cudaMemcpy()</span></span><br><span class="line">    cudaMemcpy( &amp;c, dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyDeviceToHost ) ;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"2 + 7 = %d\n"</span>, c );</span><br><span class="line">    <span class="comment">//cudaFree()</span></span><br><span class="line">    cudaFree( dev_c );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cudaMalloc()用于分配内存，但与malloc()不同的是，它是在GPU上分配内存。由于分配的地址时在GPU上，所以程序员一定不能在主机代码中对这个指针进行解引用。同样的，也不能用free()函数来释放这些内存，只能用cudaFree()。<br>为了让主机代码能得到GPU计算的结果，可以用cudaMemcpy()函数，它的第四个参数数据移动的方向，是从主机到设备、设备到主机还是设备到设备。</p>
<p>上面说的这些内容好像对加快程序的执行速度没什么帮助，我们用下面这个向量求和的例子来了解CUDA如何让程序变得更快:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;book.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span>* b,<span class="keyword">int</span>* c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tid=blockIdx.x;</span><br><span class="line">  <span class="keyword">if</span>(tid&lt;N)c[tid]=a[tid]+b[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line">  <span class="keyword">int</span>* dev_a,*dev_b,*dev_c;</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_a,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_b,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)a[i]=-i,b[i]=i*i;</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_a,a,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_b,b,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_c,c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  add&lt;&lt;&lt;N,<span class="number">1</span>&gt;&gt;&gt;(dev_a,dev_b,dev_c);</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(c,dev_c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyDeviceToHost));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,c[i]);</span><br><span class="line">  cudaFree(dev_a),cudaFree(dev_b),cudaFree(dev_c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到，我们用了add&lt;&lt;&lt;N,1&gt;&gt;&gt;。N代表了设备在执行核函数时使用的并行线程块(Block)的数量。当启动核函数时，我们告诉运行时，我们想要一个一维线程格(Grid)，其中包含N个线程块。<br>如何在代码中知道当前正在运行的是哪个线程块？可以通过blockIdx.x得到，它是一个内置变量。这样，我们就把向量求和并行化，达到了加速的效果。</p>
<p>在上面的例子中，我们启动了多个线程块，但每个线程块只有1个线程。要想在每个线程块里启动多个线程，可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;book.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span>* b,<span class="keyword">int</span>* c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tid=threadIdx.x+blockIdx.x*blockDim.x;</span><br><span class="line">  <span class="keyword">if</span>(tid&lt;N)c[tid]=a[tid]+b[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line">  <span class="keyword">int</span>* dev_a,*dev_b,*dev_c;</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_a,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_b,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  HANDLE_ERROR(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)a[i]=-i,b[i]=i*i;</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_a,a,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_b,b,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(dev_c,c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyHostToDevice));</span><br><span class="line">  add&lt;&lt;&lt;(N+<span class="number">127</span>)/<span class="number">128</span>,<span class="number">128</span>&gt;&gt;&gt;(dev_a,dev_b,dev_c);</span><br><span class="line">  HANDLE_ERROR(cudaMemcpy(c,dev_c,N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cudaMemcpyDeviceToHost));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,c[i]);</span><br><span class="line">  cudaFree(dev_a),cudaFree(dev_b),cudaFree(dev_c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到启动核函数时用的是&lt;&lt;&lt;(N+127)/128,128&gt;&gt;&gt;,(N+127)/128是对N/128向上取整，得到线程块的数量。第二个128代表一个线程块有128个线程。这样子可能会导致线程数量大于N，但没有关系，我们会在核函数里判断线程索引是否越界。<br>在核函数中，线程索引通过$tid=threadIdx.x+blockIdx.x*blockDim.x$得到。<br>为了避免使用过多的线程块，我们直接指定线程块的数量，然后在核函数中用while循环对下表递增，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span>* b,<span class="keyword">int</span>* c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tid=threadIdx.x+blockIdx.x*blockDim.x;</span><br><span class="line">  <span class="keyword">while</span>(tid&lt;N)c[tid]=a[tid]+b[tid],tid+=blockDim.x*gridDim.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reeeeeeeeeein</p>
  <div class="site-description" itemprop="description">SYSU 计算机专业大二在读</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reeeeeeeeeein</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>