<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SYSU 计算机专业大二在读">
<meta property="og:type" content="website">
<meta property="og:title" content="reeeeeeeeeein的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="reeeeeeeeeein的博客">
<meta property="og:description" content="SYSU 计算机专业大二在读">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reeeeeeeeeein">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>reeeeeeeeeein的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
<div class="bg_content">
<canvas id="canvas"></canvas>
</div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">reeeeeeeeeein的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9B%B8%E4%BC%BC%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9B%B8%E4%BC%BC%E5%BA%A6/" class="post-title-link" itemprop="url">时间序列相似度</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 21:55:02" itemprop="dateCreated datePublished" datetime="2020-06-06T21:55:02+08:00">2020-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="时间序列相似度度量标准实现"><a href="#时间序列相似度度量标准实现" class="headerlink" title="时间序列相似度度量标准实现"></a>时间序列相似度度量标准实现</h1><h2 id="预备知识：样本相似度度量标准"><a href="#预备知识：样本相似度度量标准" class="headerlink" title="预备知识：样本相似度度量标准"></a>预备知识：样本相似度度量标准</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="距离型"><a href="#距离型" class="headerlink" title="距离型"></a>距离型</h4><p>以差值为基础的相似度计算方法，通常值越小越相似。</p>
<h5 id="例子1：-欧式距离"><a href="#例子1：-欧式距离" class="headerlink" title="例子1： 欧式距离"></a>例子1： 欧式距离</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的欧式距离：</p>
<p>$d_{L^p}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert^p)^{\frac 1p}$</p>
<p>当 $p=1$ 时，距离为 $d_{L^1}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert)$，也称为曼哈顿距离。</p>
<p>当 $p=2$ 时，距离为 $d_{L^2}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert^2)^{\frac 12}$，也称为欧几里得距离</p>
<p>当 $p\rightarrow \infin$ 时，距离为 $d_{L^\infin}=\max\limits_{1\le k \le n}\left\vert x_k-y_k \right\vert$</p>
<h5 id="例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）"><a href="#例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）" class="headerlink" title="例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）"></a>例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）</h5><p>两个向量的马氏距离为：</p>
<p>$$d(\vec x,\vec y)=\sqrt{(\vec x-\vec y)^{T}\sum^{-1}(\vec x-\vec y)}$$</p>
<p>其中，$\sum$ 为 $\vec x$ 和 $\vec y$ 的协方差矩阵。</p>
<p>为什么要用马氏距离？欧式距离不行吗？考虑下面这个例子：</p>
<p><img src="https://i.loli.net/2020/06/06/3b2wpQVOKTmXFaG.png" alt="image-20200602210843484.png"></p>
<p>上图中，红圆圈是数据点的均值，绿色的×和红色的×到均值的欧式距离是相等的，但我们可以明显地看到，绿色的×应该属于这个分布，红色的×不属于。这是因为</p>
<ol>
<li><p>不同维度(x轴，y轴)之间存在相关性(在这里表现为x轴与y轴存在正相关)。</p>
</li>
<li><p>不同方向上变化幅度不同，把图顺时针旋转45度，可以看到横向上变化较大，竖向上变化较小(有些资料把这一点称为量纲不同和方差不同)。</p>
</li>
</ol>
<p>用马氏距离就可以消除这种差别，它相当于把欧式距离进行了标准化。</p>
<h4 id="夹角型"><a href="#夹角型" class="headerlink" title="夹角型"></a>夹角型</h4><p>以乘积为基础的相似度计算方法，通常值越大越相似。可以通过取相反数达成值越小越相似。</p>
<h5 id="例子1：夹角余弦"><a href="#例子1：夹角余弦" class="headerlink" title="例子1：夹角余弦"></a>例子1：夹角余弦</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的夹角 $\theta$ 满足：</p>
<p>$cos\theta=\frac{\sum\limits_{k=1}^{n}x_k<em>y_k}{\sqrt{\sum\limits_{k=1}^{n}x_k^2}</em>\sqrt{\sum\limits_{k=1}^{n}y_k^2}}$</p>
<h5 id="例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）"><a href="#例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）" class="headerlink" title="例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）"></a>例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的Pearson相关系数 $cor(X,Y)$ 满足：</p>
<p>$cor(X,Y)=\frac{\sum\limits_{k=1}^{n}(x_k-\bar x)<em>(y_k-\bar y)}{\sqrt{\sum\limits_{k=1}^{n}(x_k-\bar x)^2}</em>\sqrt{\sum\limits_{k=1}^{n}(x_k-\bar x)^2}}$</p>
<h2 id="针对特殊结构数据"><a href="#针对特殊结构数据" class="headerlink" title="针对特殊结构数据"></a>针对特殊结构数据</h2><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><p>核心需要：对齐</p>
<p>什么是对齐：样本特征的互相配对。</p>
<p>为什么要对齐：样本的相似度是根据样本特征的相似度累加/平均的，结构化数据的特征直接对齐了，但时间序列的每一时刻值可能没有天然强对齐关系。</p>
<p>得到样本相似度度量的实际处理：不同对齐策略下的相似度度量最值</p>
<p>不同对齐策略指对对齐的搜索空间的不同约束，搜索空间的大小会导致不同的复杂度。</p>
<p>时间序列对齐策略的潜在需求：</p>
<p>保序性（单调性）：例如T1:a, b, c; T2:x, y, z，无论怎么配对，T1配对出的匹配序列T2‘顺序满足y不会在x前面，z不会再x,y前面。</p>
<h4 id="保端点型对齐策略"><a href="#保端点型对齐策略" class="headerlink" title="保端点型对齐策略"></a>保端点型对齐策略</h4><p>可以一对多，需要全部点（时间序列各个时刻的值）都找到配对（从而开始点一定配对开始点，结束点一定配对结束点，也满足连续性）</p>
<p>比较适合的场景：语音相似度识别</p>
<h5 id="典型例子：DTW（-Dynamic-Time-Warping，动态时间规整）：保端点型对齐策略下的距离型度量"><a href="#典型例子：DTW（-Dynamic-Time-Warping，动态时间规整）：保端点型对齐策略下的距离型度量" class="headerlink" title="典型例子：DTW（[Dynamic Time Warping，动态时间规整）：保端点型对齐策略下的距离型度量"></a>典型例子：DTW（[Dynamic Time Warping，动态时间规整）：保端点型对齐策略下的距离型度量</h5><p><img src="https://pic4.zhimg.com/v2-343ad369c65bd575f40d17f10ae523ef_b.jpg" alt="img"></p>
<p>上图就是DTW对齐策略的一个例子。</p>
<p>最基本的DTW可以用动态规划(dp)来实现。具体的，假设时间序列 $X={x_1,x_2……x_m}，Y={y_1,y_2……y_n}$ ，用 $dp[i][j] ,i\le m,j\le n$ 来表示 $X$ 的前 $i$ 个点和 $Y$ 的前 $j$ 个点能取得的最小距离，定义状态转移方程为：</p>
<p>​                    $$dp[i][j]=\begin{cases} dist(1,1),i=1,j=1 \ dp[i-1][j]+dist(i,1)，i&gt;1,j=1 \ dp[i][j-1]+dist(1,j),i=1,j&gt;1\min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j-1])+dist(i,j),i&gt;1,j&gt;1  \end{cases}$$</p>
<p>其中 $dist(i,j)=(X[i]-Y[j])^2$ 。</p>
<p>为了将结果可视化，可以将距离矩阵（即 dist ）绘制出来，如 $X=[3,6,8],Y=[2,4,8,7]$ 时，距离矩阵如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/7BRvN3TzMlkayhE.png" alt="image-20200604221146644.png"></p>
<p>要达到一个最小距离，相当于从左上角走到右下角，且每次只允许往右、往下或者往右下走，使得走过的数字的和最小。显然在这个图里应该这样走：</p>
<p><img src="https://i.loli.net/2020/06/06/TBKFsEo1PH26Cqk.png" alt="image-20200604221539941.png"></p>
<h6 id="DTW的优点"><a href="#DTW的优点" class="headerlink" title="DTW的优点"></a>DTW的优点</h6><p>DTW能处理长度不同的时间序列，这是它比传统的距离算法强的地方。而且对很多时间序列，用DTW进行距离计算明显更合理。</p>
<h6 id="DTW的缺点"><a href="#DTW的缺点" class="headerlink" title="DTW的缺点"></a>DTW的缺点</h6><p>用距离来度量相似度的算法的时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 的 ，而DTW算法在时间和空间上都是 $O(nm)$ 的。对于较长的时间序列，直接进行计算显然开销太大，于是要引进一些优化的方法。</p>
<p>以下的变种是基于缩减搜索空间得到的变种。</p>
<h5 id="DTW变种1：greedy-DTW"><a href="#DTW变种1：greedy-DTW" class="headerlink" title="DTW变种1：greedy-DTW"></a>DTW变种1：greedy-DTW</h5><p>来自论文《Time2Graph: Revisiting Time Series Modeling with Dynamic Shapelets》的附录A.1的Algorithm 5</p>
<p>这种算法是用贪心的思想，即每次选择所有能走的点里代价最小的点。为了避免出现沿着边缘走的情况，设置一个窗口 $w$ ，规定走到的位置 $x,y$ 满足 $|x-y|\le w$ 。比如说，对时间序列 $X=[2,3,5,7,1],Y=[4,2,8,6,4]$，dist矩阵和走过的路线是这样子的：</p>
<p><img src="https://i.loli.net/2020/06/06/jBuzlAnGoPLRsEt.png" alt="image-20200605171339497.png"> </p>
<h6 id="greedy-DTW的优点"><a href="#greedy-DTW的优点" class="headerlink" title="greedy-DTW的优点"></a>greedy-DTW的优点</h6><p>它最大的优点是速度快，只需要 $O(n+m)$ 的时间复杂度就可以完成计算。</p>
<h6 id="greedy-DTW的缺点"><a href="#greedy-DTW的缺点" class="headerlink" title="greedy-DTW的缺点"></a>greedy-DTW的缺点</h6><p>缺点也很明显，贪心算法无法保证取得全局最优解，容易”误入歧途”。</p>
<h5 id="DTW变种2：Fast-DTW"><a href="#DTW变种2：Fast-DTW" class="headerlink" title="DTW变种2：Fast-DTW"></a>DTW变种2：Fast-DTW</h5><p>来自论文《FastDTW: Toward Accurate Dynamic Time Warping in Linear Time and Space》</p>
<p>可参考<a href="https://www.cnblogs.com/kemaswill/archive/2013/04/18/3029078.html" target="_blank" rel="noopener">https://www.cnblogs.com/kemaswill/archive/2013/04/18/3029078.html</a></p>
<p>这种方法的基本策略是递归。FastDTW 算法如下：</p>
<p>对于两个时间序列 $X=[1,2,3,4],Y=[3,4,5,6]$，首先将它们的长度缩短为一半，变成 $X’=[1.5,3.5],Y’=[3.5,5.5]$ ，相对应的，矩阵从 4×4 变成了 2×2，如下图所示：</p>
<p><img src="https://i.loli.net/2020/06/06/2DJK9mwILQdhzRv.png" alt="image-20200606011018301.png"></p>
<p>然后，对压缩后的时间序列递归地应用 FastDTW找到一条路径（由于这里的时间序列长度只有2，就可以直接找到不用递归），如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/PZmMsNckqW7uLiw.png" alt="image-20200606011233288.png"></p>
<p>在原来的矩阵中给这条路径经过的块打上标记，如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/D5UwZMiRAbcaQKo.png" alt="image-20200606011749696.png"></p>
<p>为了增大搜索范围，对路径以 $r$ 为半径拓展，即将与路径的距离小于等于 $r$ 的路径打上标记。$r=1$ 时，如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/gxuzD853QrbXlkT.png" alt="image-20200606012002821.png"></p>
<p>这样，就得到了我们的搜索路径，然后只用在这条路径里找就可以了。看起来，搜索路径并不比原来的矩阵小多少，但当时间序列长度足够大时，搜索路径会很小，因为它是 $O(n*r)$ 的，证明略。</p>
<h6 id="Fast-DTW的优点"><a href="#Fast-DTW的优点" class="headerlink" title="Fast-DTW的优点"></a>Fast-DTW的优点</h6><p>最大的优点显然是速度快，如下图所示（顺便吐槽一句，04年的时候执行一个 $n=1000$ 的 $O(n^2)$ 算法竟然要0.92秒，而今天的计算机可能不用0.01秒，看来计算机领域的发展还是很快的）：</p>
<p><img src="https://i.loli.net/2020/06/06/J91Eogx3DBsAKqh.png" alt="image-20200606012512919.png"></p>
<p><img src="https://i.loli.net/2020/06/06/Dz9jpLuveJbEXVK.png" alt="image-20200606012619988.png"></p>
<p>对于 $N=1000$ 左右的时间序列，用 $r=20$ 的 Fast-DTW 会比 DTW 快了 4-5倍。当 $N$ 不断增大时，加速效果还会更明显。</p>
<h6 id="Fast-DTW的缺点"><a href="#Fast-DTW的缺点" class="headerlink" title="Fast-DTW的缺点"></a>Fast-DTW的缺点</h6><p>由于这种方法得到的是较优解，因此我们有必要关注它的误差。定义误差如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/6OEouycJ5bAe72W.png" alt="image-20200606013024726.png"></p>
<p>经过试验得到误差大小：</p>
<p><img src="https://i.loli.net/2020/06/06/DsCXq1VcRS74I9a.png" alt="image-20200606013005315.png"></p>
<p>可以看到，当 $r=20$ 时，平均误差已经小于 $1%$ 。虽然误差仍然存在，但已经基本可以忽略。</p>
<p>还有一个缺点是编程难度较DTW大。</p>
<h5 id="DTW变种3：constrained-DTW"><a href="#DTW变种3：constrained-DTW" class="headerlink" title="DTW变种3：constrained DTW"></a>DTW变种3：constrained DTW</h5><p>来自论文《Searching and mining trillions of time series subsequences under dynamic time warping》</p>
<p>这篇文章对几种已有的剪枝策略进行了讨论，对它们的下界和时间复杂度进行了比较进行了比较，如下图所示：</p>
<p><img src="https://i.loli.net/2020/06/06/XqjekxGlUFdMbVJ.png" alt="image-20200606141816713.png"></p>
<p>一般认为在虚线下方的剪枝策略是没用的，因为至少存在一种下界更高且时间复杂度更低的策略。</p>
<p>最终作者决定用这种策略：先用 $LB_{Kim}FL$ ，如果不能大于 $Best_so_far$ ，则再用 $LB_{Keogh}EQ$ ，还是不行就用 $LB_{Keogh}EC$，再不行就用 $Early_abandoning_DTW$ 。</p>
<p>至于cDTW，似乎这篇论文并没有提到，查了其他的资料，大概就是把DTW的路径限制在对角线旁边的样子。</p>
<h4 id="平移型对齐策略"><a href="#平移型对齐策略" class="headerlink" title="平移型对齐策略"></a>平移型对齐策略</h4><p>只可一对一，允许两边边界的点（端点及端点附近点）找不到配对，满足连续性。</p>
<p>比较适合的场景：时钟不共享而有一定偏差的两条时间序列</p>
<h5 id="典型例子：cross-correlation：平移型对齐策略下的夹角型度量"><a href="#典型例子：cross-correlation：平移型对齐策略下的夹角型度量" class="headerlink" title="典型例子：cross-correlation：平移型对齐策略下的夹角型度量"></a>典型例子：cross-correlation：平移型对齐策略下的夹角型度量</h5><p>可参考论文&lt;&lt;k-Shape: Efficient and Accurate Clustering of Time Series&gt;&gt;的3.1节的介绍</p>
<p>cross-correlation的定义与卷积类似，对于函数 $f(x)$ 和 $g(x)$ ，它们的 cross-correlation 定义为 </p>
<p>$$h(x)=\int_{-\infin}^{+\infin}f(t)g(x+t)dt$$。事实上，把 + 号改为 - 号就是卷积了。两个已经标准化了的时间序列 $\vec x=(x_1,…,x_m)$ 和 $\vec  y=(y_1,…,y_m)$ 的 cross-correlation 可以这样定义：$CC(\vec x,\vec y)=(c_1,c_2,…,c_{2*m-1})$</p>
<p>其中：$c_{k+m}=\begin{cases}\sum\limits_{l=1}^{m-k}x_{l+k}y_l,k&gt;0\ \vec x · \vec y ,k=0 \ \sum\limits_{l=1-k}^{m}x_{l+k}y_l,k&lt;0 \end{cases}$</p>
<p>然后在 $CC(\vec x,\vec y)$ 中找到一个最大的，记为 $CC_w(\vec x,\vec y)$，定义 $NCC_c(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{\sqrt{R_0(\vec x,\vec x)·R_0(\vec y,\vec y)}}$。这样就把距离归化到 $[-1,1]$。再定义 $SBD(\vec x,\vec y)=1-NCC_c(\vec x,\vec y)$ ，则得到 向量 $\vec x$ 和向量 $\vec y$ 的 SBD（Shape-based distance）距离，对于形状接近的时间序列，这个值接近于0，否则接近于2。</p>
<p>值得注意的是，直接计算两个长为 $m$ 的时间序列的SBD距离是 $O(m^2)$ 的，但我们知道两个序列的卷积可以 $O(mlogm)$ 地计算，而)卷积只用把 $\vec x$ 翻转一下就变成了 $CC(\vec x,\vec y)$，因此，计算 SBD 距离也是 $O(mlogm)$ 的。这会比 $O(m^2)$ 的 DTW 算法快很多。</p>
<p>以下的变种是基于不同标准化思路得到的变种。</p>
<p>&lt;&lt;k-Shape: Efficient and Accurate Clustering of Time Series&gt;&gt;的3.1节的公式8的3个变种</p>
<p>定义 $NCC_b(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{m}$ 这样的结果并不会归一化到一个区间，有啥规律我也看不出来…</p>
<p>定义 $NCC_u(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{w-|w-m|}$，这样的结果是上面有多少项相乘，则结果就除以多少。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A3/" class="post-title-link" itemprop="url">并行与分布式计算作业3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 16:14:54" itemprop="dateCreated datePublished" datetime="2020-05-15T16:14:54+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并行与分布式计算作业3"><a href="#并行与分布式计算作业3" class="headerlink" title="并行与分布式计算作业3"></a>并行与分布式计算作业3</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>​        利用LLVM （C、C++）或者Soot （Java）等工具检测多线程程序中潜在的数据竞争以及是否存在不可重入函数，给出案例程序并提交分析报告。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        用pthreads编写一个简单的并行程序，用附带了ThreadSanitizer的clang对代码进行编译，在终端运行，查看数据竞争情况。再根据ThreadSanitizer的输出结果对代码进行修改，通过忙等待、互斥量和信号量等方法对临界区加锁，消除数据竞争。</p>
<p>​        编写一个检测程序中是否存在不可重入函数的程序，它读取一个IR文件，判断其中的每一个函数是否是不可重入的。</p>
<h2 id="检测数据竞争"><a href="#检测数据竞争" class="headerlink" title="检测数据竞争"></a>检测数据竞争</h2><p>​        根据<br>    $$\pi=4<em>(\sum_{n=1}^{\infty}(-1)^{n-1}</em>\frac{1}{2n-1})$$</p>
<p>​        编写一个计算$\pi$值的并行程序,代码见code1.c:</p>
<p>​        通过命令行参数得到线程数量和要计算的范围。在第33行创建多个线程，每个线程负责计算一部分内容，把结果累加到全局变量sum上。由于多个线程是并行执行的，且会对sum进行修改，所以会出现问题。不用ThreadSanitizer时，程序运行结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/yzVAJMmTWxp6ihv.png" alt="image-20200424185518501.png"></p>
<p>​        可以看到，每次运行结果都不一样，有时偏大有时偏小，说明数据竞争现象确实存在。</p>
<p>​        用ThreadSanitizer检测，结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/RvzdrZ8S3Im7VEh.png" alt="image-20200424190726679.png"></p>
<p>​        可以看到，运行结果显示存在data race，在第21行，刚好就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        一个很自然的想法是，给每个线程创建一个局部变量，把要计算的值加到这个局部变量上，最后再对所有线程求一次和。只需将Thread_sum函数修改为这样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样看似正常，但运行后发现，第24行仍然是多个线程同时修改一个全局变量，仍然存在数据竞争现象:</p>
<p><img src="https://i.loli.net/2020/05/15/hL9vPbIAzw6tsuG.png" alt="image-20200424194846838.png"></p>
<h2 id="解决数据竞争"><a href="#解决数据竞争" class="headerlink" title="解决数据竞争"></a>解决数据竞争</h2><p>​        尝试用忙等待、互斥量和信号量来解决数据竞争问题。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>​        忙等待就是设置一个标记变量，用于指明临界区可以被哪个线程执行，该执行完之后修改这个标记变量，而不能执行临界区的线程必须一直处于忙等待状态。</p>
<p>​        这只用定义一个flag，再对上面的第24行修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">flag=(flag+<span class="number">1</span>)%thread_count;</span><br></pre></td></tr></table></figure>

<p>​        完整代码保存在code2.c</p>
<p>​        ThreadSanitizer似乎不支持用忙等待的方法对临界区加锁:</p>
<p><img src="https://i.loli.net/2020/05/15/hIrN26FVJad5EDu.png" alt="image-20200424221456398.png"></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>​        互斥量能保证同一时间只有一个线程在执行临界区的代码，其他线程只能等待。等当前线程执行完之后，会从等待的线程中随机选一个进入临界区。</p>
<p>​        这只用定义一个互斥量mutex，再将临界区代码修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>​        完整代码保存在code3.c</p>
<p>​        用ThreadSanitizer测试，结果正常，没有warning:<br><img src="https://i.loli.net/2020/05/15/eZdkjpxIVoaWmLY.png" alt="image-20200424220329505.png"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​        信号量(semaphore)可以认为是一种特殊类型的unsigned int，它的类型是sem_t。信号量可以赋值为0,1,……。大多数情况下，我们只用0和1两个值。这种只有0和1值的信号量也称为二元信号量。0对应上了锁的互斥量，1对应没上锁的互斥量。</p>
<p>​        如果我们要用信号量来解决临界区问题，可以先创建一个全局信号量，初始值为1。在临界区前调用sem_wait()函数,这个函数的意义是:如果信号量为0则阻塞；如果是非0值则减1然后进入临界区。临界区执行完之后，调用sem_post()函数将信号量置为1。<del>好像跟互斥量没啥区别</del></p>
<p>​        这也只用定义一个信号量my_semaphore，在main函数里初始化，再将临界区代码修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;my_semaphore);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">sem_post(&amp;my_semaphore);</span><br></pre></td></tr></table></figure>

<p>​        完整代码见code4.c</p>
<p>​        测试一下，也很正常:</p>
<p><img src="https://i.loli.net/2020/05/15/BVSGmTND7Hr42ke.png" alt="image-20200424221059782.png"></p>
<h2 id="检测不可重入函数"><a href="#检测不可重入函数" class="headerlink" title="检测不可重入函数"></a>检测不可重入函数</h2><p>​        利用clang可以生成c语言程序对应的中间表示，下面这个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  B(<span class="number">1</span>);</span><br><span class="line">  val=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    会被转化为</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define void @C(i32) #0 &#123;</span><br><span class="line">  %2 = alloca i32,<span class="built_in"> align </span>4</span><br><span class="line">  store i32 %0, i32* %2,<span class="built_in"> align </span>4</span><br><span class="line">  call void @B(i32 1)</span><br><span class="line">  store i32 1, i32* @val,<span class="built_in"> align </span>4</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们不关心其他的内容，只需要知道:</p>
<ol>
<li><p>函数定义以“define”开始，这一行的第一个  ‘@’  和  ‘(‘  之间的字符串是函数的名字。</p>
</li>
<li><p>调用一个其他函数会以 “call” 开始， 这一行的第一个  ‘@’  和  ‘(‘  之间的字符串是被调用函数的名字。</p>
</li>
<li><p>访问一个全局变量时会用到 ‘@’ ,访问其他变量会用到 ‘%’ 。</p>
<p>此外，被其他函数调用但没有在程序中定义的函数，像printf()函数等，都默认为不可重入函数。</p>
</li>
</ol>
<p>​       知道了这些，就可以写一个程序来检测程序中的不可重入函数了。做法很简单，把函数理解为一个点，把调用关系理解为边，A调用了B就连一条B-&gt;A的边。然后将访问了全局变量的函数和在程序中没有给出定义的函数标记为不可重入函数，从这些 “原生的” 不可重入函数开始进行深度优先搜索，凡是访问到的点都是不可重入函数。深度优先搜索的示例代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;<span class="comment">//用链式前向星的方法存边。这里是遍历u节点的每一条出边。</span></span><br><span class="line">    <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v])&#123;<span class="comment">//如果这个节点没有被访问过</span></span><br><span class="line">      vis[v]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(bkcr[v]!=<span class="number">-1</span>)bkcr[v]=<span class="number">1</span>;<span class="comment">//-1代表的是"原生的" 不可重入函数，1是由于调用了不可重入函数而成为不可重入函数的函数</span></span><br><span class="line">      dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        完整代码见code5.cpp</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​        编写一个test.c，里面有几个函数调用来调用去，如下图所示:</p>
<p><img src="https://i.loli.net/2020/05/15/WJbH2ApZY98dwGE.png" alt="image-20200504124549947.png"></p>
<p>​        用clang生成中间代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O0 -S -emit-llvm ./<span class="built_in">test</span>/test.c -o input.ll</span><br></pre></td></tr></table></figure>

<p>​        进行检测，输出如下:</p>
<p><img src="https://i.loli.net/2020/05/15/NiJcqHf8RXYGzL5.png" alt="image-20200504124714169.png"></p>
<p>​        结果符合预期。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        用ThreadSanitizer可以方便地检测多线程中存在的数据竞争问题，检测到临界区后，可以用互斥量和信号量对它进行加锁。利用llvm可以生成程序的中间代码，然后可以检测其中是否有不可重入函数。</p>
<p>​        这次实验完成的比较简单，主要是因为之前学过一点pthread，还写了篇<a href="https://reeeeeeeeeein.github.io/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" target="_blank" rel="noopener">学习笔记</a>，于是直接把代码和博客的内容拿过来用了(<del>抄自己的博客不算抄吧</del>)。检测不可重入函数稍微有点复杂，不过只要对llvm的中间代码有了基本的了解，学过一些图论算法，解决起来也不算困难。</p>
<p>​        一个比较大的收获是学会了使用ThreadSanitizer来检查数据竞争，大大方便了以后编写多线程程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/" class="post-title-link" itemprop="url">操作系统实验三_操作系统内核</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 15:10:51" itemprop="dateCreated datePublished" datetime="2020-05-15T15:10:51+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验三-操作系统内核"><a href="#操作系统实验三-操作系统内核" class="headerlink" title="操作系统实验三_操作系统内核"></a>操作系统实验三_操作系统内核</h1><p>[toc]</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1、加深理解操作系统内核概念<br>2、了解操作系统开发方法<br>3、掌握汇编语言与高级语言混合编程的方法<br>4、掌握独立内核的设计与加载方法<br>5、加强磁盘空间管理工作</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1、知道独立内核设计的需求<br>2、掌握一种x86汇编语言与一种C高级语言混合编程的规定和要求<br>3、设计一个程序，以汇编程序为主入口模块，调用一个C语言编写的函数处理汇编模块定义的数据，然后再由汇编模块完成屏幕输出数据，将程序生成COM格式程序，在DOS或虚拟环境运行。<br>4、汇编语言与高级语言混合编程的方法，重写和扩展实验二的的监控程序，从引导程序分离独立，生成一个COM格式程序的独立内核。<br>5、再设计新的引导程序，实现独立内核的加载引导，确保内核功能不比实验二的监控程序弱，展示原有功能或加强功能可以工作。<br>6、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>Windows 10</li>
<li>WSL （Windows Subsystem for Linux） [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。</li>
<li>gcc version 7.5.0：C 语言程序编译器，Ubuntu 自带。</li>
<li>ld  version 2.3.0:  链接器，Ubuntu自带</li>
<li>NASM version 2.13.02：汇编程序编译器，通过<code>sudo apt install nasm</code>安装在 WSL 上。</li>
<li>Oracle VM VirtualBox ：轻量开源的虚拟机软件，安装在Windows下。</li>
<li>VSCode - Insiders v1.33.0：好用的文本编辑器，有丰富的插件，可以用它来打开WSL中的文件夹，用它自带的终端执行make命令。</li>
<li>GNU Make 4.1：安装在 Ubuntu 下，一键编译并连接代码，生成最终的文件。</li>
<li>Bochs 2.1.1：安装在Windows下，用于调试代码。</li>
</ul>
<h3 id="自制工具"><a href="#自制工具" class="headerlink" title="自制工具"></a>自制工具</h3><p>​        由于我的虚拟机和Bochs都安装在Windows下，所以需要将WSL中生成的文件写入至Windows的磁盘，这可以用我编写的工具 do 来解决，只需要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;do 文件名 写入的扇区</span><br></pre></td></tr></table></figure>

<p>​        就可以了。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        首先了解c语言程序与汇编语言程序混合编译的方法，再开发操作系统内核，它具有两个主要功能:</p>
<ul>
<li><p>提供加载用户程序的方法，用户可以将程序写入磁盘，然后让操作系统执行这些用户程序。</p>
</li>
<li><p>控制键盘输入和屏幕输出，使得用户可以与操作系统交互。</p>
</li>
</ul>
<p>​        再将上一次实验的4个程序放进磁盘，让操作系统执行它们，查看执行结果是否正确。</p>
<h3 id="c与汇编混合编译"><a href="#c与汇编混合编译" class="headerlink" title="c与汇编混合编译"></a>c与汇编混合编译</h3><p>​        由于操作系统内核非常复杂，只用汇编语言是很难完成的，因此需要使用c语言和汇编语言的混合编译，生成可执行的二进制文件。</p>
<p>​        可以用gcc将一个c语言程序编译生成汇编语言文件，如对下面这个test.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=i386 -m16 -ffreestanding -fno-PIE -masm=intel -S test.c -o test.asm</span><br></pre></td></tr></table></figure>

<p>​        会生成一个x86格式的汇编语言文件test.asm。它的内容很复杂，但我们只用关注一些关键的地方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	push	ebp;函数开始时，总要push ebp，保护这个寄存器</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	.cfi_offset 5, -8</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	.cfi_def_cfa_register 5</span><br><span class="line">	push	3 ;传递参数用push，把参数压到栈里，被调用的函数就能发现</span><br><span class="line">	call	f ;这里调用了f这个函数,用的是call指令</span><br><span class="line">	add	esp, 4 ;由于前面的ret和pop指令，现在esp指向的值就是3，也就是刚才传的参数，所以把esp+&#x3D;3，会让栈恢复到函数调用之前的状态</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	.cfi_restore 5</span><br><span class="line">	.cfi_def_cfa 4, 4</span><br><span class="line">	ret ;返回只用一条ret指令就可以了。由于我的test.c文件没有return 0，所以gcc帮我补上了一条ret指令</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>​         f  函数是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	push	ebp ;这里也是要push ebp</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	.cfi_offset 5, -8</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	.cfi_def_cfa_register 5</span><br><span class="line">	mov	eax, DWORD PTR [ebp+8] ;main函数用了call指令，esp要减4；前面push 了 ebp ，esp又要减4，所以esp+8才是我们传递给f函数的参数。</span><br><span class="line">	inc	eax ;返回一个值，可以把它放在eax里</span><br><span class="line">	pop	ebp ;这里把ebp pop 掉，esp+&#x3D;4</span><br><span class="line">	.cfi_restore 5</span><br><span class="line">	.cfi_def_cfa 4, 4</span><br><span class="line">	ret ;这里返回，esp+&#x3D;4</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>​        看来c语言生成的汇编程序也不算神秘，除了一些奇奇怪怪的指令，跟我们写的汇编程序也没有很大差别。通过上述分析，我们对函数调用和传递参数过程有了更深入的了解。</p>
<p>​        接着，我们编写一个汇编程序（msg.asm）和c程序（count.c）混合编程实例。汇编模块中定义一个字符串（为了方便，假设它以’\n’结尾），调用C语言的函数，统计其中某个字符出现的次数，汇编模块显示统计结果。</p>
<p>​        c程序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;*str!=<span class="string">'\n'</span>;str++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">'e'</span>)i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中，汇编程序调用c程序的函数的过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 0</span><br><span class="line">push string; string 是一个标号，占2个字节，但c语言的指针是4个字节，于是要把前两个字节置为0，就在上面多push一个0</span><br><span class="line">push 0;call会压栈2个字节，但c语言中默认的是压栈4个字节，如果我们不压栈4个字节，c程序中栈的位置会错乱</span><br><span class="line">call count</span><br></pre></td></tr></table></figure>

<p>​        函数返回会把返回值放在eax寄存器，然后汇编程序可以调用 10h 号中断把它显示出来。</p>
<p>​        编写makefile文件（makefile2）如下:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">kernel:msg.o count.o my_mbr</span></span><br><span class="line">	ld -m elf_i386 -N --oformat binary -Ttext 0x7e00 msg.o count.o -o kernel</span><br><span class="line">	<span class="comment">#ld 用于将汇编程序生成的二进制文件和c程序生成的二进制文件链接起来， -Ttest用于指定程序的起始位置为0x7e00处</span></span><br><span class="line">	./do kernel 1 <span class="comment"># 将kernel文件写入磁盘的第一个扇区</span></span><br><span class="line">    ./do my_mbr 0 <span class="comment"># my_mbr是引导扇区程序，它会将kernel文件加载到0x7e00处</span></span><br><span class="line"><span class="section">msg.o:msg.asm</span></span><br><span class="line">	nasm -felf msg.asm -o msg.o <span class="comment"># 如果不加 -felf 参数好像就不能调用c程序中的函数</span></span><br><span class="line">	nm msg.o &gt; tem.txt <span class="comment">#用 nm 命令来分析符号表，输出重定向到tem.txt文件</span></span><br><span class="line"><span class="section">count.o:count.asm</span></span><br><span class="line">	gcc -march=i386 -m16 -mpreferred-stack-boundary=2 -ffreestanding -fno-PIE -masm=intel -c count.c -o count.o</span><br><span class="line">	<span class="comment">#这里跟上文的编译方式基本一样，不同的是 -c 参数指定生成 .o 文件</span></span><br><span class="line">	nm count.o &gt;&gt; tem.txt  <span class="comment">#用 nm 命令来分析符号表，输出重定向到tem.txt文件的末端</span></span><br><span class="line"><span class="section">my_mbr:my_mbr.asm</span></span><br><span class="line">	nasm my_mbr.asm -o my_mbr</span><br></pre></td></tr></table></figure>

<p>​        在VSCode自带终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f makefile2</span><br></pre></td></tr></table></figure>

<p>​        就完成了编译、链接和写入磁盘的工作，非常方便。得到的符号表如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000001a t _end #因为msg.asm里将_start声明为全局变量，_end没有，所以这一行是 小写字母t 表示这是局部变量</span><br><span class="line">00000000 T _start #这一行是大写字母T表示全局变量</span><br><span class="line">         U count</span><br><span class="line">0000001c t string</span><br><span class="line">00000000 T count</span><br><span class="line">0000003f T main</span><br></pre></td></tr></table></figure>

<p>​        用bochs运行，结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/BiZqJkC7Qdv3Ueu.png" alt="image-20200509142152549.png"></p>
<p>​        运行结果正常。</p>
<h3 id="开发操作系统内核"><a href="#开发操作系统内核" class="headerlink" title="开发操作系统内核"></a>开发操作系统内核</h3><p>​        理论上来说，用纯C语言开发内核也是可以的，但要用到很多内嵌汇编，会使程序看起来令人不适。为此，我把 C 程序中需要用到的大量汇编语言代码放置在entry.asm中，c程序只需要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号</span><br></pre></td></tr></table></figure>

<p>​        就可以调用entry.asm 里的各种过程。</p>
<h4 id="汇编程序部分"><a href="#汇编程序部分" class="headerlink" title="汇编程序部分"></a>汇编程序部分</h4><p>​        这部分的内容在entry.asm这个文件中，主要分为三部分。从第6行到第13行是第一部分，主要负责将控制权交给C程序中的main函数，当main函数返回时停机。</p>
<p>​        从第15行到第71行_load_program过程，用于加载用户程序。将程序从磁盘加载到内存可以调用  16h 号中断来实现，但我一调用就会出bug，于是我只能用《x86汇编语言：从实模式到保护模式》这本书里提供的代码。</p>
<p>​        调用这个过程之前要将用户程序被加载到的位置放置在dx中，用户程序在磁盘中的起始扇区放置在si中，用户程序的所占扇区数放置在bx中。</p>
<p>​        从第73行到第111行是clear过程，用于将屏幕清空。这个过程十分简单，不必赘述。</p>
<h4 id="C程序部分"><a href="#C程序部分" class="headerlink" title="C程序部分"></a>C程序部分</h4><p>​        main.c这个文件中的内容是操作系统内核的主要部分。它包括基础I/O操作、工具函数和各种用户交互命令。</p>
<h5 id="I-O-操作"><a href="#I-O-操作" class="headerlink" title="I/O 操作"></a>I/O 操作</h5><p>​        为了方便输入输出，我首先编写了getchar()、putchar()、getline()、put()这4个函数。</p>
<p>​        第23行到第32行的内容是 getchar() 函数，它通过调用 16h 号中断来得到一个输入字符。如果这个字符的值是13（回车符的键盘码），则返回 ‘\n’ 。</p>
<p>​        第34行到第86行的内容是putchar() 函数，它接受一个字符类型的参数，将字符打印到屏幕上。打印的位置由locr 、 locc 这两个全局变量来决定。</p>
<p>​        当要打印的字符是一个普通的字符时，调用 10h 号中断在当前光标处输出这个字符，并调整locr 和 locc 两个变量的值；</p>
<p>​        当要打印的字符是回车符时，将locc置0，将locr++，调用 10h 号中断设置光标的位置为 locc 和 locr 指定的位置；</p>
<p>​        当要打印的字符是退格符时，首先修改 locc 和 locr 两个变量的值，保证这两个值始终都是下一次打印的字符在的屏幕上的位置。然后调用10h号中断修改当前光标的位置为为 locc 和 locr 指定的位置，将这个位置的值清0。</p>
<p>​        getline()函数接受一个字符类型的指针，不断调用getchar()，把读进来的字符存到字符串里，读到回车符就终止，给字符串加上一个 ‘\0’ 。</p>
<p>​        put()函数接受一个字符类型的指针，不断调用putchar()输出它，遇到 ‘\0’ 就终止。</p>
<h5 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h5><p>​        为了方便，我编写了 int_to_str () , str_to_int () 和 strcmp () 这几个函数。意思很明显，内容也缺乏技术含量，不再赘述。</p>
<h5 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h5><p>​        程序会不断循环，每次都用getline读取用户输入的命令，并进行交互，共有clear、help、load 和 quit  4种交互命令。</p>
<p>​        clear命令会将屏幕清空，这只需调用前面说过的entry.asm里的_clear过程就可以了。</p>
<p>​        help命令会打印提示信息。</p>
<p>​        quit命令会终止操作系统内核的执行。</p>
<p>​        load命令是最重要的命令。设计这个命令的初衷是，假设用户有一块装有我的操作系统内核的硬盘，但他完全不懂电脑，只会将程序写入硬盘。这个命令可以让他将程序加载到内存中并运行，而完全不需要修改操作系统的代码。</p>
<p>​        load命令会打印一条提示信息提示，提示用户输入程序在磁盘中的起始位置，再打印一条提示信息，提示用户输入程序在磁盘中占用的扇区数。然后调用 _load_program 过程将程序加载进内存0xa000处，设置es、ds寄存器的值，并将控制权交给用户程序。用户程序运行结束后，操作系统会将es、ds寄存器的值清0，并清空屏幕。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>​        编写一个makefile文件，然后就可以在VSCode自带的终端里输入make完成大量的工作:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">user_programs=user_program_1 user_program_2 user_program_3 user_program_4</span><br><span class="line"><span class="section">all: kernel my_mbr <span class="variable">$(user_programs)</span></span></span><br><span class="line">	./do kernel 1 <span class="comment"># kernel 文件是生成的操作系统内核二进制文件</span></span><br><span class="line">	./do my_mbr 0 <span class="comment"># my_mbr 是引导扇区程序</span></span><br><span class="line"><span class="section">kernel:entry.o main.o  </span></span><br><span class="line">	ld -m elf_i386 -N --oformat binary -Ttext 0x7e00 entry.o main.o -o kernel</span><br><span class="line">	<span class="comment"># 这里将 entry.o 和 main.o 链接成kernel文件，参数在上文介绍过了，不再赘述</span></span><br><span class="line">	nm entry.o &gt; symbol_table.txt <span class="comment">#分析符号表，结果在 symbol_table.txt</span></span><br><span class="line">	nm main.o &gt;&gt; symbol_table.txt</span><br><span class="line"><span class="section">entry.o:entry.asm</span></span><br><span class="line">	nasm -felf <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">	gcc -march=i386 -m16 -mpreferred-stack-boundary=2 -ffreestanding -fno-PIE -masm=intel -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#参数在上文已经介绍过了，不再赘述</span></span><br><span class="line"><span class="section">my_mbr:my_mbr.asm</span></span><br><span class="line">	nasm my_mbr.asm -o my_mbr</span><br><span class="line"><span class="section">user_program_1:user_program_1.asm # user_program是一些用户程序，把它们分别写入到第10,20,30,40个扇区，然后可以在操作系统中加载它们</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 10</span><br><span class="line"><span class="section">user_program_2:user_program_2.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 20</span><br><span class="line"><span class="section">user_program_3:user_program_3.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 30</span><br><span class="line"><span class="section">user_program_4:user_program_4.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 40</span><br></pre></td></tr></table></figure>



<p>​        用bochs运行，依次输入load,10,1（第一个用户程序在磁盘的第10个扇区，大小为1个扇区）：</p>
<p><img src="https://i.loli.net/2020/05/15/W6c7UZwH2i3zbQ5.png" alt="image-20200509201901481.png"></p>
<p>​        效果拨群：</p>
<p><img src="https://i.loli.net/2020/05/15/82qvaxiGgCT6WH1.png" alt="image-20200509202009328.png"></p>
<p>​        按下Ctrl+C，返回操作系统:</p>
<p><img src="https://i.loli.net/2020/05/15/qVfBGdirO8TMtHz.png" alt="image-20200509202136463.png"></p>
<p>​        再依次输入load，20，2 加载第二个程序:</p>
<p><img src="https://i.loli.net/2020/05/15/pB162ZyeUJmLlri.png" alt="image-20200509205136902.png"></p>
<p>​        效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/pUdtYiPCSu12Ff4.png" alt="image-20200509205234324.png"></p>
<p>​        输入 load 40 4 后效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/p8iS1qwUP7LyH3X.png" alt="image-20200509205342547.png"></p>
<p>​        输入load 30 3 后效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/h4wkFUQot7C6lSY.png" alt="image-20200509205446870.png"></p>
<p>​        输入help打印提示信息:</p>
<p><img src="https://i.loli.net/2020/05/15/8FmgjUR9kdExCrw.png" alt="image-20200509205640183.png"></p>
<p>​        输入clear清空:</p>
<p><img src="https://i.loli.net/2020/05/15/oRcXPSM4mfpLC13.png" alt="image-20200509205739629.png"></p>
<p><img src="https://i.loli.net/2020/05/15/krx9MFn3uqolZsK.png" alt="image-20200510163248587.png"></p>
<p>​        输入quit可以退出操作系统：</p>
<p><img src="https://i.loli.net/2020/05/15/Ap3aekdBQ1SIJXP.png" alt="image-20200509205827461.png"></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​        这次实验算得上是很硬核了，用到了很多x86汇编的知识，还要用 ld 这种完全不熟的工具，用gcc里各种奇奇怪怪的参数，甚至为了方便我还学了一下makefile <del>（好像早就该学了吧）</del>    ，遇到的困难也有很多，主要有：</p>
<ul>
<li><p>​        对汇编语言不够了解。主要是函数调用和传参那里，非常麻烦，之前从没有深入了解过。而且C语言程序编译生成的汇编代码跟自己写的在风格上有很大差别，让我很不适应。一开始的时候只能看懂一些关键的语句的意思，好在我看多了之后还是克服了心中的 “恐惧感” 。</p>
</li>
<li><p>​        debug实在是太麻烦了。虽然我会使用bochs调试程序，但很多bug非常隐蔽，包括但不限于:</p>
<ol>
<li><p>在键盘中输入alt+tab切换屏幕，导致后面的输入无法被bochs读入。至今我都没想到解决的办法，好在不影响我写程序。</p>
</li>
<li><p>向c语言的函数传字符串常量会出错。这个问题好像不止我一个遇到，其他的同学和网上的<a href="https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">博客</a>也有这样的问题。我至今也没找到原因，只能把字符串常量改为char*类型。</p>
</li>
<li><p>向指向int类型的指针传short类型变量的地址。我声明了一个short变量，调用 str_to_int (char* s，int* val) 函数的时候把它的地址传了进去，本来我觉得反正都会进行类型转换，没啥问题。可是我执行了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*val=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>之后，问题就来了: short类型变量是2个字节，但 val 指针是int类型的指针，上面的操作会把内存中4个字节全部置为0。更要命的是，由于第一个参数先压栈，第二个字符后压栈，val指向的后面两个字节刚好就是 s 字符串的前两个字节，于是这个函数就不会得到正确的结果。当我想到这个问题时，我不禁为这世上有如此巧妙的bug而感到震惊。</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2020/05/15/QxwsYLrkB8vln9G.png" alt="image-20200509000616841.png"></p>
<p> <img src="https://i.loli.net/2020/05/15/PwOi6rSZyXVCknb.png" alt="image-20200509000427794.png"></p>
<ol start="3">
<li><p>int 16h 读键盘会导致光标位置出错。这是一个很奇怪的bug，不调用int 16h时，用int 10h 中断（ah=3）来读取光标位置可以正常运行，当我用 int 16h 读键盘输入后，用int 10h 中断（ah=03）就完全得不到正确结果，但在光标处打印字符却没有问题。我最终也没整明白这其中的缘由，只能放弃使用int 10h 中断来读取光标位置，改用 locc locr 这两个变量。</p>
<p>我后来想到，debug不一定要对着bochs的那些汇编代码一行行看，用内核输入输出函数也能帮助我debug，这样稍微缓解了我的压力。</p>
</li>
</ol>
<ul>
<li>​        很多工具不会用。说出来有点丢脸，在这次实验之前我从来没用过 ld 这个工具，当我看到老师给的ppt里那一串参数时，突然认识到自己是多么不学无术。经过我反复地尝试、不断地失败后，我总算学会了如何使用ld和gcc完成C程序与汇编程序混合编译<del>事实上只是能跑起来而已，学会是不可能学会的</del>。</li>
</ul>
<p>​        虽然困难很多，但收获也同样不少。通过这次实验，我大大加强了对汇编语言和C语言的了解，对操作系统的工作方式的认识也更加深入了。同时，完成操作系统内核的开发也算是一件很鼓舞人心的事情，这让我有了更多的勇气和兴趣来进一步学习更深的知识。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/</a> （今年大三的学长，博客写的很不错）</li>
<li><a href="https://blog.csdn.net/a200710716/article/details/45936643" target="_blank" rel="noopener">https://blog.csdn.net/a200710716/article/details/45936643</a> （关于键盘输入的ASCII码的资料）</li>
<li><a href="https://www.cnblogs.com/johnshao/archive/2011/06/13/2079638.html" target="_blank" rel="noopener">https://www.cnblogs.com/johnshao/archive/2011/06/13/2079638.html</a> （int 10h 中断的详细介绍）</li>
<li><a href="https://blog.csdn.net/ZCMUCZX/article/details/80462394?locationNum=4&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/ZCMUCZX/article/details/80462394?locationNum=4&amp;fps=1</a> （int 16h 中断的详细介绍）</li>
<li><a href="https://blog.csdn.net/daydayup654/article/details/78630341" target="_blank" rel="noopener">https://blog.csdn.net/daydayup654/article/details/78630341</a> （ ld 工具的详细介绍）</li>
<li><a href="http://c.biancheng.net/view/661.html" target="_blank" rel="noopener">http://c.biancheng.net/view/661.html</a> （gcc 的各种使用姿势）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C_%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C_%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">操作系统实验二_加载用户程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 14:57:12" itemprop="dateCreated datePublished" datetime="2020-05-15T14:57:12+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验二-加载用户程序"><a href="#操作系统实验二-加载用户程序" class="headerlink" title="操作系统实验二_加载用户程序"></a>操作系统实验二_加载用户程序</h1><p>众所周知，引导扇区程序会将操作系统加载到内存中，并把计算机的控制权交给操作系统。问题来了，引导扇区程序是怎么加载用户程序的？</p>
<p>这是一个复杂的问题，为了回答这个问题，首先我们需要了解用户程序的内容有什么样的格式，其次我们需要知道处理器与硬盘交互的方式，最后还要知道引导扇区程序怎么把控制权交给用户程序。</p>
<h2 id="用户程序header段"><a href="#用户程序header段" class="headerlink" title="用户程序header段"></a>用户程序header段</h2><p>在引导扇区程序中，处理器从0x7c00处开始执行代码。然而，对于引导扇区程序会把用户程序加载到哪一个位置，用户程序是不知道的。那就有问题了，如果我在用户程序中要访问数据段中的一个数据，却连这个数据在内存中的位置都不知道，还怎么访问呢？</p>
<p>分段的方法能很好的解决这个问题。用户程序被分为几段，每一段有一个起始地址，如果我们要访问一个数据，只需给出它在段中的偏移地址即可。用户程序会告诉引导扇区程序自己有几个段，每个段相对于程序开始处的偏移是多少，引导扇区程序会给用户程序在内存中分配一个位置，比如说，0xd000，然后假设用户程序的数据段相对于程序开始处偏移为0x100，则数据段会被加载到内存中的0xd100处。然后，引导扇区程序把ds置为0xd10，这样，用户程序就可以用段地址和偏移地址访问内存了。</p>
<p>为了告诉引导扇区程序一些必要的信息，用户程序会有一个header段，里面包含了程序的长度、第一条指令的位置、其他段的个数和其他段的相对偏移量。如图所示:</p>
<p><img src="https://i.loli.net/2020/04/27/WtKF7V15MsSwuJQ.png" alt="image-20200427172648671.png"></p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart&#x3D;0 align&#x3D;16 ;SECTION表明这是一个段的开头，vstart&#x3D;0表明这个段里的所有标号</span><br><span class="line">;都用的是偏移地址，align&#x3D;16表明这个段的起始位置要为16的倍数</span><br><span class="line">length dd program_end;program_end标号在程序的尾部，可以用来得到程序的长度</span><br><span class="line">codeentry dw start;start标号指向程序的第一条指令的位置</span><br><span class="line">          dd section.code_1.start;section.code_1.start指的是code_1这个段的开始位置，第一条指令在这个段里面</span><br><span class="line">          ;根据上面两行，可以知道用户程序的第一条指令的位置</span><br><span class="line">segment_table dw (header_end-code_1_segment)&#x2F;4;段表的长度，即这个程序还有几个段</span><br><span class="line">code_1_segment dd section.code_1.start;code_1段的开始位置</span><br><span class="line">data_1_segment dd section.data_1.start;data_1段的开始位置</span><br><span class="line">stack_segment dd section.stack.start;stack段的开始位置</span><br><span class="line">header_end:</span><br></pre></td></tr></table></figure>

<p>有了这个header段，引导扇区程序就能得到加载用户程序所必须的信息。由于引导扇区程序要将用户程序加载进内存，我们也成引导扇区程序为<strong>加载器</strong>。</p>
<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p>我们来看一下加载器会做些什么。</p>
<p>首先，我们默认加载器知道用户程序在磁盘中的哪一个扇区，也明确了用户程序会被加载到哪一个位置。在加载器的开头，会有一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_sector equ 100</span><br></pre></td></tr></table></figure>

<p>这是一个伪指令，相当于%define first_sector 100。</p>
<p>然后，加载器像其他程序一样，会有一个段声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align&#x3D;16 vstart&#x3D;0x7c00</span><br></pre></td></tr></table></figure>

<p>注意这里vstart=0x7c00。也就是说，后面的标号的值都要加上0x7c00。接下来是正常的设置堆栈段和栈指针的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure>

<p>然后要处理的是用户程序在内存中的起始位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[cs:start_loc]</span><br><span class="line">mov dx,[cs:start_loc+2]</span><br><span class="line">mov bx,16</span><br><span class="line">div bx</span><br><span class="line">mov es,ax</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>一开始时cs寄存器是0，start_loc标号在程序的尾部，内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_loc: dd 0x10000</span><br></pre></td></tr></table></figure>

<p>这个值就是用户程序会被加载到的位置。</p>
<p>由于0x10000是一个20位的数，于是只能用dx:ax两个寄存器来存储。我们将dx:ax除以16，商保存在ax中，将它赋值给es和ds。这样，ds和es就是用户程序的起始段地址。接下来我们读入第一个扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor bx,bx</span><br><span class="line">xor di,di</span><br><span class="line">mov si,first_sector</span><br><span class="line">call read_disk</span><br></pre></td></tr></table></figure>

<p>call指令意思是过程调用，它会先将ip的值保存至栈中，转而取执行read_disk位置的指令。事实上，它就相当于高级语言中的函数。向这个”函数”传递参数的方式是把要用到值放在其他寄存器中。</p>
<p>既然我们要读磁盘，我们得知道把要读哪一个扇区和读出来的内容放在哪里告诉磁盘。这里我们把扇区的位置放置在di:si中，读出来的内容放在[ds:bx]里 。做完这些工作，就可以调用read_disk了，它的内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">read_disk:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,1</span><br><span class="line">out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f3</span><br><span class="line">mov ax,si</span><br><span class="line">out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f4</span><br><span class="line">mov al,ah</span><br><span class="line">out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f5</span><br><span class="line">mov ax,di</span><br><span class="line">out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f6</span><br><span class="line">mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">or al,ah                        ;LBA地址27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f7</span><br><span class="line">mov al,0x20                     ;读命令</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">disk_ok?:</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88</span><br><span class="line">cmp al,0x08</span><br><span class="line">jne disk_ok?</span><br><span class="line"></span><br><span class="line">mov cx,256</span><br><span class="line">mov dx,0x1f0</span><br><span class="line"></span><br><span class="line">read_content:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne read_content</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>看起来很复杂，但只要一条条分析，还是能分析清楚的。首先是把ax,bx,cx,dx 4个寄存器push到栈中。因为我们要修改它们的值，得先把它们保护起来，等这个过程要返回了，就把它们pop回去。</p>
<p>从第7行到第30行，是在向I/O端口读写信息，这些端口是独立编址的。从I/O端口读入信息用in指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,dx</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in ax,dx</span><br></pre></td></tr></table></figure>

<p>dx是要访问的端口号，al、ax是用来保存读入的值。注意不能用其他的寄存器。</p>
<p>相应的，向I/O端口写入信息，要用out指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,al</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,ax</span><br></pre></td></tr></table></figure>

<p>dx是访问的端口号，al、ax是要写入的值。</p>
<p>in、out指令的dx参数也可以用立即数代替。</p>
<p>主硬盘端口分配的端口号是0x1f0-0x1f7。</p>
<p>其中，0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<p>0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。</p>
<p>0x1f2端口用于设置要读取的扇区数量，0x1f3-0x1f6端口用于设置起始扇区号。扇区号有28个字节，0-7字节要放在0x1f3里，8-15字节要放在0x1f4里，16-23字节要放在0x1f5里，24-27字节要放在0x1f6里。0x1f6的高4位置为1110。</p>
<p>端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送 读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第 7 位置 “1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第 3 位置“1”，意思是准备好了，请求主机发送或者接收数据。</p>
<p>了解了这些后，第7-30行的代码也就很容易理解了。</p>
<p>第32-36行是在不断判断硬盘是否准备好，如果没有则继续循环。</p>
<p>第38行将cx置为256，因为一个扇区是512个字节，一次读出2个字节。第39行将dx置为0x1f0，即从0x1f0读入数据。</p>
<p>第41-47行不断将数据读入到[ds:bx]处，然后将bx+=2。</p>
<p>最后恢复ax,bx,cx,dx寄存器，注意顺序要反过来。</p>
<p>第一次读完磁盘后，用户程序的第一个扇区就已经在内存里了。接下来要进行一些很重要的工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov dx,[bx+2]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov bx,512</span><br><span class="line">div bx</span><br><span class="line">cmp dx,0</span><br><span class="line">je tem1</span><br><span class="line">inc ax</span><br></pre></td></tr></table></figure>

<p>用户程序的前4个字节是用户程序的大小，先把它读入到ds:ax中，然后除以512，得到用户程序在磁盘中的扇区数。注意，如果用户程序的大小恰好为512的倍数，则除法指令结束后，ax的值就是用户程序占的扇区数，此时dx为0；否则，这个数字要加1。</p>
<p>接下来要读入其他扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tem1:</span><br><span class="line">dec ax</span><br><span class="line">mov cx,ax</span><br><span class="line">cmp cx,0</span><br><span class="line">je tem3</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">tem2:</span><br><span class="line">xor bx,bx</span><br><span class="line">inc si</span><br><span class="line">mov ax,ds</span><br><span class="line">add ax,0x20</span><br><span class="line">mov ds,ax</span><br><span class="line">call read_disk</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne tem2</span><br></pre></td></tr></table></figure>

<p>首先将ax减1(刚才已经读了一个扇区了)。如果ax==0，则跳过下面的工作；否则进入tem2这个循环。</p>
<p>循环里每次将si加1(ds:si是要读的扇区号)，将ds+=0x20(写入内存的位置每次往后推512个字节)，将bx置为0，然后调用read_disk过程读入扇区。</p>
<p>把扇区读完了，接下来要确定用户程序的第一条指令的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tem3:</span><br><span class="line">mov dx,[0x08]</span><br><span class="line">mov ax,[0x06]</span><br><span class="line">call segment_reloc</span><br></pre></td></tr></table></figure>

<p>回忆一下，第一条指令的位置是通过 段地址(第一条指令所在段的首地址)+偏移地址(第一条指令相对于段地址的差值) 给出的。在[ds:bx+0x06]到[ds:bx+0x09]之间的是段地址。我们把它的值与用户程序在内存中的首地址相加，就得到了这个段的真实地址，再把它右移4位，送到ax寄存器中。上述过程会被执行很多次（有好几个段），所以我们把它写成一个segment_reloc过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push dx</span><br><span class="line"></span><br><span class="line">add ax,[cs:start_loc]</span><br><span class="line">add dx,[cs:start_loc+0x02]</span><br><span class="line">shr ax,4</span><br><span class="line">shl dx,12</span><br><span class="line">or ax,dx</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>shr指令是右移4位，shl指令是左移12位，or指令把ax和dx合起来（ax的高4位为0，dx的低12位为0）。</p>
<p>得到真实段地址右移4位的值后，把它送回[ds:0x06]处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x06],ax</span><br></pre></td></tr></table></figure>

<p>接下来要读段表。首先从[ds:0x0a]处取出一个字放到cx中，表示段表的大小，然后将bx置为0x0c，这是段表的首地址相对用户程序起始处的偏移地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov cx,[0x0a]</span><br><span class="line">mov bx,0x0c</span><br></pre></td></tr></table></figure>

<p>接下来要一个个读:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">segment_table_reloc:</span><br><span class="line">mov dx,[bx+0x02]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">call segment_reloc</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,4</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne segment_table_reloc</span><br></pre></td></tr></table></figure>

<p>这部分内容跟开始时读段表差不多，不再赘述。</p>
<p>折腾完这些，加载器的工作差不多完成了，可以把控制权交给用户程序了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far [0x04]</span><br></pre></td></tr></table></figure>

<p>jmp far是 16 位间接绝对远转移。上面一条指令会从 ds:0x04 处取出6个字节，把前两个字节作为一个字，它是指令的偏移地址；后4个字节被当成一个双字，是指令所在段的地址（这个地址已经被我们重定位过了）。这样就能跳到用户程序的第一条指令了。注意，此时ds,es的值都是用户程序在内存中的首地址右移4位的值。</p>
<h2 id="用户程序其他内容"><a href="#用户程序其他内容" class="headerlink" title="用户程序其他内容"></a>用户程序其他内容</h2><p>看看用户程序会做什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SECTION code_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">start:</span><br><span class="line">mov ax,[stack_segment]</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,stack_end</span><br><span class="line"></span><br><span class="line">mov ax,[data_1_segment]</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,msg</span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">xor ax,ax</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">do:</span><br><span class="line">mov al,[bx]</span><br><span class="line">inc bx</span><br><span class="line">mov [es:di],al</span><br><span class="line">inc di</span><br><span class="line">mov byte [es:di],0x07</span><br><span class="line">inc di</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne do</span><br><span class="line"></span><br><span class="line">jmp near $</span><br><span class="line"></span><br><span class="line">SECTION data_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">msg db &#39;hello world!&#39;</span><br><span class="line"></span><br><span class="line">SECTION stack align&#x3D;16 vstart&#x3D;0</span><br><span class="line">resb 256</span><br><span class="line">stack_end:</span><br><span class="line">SECTION trail align&#x3D;16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>

<p>第1行声明了一个段，第3行就是我们期待已经的第一条指令。前3条指令用于设置段指针和段寄存器的值。</p>
<p>第7，8行两行设置数据段寄存器ds的值，第9,10行两行设置附加段寄存器es的值。</p>
<p>从第12行开始是一个很正常的显示字符串的工作，不再赘述。</p>
<p>第32行声明了数据段，里面只有一个字符串。</p>
<p>第35行声明了堆栈段，里面用resb指令保留了256个字节。注意，stack_end标号是在resb指令的后面，因为栈指针的值是不断减小的。</p>
<p>最后，第38行声明了一个trail段，它没什么用，值得注意的是它没有vstart=0这个定义，所以标号program_end的值是从0开始算的，所以它的值就是用户程序的大小。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>用bochs运行，结果如下:</p>
<p><img src="https://i.loli.net/2020/04/27/j79IMNP2pcyd46C.png" alt="image-20200427174119405.png"></p>
<p>效果拨群。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80_%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80_%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">操作系统实验一_引导扇区程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 14:56:04" itemprop="dateCreated datePublished" datetime="2020-05-15T14:56:04+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验一-引导扇区程序"><a href="#操作系统实验一-引导扇区程序" class="headerlink" title="操作系统实验一_引导扇区程序"></a>操作系统实验一_引导扇区程序</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​        锻炼编写汇编语言程序的能力，增加对操作系统启动方式的了解，学习bochs调试工具、NASM编译工具的使用。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>​        设计IBM_PC的一个引导扇区程序，程序功能是：用字符‘A’从屏幕左边某行位置45度角下斜射出，保持一个可观察的适当速度直线运动，碰到屏幕的边后产生反射，改变方向运动，如此类推，不断运动；在此基础上，增加你的个性扩展，如同时控制两个运动的轨迹，或炫酷动态变色，个性画面，如此等等，自由不限。还要在屏幕某个区域特别的方式显示你的学号姓名等个人信息。将这个程序的机器码放进放进第三张虚拟软盘的首扇区，并用此软盘引导你的XXXPC，直到成功。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​        使用NASM来编译代码，由于VSCode里可以使用终端，所以我用VSCode来编写汇编代码，然后可以方便的在终端里用NASM。<br>​        用《x86汇编语言-从实模式到保护模式》这本书附带的fixvhdwr来将二进制文件写入至硬盘，然后使用bochs2.1.1来对程序进行调试，调试无误后把二进制文件放到VirtualBox运行。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​        我计划按实验要求的方法在屏幕上循环显示”reeeeeeeeeein”,并且字符的颜色不相同,每显示一些字符之后就把屏幕刷新。如下图所示:</p>
<p><img src="https://i.loli.net/2020/04/23/b3kvIO5Efi6KDJj.png" alt="image.png"></p>
<p>​        首先我们要确定当前要显示的位置，这就需要知道是在哪一行哪一列。于是我在程序末尾分配两个变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locr: db 0 ;当前所在行</span><br><span class="line">locc: db 0 ;当前所在列</span><br></pre></td></tr></table></figure>

<p>​        为了方便，以后直接用locr指代[ds:locr]这个位置存储的值，其他变量也是同理。</p>
<p>​        知道了当前位置，还需要知道下一个位置。下一个位置无非是由当前位置往左往右往上往下得到，于是我又分配了两个变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_or_d: db 0 ;上还是下，0是下，1是上</span><br><span class="line">l_or_r: db 0 ;0右，1左</span><br></pre></td></tr></table></figure>

<p>​        要显示”reeeeeeeeeein”,得知道现在要显示的是第几个字符，还要把这个字符串存储起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words: db &#39;r&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;i&#39;,&#39;n&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc: db 0 ;当前显示第几个字母</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%define name_length 13;字符串的长度为13</span><br></pre></td></tr></table></figure>

<p>​        为了美观，背景颜色就用默认的黑色，而字符的前景颜色用颜色表里I=1的8个颜色:<br><img src="https://i.loli.net/2020/04/23/u9dmARTcgSlZJGt.png" alt="image.png"><br>​        所以分配一个变量存储当前的颜色:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: db 8;颜色从8显示到15</span><br></pre></td></tr></table></figure>

<p>​        在我的电脑上，bochs和VirtualBox虚拟机的屏幕宽度都是80个字符。于是我设置可显示的宽度为80，可显示的高度为17。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%define width 80</span><br><span class="line">%define height 17</span><br></pre></td></tr></table></figure>

<p>​        要刷新屏幕，得用一个计数器，当它减到0就刷新一次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%define flush_seq 300</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_or_not: dw flush_seq;注意这里只能dw不能db，因为300&gt;255</span><br></pre></td></tr></table></figure>

<p>​        此外，为了显示我的””知识产权”，我会屏幕下方显示”made by zjr”这个字符串。</p>
<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><h4 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h4><p>​        把上面这些工作做完了，就可以开始编写一些重要的代码了。首先看一下显示字符的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">do:</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov al,[ds:locr]</span><br><span class="line">  imul bx,ax,width</span><br><span class="line">  mov ax,bx</span><br><span class="line">  xor bx,bx</span><br><span class="line">  mov bl,[ds:locc]</span><br><span class="line">  add ax,bx</span><br><span class="line">  add ax,ax</span><br><span class="line">  mov di,ax;到这里，es:di就是我们要访问的位置</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov al,[ds:loc]</span><br><span class="line">  mov si,ax</span><br><span class="line">  mov al,[ds:si+words]</span><br><span class="line">  mov [es:di],al</span><br><span class="line">  mov al,[ds:color]</span><br><span class="line">  mov byte [es:di+1],al</span><br><span class="line">  inc al</span><br><span class="line">  cmp al,16</span><br><span class="line">  jne tem0</span><br><span class="line">  mov al,8</span><br><span class="line">  tem0:</span><br><span class="line">  mov [ds:color],al</span><br><span class="line">  inc byte [ds:loc]</span><br><span class="line">  cmp byte [ds:loc],name_length</span><br><span class="line">  jne tem1</span><br><span class="line">  mov byte [ds:loc],0</span><br></pre></td></tr></table></figure>

<p>​        当前显示的位置是:</p>
<p>$$<br>locr*width+locc<br>$$</p>
<p>​        第二行把ax清0(这是有必要的，如果ah的值不为0可能得到错误的结果)。把locr的内容放到al里，然后第四行把ax和width相乘，结果放到bx。</p>
<p>​        第五行到第十行是把bx放到ax，并把locc加到ax里，然后ax乘2。ax乘2的原因是显示屏上显示一个字符要2个字节。最后把ax放到di里。这样，es:di就是我们当前要显示的位置。</p>
<p>​        从第11行到第15行是找到要显示的字符。首先取出loc，再用$ds:words+loc$得到要显示的字符的位置，最后把这个字符取出来，放到$es:di$里。</p>
<p>​        第16行开始是在确定字符的前景颜色，这跟找到字符是差不多的。注意color要自增一次，自增完之后要判断它是否等于16，如果等于，就把color置为8。</p>
<p>​        第24行开始是对loc的自增，然后判断是否是8，是的话就置为0。</p>
<h4 id="下一个位置"><a href="#下一个位置" class="headerlink" title="下一个位置"></a>下一个位置</h4><p>​        显示了当前的字符后，要确定下一个字符的位置，这就需要u_or_d和l_or_r这两个变量。u_or_d取值为0，则locr要加1，否则locr要减1；l_or_r取值为0，则locc加1，否则locc要减1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tem1:</span><br><span class="line">  cmp byte [ds:u_or_d],0</span><br><span class="line">  je tem2</span><br><span class="line">    dec byte [ds:locr]</span><br><span class="line">    jmp tem3</span><br><span class="line">  tem2:</span><br><span class="line">    inc byte [ds:locr]</span><br><span class="line">  tem3:</span><br><span class="line"></span><br><span class="line">  cmp byte [ds:l_or_r],0</span><br><span class="line">  je tem4</span><br><span class="line">    dec byte [ds:locc]</span><br><span class="line">    jmp tem5</span><br><span class="line">  tem4:</span><br><span class="line">    inc byte [ds:locc]</span><br></pre></td></tr></table></figure>



<p>​        先看1到7行:判断u_or_d是否为0，是则跳到tem2，把locr加1；否则把locr减1，然后跳到tem3,不执行tem2那里的操作。其实就是一个if-else语句。</p>
<p>​        10到16行基本与之相同，不再赘述。</p>
<h4 id="调整方向"><a href="#调整方向" class="headerlink" title="调整方向"></a>调整方向</h4><p>​        接下来，要判断方向要不要调整。如果locr到达height-1，则要把u_or_d改为1；如果locr到达0，则要把u_or_d改为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tem5:</span><br><span class="line"> cmp byte [ds:locr],height-1</span><br><span class="line"> jne tem6</span><br><span class="line"> mov byte [ds:u_or_d],1</span><br><span class="line"></span><br><span class="line"> tem6:</span><br><span class="line"> cmp byte [ds:locr],0</span><br><span class="line"> jne tem7</span><br><span class="line"> mov byte [ds:u_or_d],0</span><br><span class="line"></span><br><span class="line"> tem7:</span><br><span class="line"> cmp byte [ds:locc],width-1</span><br><span class="line"> jne tem8</span><br><span class="line"> mov byte [ds:l_or_r],1</span><br><span class="line"></span><br><span class="line"> tem8:</span><br><span class="line"> cmp byte [ds:locc],0</span><br><span class="line"> jne tem9</span><br><span class="line"> mov byte [ds:l_or_r],0</span><br></pre></td></tr></table></figure>

<p>​        先判断locr是否等于height-1，不等于就跳到tem6位置，不执行第4行。如果等于就执行第4行，把u_or_d改为1；再判断它是否为0，是的话就执行第9行，把u_or_d改为0。值得注意的是，两个判断语句是相互独立的，所以第三行不能调到tem7，而是要跳到tem6。</p>
<p>​        第11行往后跟前面基本是一样的。</p>
<h4 id="其他工作"><a href="#其他工作" class="headerlink" title="其他工作"></a>其他工作</h4><p>​        每打印一个字符，会让程序暂停一段时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tem9:</span><br><span class="line">  mov ah,86h</span><br><span class="line">  mov cx,0x1E</span><br><span class="line">  mov dx,0x8480     </span><br><span class="line">  int 15h</span><br></pre></td></tr></table></figure>



<p>​        考虑到如果屏幕字符很多会很影响观看体验，所以每打印300个字符会把屏幕刷新一遍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp word [ds:flush_or_not],0</span><br><span class="line">jne tem10</span><br><span class="line">mov word [ds:flush_or_not],flush_seq</span><br><span class="line">jmp flush</span><br><span class="line">tem10:</span><br><span class="line">  dec word [ds:flush_or_not]</span><br><span class="line">jmp do</span><br></pre></td></tr></table></figure>

<p>​        当flush_or_not等于0时，把它重新置为flush_seq，然后跳到flush段的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flush:</span><br><span class="line">  mov ax,width</span><br><span class="line">  imul bx,ax,height</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov di,ax</span><br><span class="line">  flush_do:</span><br><span class="line">    add di,di</span><br><span class="line">    mov byte [es:di],0</span><br><span class="line">    mov byte [es:di+1],0</span><br><span class="line">    inc ax</span><br><span class="line">    mov di,ax</span><br><span class="line">    cmp ax,bx</span><br><span class="line">    jl flush_do</span><br></pre></td></tr></table></figure>

<p>​        首先用width和height相乘，得到要刷新的总字节数。然后执行循环，当ax&lt;bx时继续，否则退出。循环里把di*2，然后将es:di和es:di+1置为0(注意一个字符占的位置是两个字节)，最后ax+1，将di置为ax。</p>
<p>​        把上面这段代码放在do标志前面，这样程序开始的时候就会把屏幕刷新。</p>
<p>​        在程序开始的地方要设置段寄存器和附加段寄存器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x7c0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br></pre></td></tr></table></figure>

<p>​        在屏幕下方打印”made by zjr”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,width</span><br><span class="line">imul bx,ax,height+2</span><br><span class="line">add bx,bx</span><br><span class="line">mov di,bx</span><br><span class="line">xor cx,cx</span><br><span class="line">mov si,cx</span><br><span class="line">do2:</span><br><span class="line">  mov al,[ds:si+my_name]</span><br><span class="line">  mov [es:di],al</span><br><span class="line">  inc di</span><br><span class="line">  inc di</span><br><span class="line">  inc si</span><br><span class="line">  cmp si,name2_length</span><br><span class="line">  jne do2</span><br></pre></td></tr></table></figure>

<p>​        由于显示”reeeeeeeeeein”的位置是左上角(0,0)到右下角(height-1,width-1),可以让”maded by zjr”字符串在(height+2,0)开始显示，于是用bx存储$width<em>(height+2)</em>2$，把它复制给di，然后就可以用es:di直接访问要存储的位置。此后进入循环，用si做循环变量，每次用[ds:si+my_name]得到要打印的字符，赋值给al，再把它送到到打印的位置。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>​        在VSCode里新建终端，输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NASM proj.asm -o p</span><br></pre></td></tr></table></figure>

<p>​        得到一个二进制文件。然后使用fixvhdwr把它写到一个文件格式为vhd的虚拟硬盘:</p>
<p><img src="https://i.loli.net/2020/05/15/m2Colb69jveKOUz.png" alt="image-20200423194702107.png"></p>
<p>​        然后选择这个二进制文件:</p>
<p><img src="https://i.loli.net/2020/05/15/Bfj7THwEq84MxRX.png" alt="image-20200423194811099.png"></p>
<p>​        写入完成后，可以用bochs打开:</p>
<p><img src="https://i.loli.net/2020/05/15/QbgTUBG2pA81Frx.png" alt="image-20200423195008833.png"></p>
<p>​        可以看到，结果符合预期。</p>
<p>​        然后可以用VirtualBox验证一下:</p>
<p>​        首先把刚才生成的二进制文件保存为img格式:</p>
<p><img src="https://i.loli.net/2020/05/15/r73KEhFymjLkSWv.png" alt="image-20200423195208552.png"></p>
<p>​        新建一个虚拟机:</p>
<p><img src="https://i.loli.net/2020/05/15/7bDsRBiTzPXmWfC.png" alt="image-20200423195406846.png"></p>
<p>​        点击右边的存储，往里面添加刚才创建的img文件作为软驱:</p>
<p><img src="https://i.loli.net/2020/05/15/LBQdsMFyj1ur3ft.png" alt="image-20200423195524820.png"></p>
<p>在系统一栏设置启动顺序为软驱优先:</p>
<p><img src="https://i.loli.net/2020/05/15/tUvoYS4eaLFDqKQ.png" alt="image-20200423195708890.png"></p>
<p>​        启动后就能看到结果：</p>
<p><img src="https://i.loli.net/2020/05/15/6czsDHAn1IuLJgB.png" alt="image-20200423195854503.png"></p>
<p>​        (似乎在virtualbox里显示的比bochs慢，并不知道为什么)</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>​        这次实验整体难度不算特别大，只对编写汇编代码有较基本的要求。我本来在2月份的时候就已经完成了，但只录了视频，没有写实验报告就交上去了，结果两个月过后，代码找不到了，实验报告也写不成了，没办法，只能重新写一遍，就算是练习吧。</p>
<p>​        虽然写的代码并不多，但还是有不少奇奇怪怪的bug,比如:</p>
<p><img src="https://i.loli.net/2020/05/15/beE8Kg6wa3mCvxu.png" alt="image-20200423200349299.png"></p>
<p>​        这里loc变量长度是一个字节，而si是一个16位的寄存器。把loc赋值给si后，尽管我加了个byte，但第36行的[ds:si]还是会取两个字节的值。一开始loc后面是没有变量的，运行结果十分正常，后来我在后面加了一个<img src="https://i.loli.net/2020/05/15/Bn3PD8pvrxhe72w.png" alt="image-20200423200602504.png"></p>
<p>​        取[ds:si]的时候就得到一个很大的值。这个bug困扰了我很久，直至我想起来si是个16位寄存器。</p>
<p>​        类似于这样的bug还有很多，不再一一列举。以后我得多练习汇编语言编程，为以后其他的实验做准备。</p>
<p>​        本次实验最大的收获还是增强了汇编语言编程能力，此外我还学会了用bochs进行debug，这对以后做实验是一个很大的帮助。还有的就是感谢TA推荐了Typora这个编写MarkDown文档的工具，确实比我之前用的VSCode插件好用很多，也算是一个意外之喜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_chat%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_chat%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计算机网络实验二_chat实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-14T00:00:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-15 14:40:00" itemprop="dateModified" datetime="2020-05-15T14:40:00+08:00">2020-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络实验2-Chat实验"><a href="#计算机网络实验2-Chat实验" class="headerlink" title="计算机网络实验2_Chat实验"></a>计算机网络实验2_Chat实验</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>利用客户/服务器(Client/Sever或CS)模式实现一个多人聊天(群聊)程序。其功能是每个客户发送给服务器的消息都会传送给所有的客户端。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>采用linux编程，调用pthread库</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1.编写多人聊天程序，要求客户端和服务器都采用多线程方式进行编程。每个客户端都采用TCP协议连接服务器并保持连接。服务器同时与所有客户端建立和保持连接。每个客户端输入的消息都会通过服务器转发给所有客户。</p>
<p>客户端程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN          2000                  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * main - TCP client for TIME service</span></span><br><span class="line"><span class="comment"> *------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">client_recv</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_sock=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">char</span>* buf=<span class="keyword">new</span> <span class="keyword">char</span>[BUFSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1=recv(my_sock,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message received: %s\n"</span>,buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>    *host = <span class="string">"127.0.0.1"</span>;        <span class="comment">/* server IP to connect         */</span></span><br><span class="line">        <span class="keyword">char</span>    *service = <span class="string">"50500"</span>;         <span class="comment">/* server port to connect       */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>             <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">        <span class="keyword">char</span>    buf[BUFLEN+<span class="number">1</span>];              <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">        <span class="keyword">int</span>     sock;                       <span class="comment">/* socket descriptor            */</span></span><br><span class="line">        <span class="keyword">int</span>     cc;                         <span class="comment">/* recv character count         */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">        sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                         <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                      <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_family = AF_INET;                        <span class="comment">// 因特网地址簇</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">      <span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service));         <span class="comment">// 设置服务器端口号</span></span><br><span class="line">        <span class="keyword">int</span> ret=connect(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line">        pthread_create(&amp;thread_handle,<span class="literal">NULL</span>,client_recv,(<span class="keyword">void</span>*)sock);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"请输入要发送的消息:"</span>);</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"exit"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出成功!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> c1=send(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(sock);                             <span class="comment">// 关闭监听套接字</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">        getchar();                              <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_socks 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> buf_size 1000</span></span><br><span class="line"><span class="keyword">int</span>* socks[max_socks],now_loc;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span>* pts=<span class="keyword">new</span> <span class="keyword">char</span>[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = recv(my_sock, pts, buf_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pts[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"服务器收到消息: %s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">/* argc: 命令行参数个数， 例如：C:\&gt; TCPServer 8080</span></span></span><br><span class="line"><span class="function"><span class="comment">                  argc=2 argv[0]="TCPServer",argv[1]="8080" */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_handles=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(max_socks*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">fsin</span>;</span> <span class="comment">/* the from address of a client       */</span></span><br><span class="line">  <span class="keyword">int</span> msock, ssock;        <span class="comment">/* master &amp; slave sockets         */</span></span><br><span class="line">  <span class="keyword">char</span> *service = <span class="string">"50500"</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">/* an Internet endpoint address             */</span></span><br><span class="line">  <span class="keyword">int</span> alen;               <span class="comment">/* from-address length                      */</span></span><br><span class="line">  <span class="keyword">char</span> pts[<span class="number">1000</span>];         <span class="comment">/* pointer to time string           */</span></span><br><span class="line">  <span class="keyword">time_t</span> now;             <span class="comment">/* current time                                 */</span></span><br><span class="line"></span><br><span class="line">  msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">// 创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                    <span class="comment">// 返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                     <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                            <span class="comment">// 因特网地址簇(INET-Internet)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;                    <span class="comment">// 监听所有(接口的)IP地址。</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service)); <span class="comment">// 监听的端口号。atoi--把ascii转化为int，htons--主机序到网络序(host to network，s-short 16位)</span></span><br><span class="line">  bind(msock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));   <span class="comment">// 绑定监听的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">  listen(msock, <span class="number">5</span>); <span class="comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;                                                                         <span class="comment">// 检测是否有按键,如果没有则进入循环体执行</span></span><br><span class="line">      alen = <span class="keyword">sizeof</span>(struct sockaddr);                                      <span class="comment">// 取到地址结构的长度</span></span><br><span class="line">      ssock = accept(msock, (struct sockaddr *)&amp;fsin, (<span class="keyword">socklen_t</span> *)&amp;alen); <span class="comment">// 如果在连接请求队列中有连接请求，</span></span><br><span class="line">      socks[now_loc]=<span class="keyword">new</span> <span class="keyword">int</span>(ssock);</span><br><span class="line">      pthread_create(&amp;thread_handles[now_loc],<span class="literal">NULL</span>,serve,(<span class="keyword">void</span>*)now_loc);</span><br><span class="line">      now_loc++;</span><br><span class="line">  &#125;</span><br><span class="line">  close(msock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果:<br><img src="https://i.loli.net/2020/05/15/X2EWRokZ9QuJBUh.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/15/YDWgXzjtUG6s7Tf.png" alt="image.png"></p>
<p>2.服务器程序转发某个客户端发来的消息时都在消息前面加上该客户端的IP地址和端口号以及服务器的当前时间。要求服务器程序把转发的消息也显示出来。</p>
<p>服务器程序(修改部分)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_socks 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> buf_size 1000</span></span><br><span class="line"><span class="keyword">int</span>* socks[max_socks],now_loc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">fsin</span>[<span class="title">max_socks</span>];</span> <span class="comment">/* the from address of a client       */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span>* pts=<span class="keyword">new</span> <span class="keyword">char</span>[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tem=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: "</span>,</span><br><span class="line">    (tem&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(tem&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(tem&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,tem&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock, pts + c1, <span class="number">1000</span>-c1, <span class="number">0</span>);</span><br><span class="line">    pts[c1 + c2] = <span class="string">'\n'</span>;</span><br><span class="line">    pts[c1+c2+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">/* argc: 命令行参数个数， 例如：C:\&gt; TCPServer 8080</span></span></span><br><span class="line"><span class="function"><span class="comment">                  argc=2 argv[0]="TCPServer",argv[1]="8080" */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_handles=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(max_socks*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">int</span> msock, ssock;        <span class="comment">/* master &amp; slave sockets         */</span></span><br><span class="line">  <span class="keyword">char</span> *service = <span class="string">"50500"</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">/* an Internet endpoint address             */</span></span><br><span class="line">  <span class="keyword">int</span> alen;               <span class="comment">/* from-address length                      */</span></span><br><span class="line">  <span class="keyword">char</span> pts[<span class="number">1000</span>];         <span class="comment">/* pointer to time string           */</span></span><br><span class="line">  <span class="keyword">time_t</span> now;             <span class="comment">/* current time                                 */</span></span><br><span class="line"></span><br><span class="line">  msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">// 创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                    <span class="comment">// 返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                     <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                            <span class="comment">// 因特网地址簇(INET-Internet)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;                    <span class="comment">// 监听所有(接口的)IP地址。</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service)); <span class="comment">// 监听的端口号。atoi--把ascii转化为int，htons--主机序到网络序(host to network，s-short 16位)</span></span><br><span class="line">  bind(msock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));   <span class="comment">// 绑定监听的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">  listen(msock, <span class="number">5</span>); <span class="comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;                                                                         <span class="comment">// 检测是否有按键,如果没有则进入循环体执行</span></span><br><span class="line">      alen = <span class="keyword">sizeof</span>(struct sockaddr);                                      <span class="comment">// 取到地址结构的长度</span></span><br><span class="line">      ssock = accept(msock, (struct sockaddr *)&amp;fsin[now_loc], (<span class="keyword">socklen_t</span> *)&amp;alen); <span class="comment">// 如果在连接请求队列中有连接请求，</span></span><br><span class="line">      socks[now_loc]=<span class="keyword">new</span> <span class="keyword">int</span>(ssock);</span><br><span class="line">      pthread_create(&amp;thread_handles[now_loc],<span class="literal">NULL</span>,serve,(<span class="keyword">void</span>*)now_loc);</span><br><span class="line">      now_loc++;</span><br><span class="line">  &#125;</span><br><span class="line">  close(msock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏:<br><img src="https://i.loli.net/2020/05/15/voCymHlJwVsk4re.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/15/pZMjuklzbSs2GfE.png" alt="image.png"></p>
<p>3.新客户刚连接时服务器端把“enter”消息（包含客户端IP地址和端口号）发送给所有客户端。<br>服务器程序(修改部分)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只修改了serve函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span> pts[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span> tem[buf_size+<span class="number">1</span>]=<span class="string">"Enter!\n"</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> port=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: %s"</span>,</span><br><span class="line">    (port&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,port&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch,tem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock,tem,buf_size, <span class="number">0</span>);</span><br><span class="line">    tem[c2] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏：<br>第一个客户端启动:<br><img src="https://i.loli.net/2020/05/15/DytxLFilVIW1B37.png" alt="image.png"><br>第二个客户端启动:<br><img src="https://i.loli.net/2020/05/15/8xwAv2zTSJMbUHI.png" alt="image.png"></p>
<p>4.客户端输入exit时退出客户端程序（正常退出），或者客户端直接关闭窗口退出（异常退出），服务器都会把该客户leave的消息广播给所有客户。<br>服务器程序(修改部分)：<br>只修改了serve函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span> pts[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span> tem[buf_size+<span class="number">1</span>]=<span class="string">"Enter!\n"</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> port=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: %s"</span>,</span><br><span class="line">    (port&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,port&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch,tem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tem,<span class="string">"Leave!\n"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock,tem,buf_size, <span class="number">0</span>);</span><br><span class="line">    tem[c2] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(tem,<span class="string">"Leave!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏：<br>客户端用输入exit离开时:<br><img src="https://i.loli.net/2020/05/15/qFluxBEg2CJRpVA.png" alt="image.png"><br>客户端用Ctrl+C退出时:<br><img src="https://i.loli.net/2020/05/15/oOM3ydBrRLQ16Em.png" alt="image.png"></p>
<p>5.运行客户端程序测试与老师的服务器程序的连接（103.26.79.35:50500）。<br>运行截屏（客户端）：</p>
<p><img src="https://i.loli.net/2020/05/15/5MA6BlNVL9Th1wx.png" alt="image.png"></p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>还是挺有趣的…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">MPI学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 19:50:15" itemprop="dateCreated datePublished" datetime="2020-05-10T19:50:15+08:00">2020-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MPI学习笔记2"><a href="#MPI学习笔记2" class="headerlink" title="MPI学习笔记2"></a>MPI学习笔记2</h1><h2 id="集合通信"><a href="#集合通信" class="headerlink" title="集合通信"></a>集合通信</h2><p>MPI_Send和MPI_Recv可以实现不同进程之间的通信，但如果要跟很多进程发消息，或者要接受很多进程发送的消息，这样就太过麻烦。为此，MPI提供了一系列称为集合通信的函数，它涉及通信子之间的所有进程的通信。</p>
<h3 id="MPI-Reduce"><a href="#MPI-Reduce" class="headerlink" title="MPI_Reduce"></a>MPI_Reduce</h3><p>MPI_Reduce用于实现高效的全局运算，如求和，求最大值等。原型如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce</span><span class="params">(<span class="keyword">void</span>* input_data_p,<span class="keyword">void</span>* output_data_p,<span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype datatype,MPI_Op <span class="keyword">operator</span>,<span class="keyword">int</span> dest_process,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于每个进程，我们调用MPI_Reduce，然后对目的进程，output_data_p指向的值会与每个进程的input_data_p指向的值进行运算。如果count参数的值大于1，则运算会在数组上进行。<br>支持的运算有:<br>|运算符值|含义|<br>|-|-|<br>|MPI_MAX|求最大值|<br>|MPI_MIN|求最小值|<br>|MPI_SUM|求累加和|<br>|MPI_PROD|求累乘值|<br>|MPI_LAND|逻辑与|<br>|MPI_BAND|按位与|<br>|MPI_LOR|逻辑或|<br>|MPI_BOR|按位或|<br>|MPI_LOR|逻辑异或|<br>|MPI_BOR|按位异或|<br>|MPI_MAXLOC|求最大值和最大值所在的位置|<br>|MPI_MINLOC|求最小值和最小值所在的位置|</p>
<p>一个示例程序如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> val=my_rank*my_rank,sum=<span class="number">0</span>;</span><br><span class="line">  MPI_Reduce(&amp;val,&amp;sum,<span class="number">1</span>,MPI_INT,MPI_SUM,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两点值得注意:<br>1.第一个参数和第二个参数的指针不能相同，否则会得到非法的结果。<br>2.对于不是目标进程的进程，第二个参数实际上是没有作用的，可以置为NULL。</p>
<h2 id="MPI-Allreduce"><a href="#MPI-Allreduce" class="headerlink" title="MPI_Allreduce"></a>MPI_Allreduce</h2><p>有时候，我们不仅需要全局运算，还需要把结果放到每个进程里，这时候可以调用MPI_Allreduce函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allreduce</span><span class="params">(<span class="keyword">void</span>* input_data_p,<span class="keyword">void</span>* output_data_p,<span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype datatype,MPI_OP <span class="keyword">operator</span>,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数的意义基本与MPI_Reduce相同，不再赘述。<br>用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> val=my_rank*my_rank,sum=<span class="number">0</span>;</span><br><span class="line">  MPI_Allreduce(&amp;val,&amp;sum,<span class="number">1</span>,MPI_INT,MPI_SUM,MPI_COMM_WORLD);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MPI-Bcast"><a href="#MPI-Bcast" class="headerlink" title="MPI_Bcast"></a>MPI_Bcast</h2><p>有时候，我们需要将一个进程里的数据发送到通信子中的所有进程，这是可以调用MPI_Bcast函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Bcast</span><span class="params">(<span class="keyword">void</span>* data_p,<span class="keyword">int</span> count,MPI_Datatype datatype,<span class="keyword">int</span> souce_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，data_p在发送进程里为输入参数，在其他进程里为输出参数，用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span>* s=<span class="string">"hello world!\n"</span>;</span><br><span class="line">    MPI_Bcast(s,<span class="built_in">strlen</span>(s)+<span class="number">1</span>,MPI_CHAR,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    MPI_Bcast(s,<span class="number">14</span>,MPI_CHAR,<span class="number">0</span>,MPI_COMM_WORLD);<span class="comment">//注意，这里s还是空字符串，不能用strlen确定长度。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In process %d,s is %s"</span>,my_rank,s);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MPI-Scatter"><a href="#MPI-Scatter" class="headerlink" title="MPI_Scatter"></a>MPI_Scatter</h3><p>假如在主进程里有一个长为100的数组，要把它分到10个进程里，其中0号进程分到前10个元素，1号进程分到第10个到第19个元素……这时可以调用MPI_Scatter函数来进行分发:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Scatter</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,<span class="keyword">int</span> recv_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype recv_type,<span class="keyword">int</span> src_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>假如数组大小为n，通信子里共有comm_sz个进程，则MPI_Scatter会把数组分为comm_xz份，每份有$local_n=\frac{n}{comm_xz}$个。此时send_count和recv_count应被置为local_n，因为send_count表示的是发送到每个进程的数据量，recv_count表示每个进程接收到的数据量。</p>
<p>一个示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span>* b=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n/comm_sz*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span>* a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Scatter(a,n/comm_sz,MPI_INT,b,n/comm_sz,MPI_INT,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Scatter(<span class="literal">NULL</span>,n/comm_sz,MPI_INT,b,n/comm_sz,MPI_INT,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/comm_sz;i++)<span class="built_in">printf</span>(<span class="string">"In process %d, b[%d]=%d\n"</span>,my_rank,i,b[i]);</span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，跟MPI_Reduce一样，MPI_Scatter的两个指针参数不能相同，而且非目的进程的send_buff_p可以是NULL。</p>
<h3 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a>MPI_Gather</h3><p>有了把数据发出去的方法，自然会有把数据收集起来的方法，它是MPI_Gather:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Gather</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> recv_count,MPI_Datatype recv_type,<span class="keyword">int</span> dest_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用法和注意事项 与MPI_Scatter差不多，不再赘述</p>
<h3 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a>MPI_Allgather</h3><p>MPI_Allgather与 MPI_Gather的关系有点类似MPI_allreduce与MPI_Reduce的关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Gather</span><span class="params">(<span class="keyword">void</span>* send_buf_p,<span class="keyword">int</span> send_count,MPI_Datatype send_type,<span class="keyword">void</span>* recv_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> recv_count,MPI_Datatype recv_type,<span class="keyword">int</span> dest_proc,MPI_Comm comm)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于将数据串联起来，存储到每个进程的recv_buf_p参数中。</p>
<h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><p>用上述集合通信的方法实现矩阵向量乘法的并行化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_rand</span><span class="params">(<span class="keyword">double</span>* vec,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)vec[i]=(<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mat_vec_mul2</span><span class="params">(<span class="keyword">double</span>* local_A,<span class="keyword">double</span>* x,<span class="keyword">double</span>* local_y,<span class="keyword">int</span> local_m,<span class="keyword">int</span> n,<span class="keyword">int</span> local_n,MPI_Comm comm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> local_i,j,local_ok=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(local_i=<span class="number">0</span>;local_i&lt;local_m;local_i++)&#123;</span><br><span class="line">    local_y[local_i]=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)local_y[local_i]+=local_A[local_i*n+j]*x[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> comm_sz,my_rank;</span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m,n,local_m,local_n;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">  <span class="built_in">sscanf</span>(argv[<span class="number">2</span>],<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  local_m=m/comm_sz,local_n=n/comm_sz;</span><br><span class="line">  <span class="keyword">double</span>* local_A,* local_x,* local_y;</span><br><span class="line">  local_A=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_m*n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  local_x=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  local_y=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(local_m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">double</span> *x=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* A=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*n*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">double</span>* y=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>)),*y2=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    my_rand(A,m*n),my_rand(x,n);</span><br><span class="line">    MPI_Scatter(A,local_m*n,MPI_DOUBLE,local_A,local_m*n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(x,n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    Mat_vec_mul2(local_A,x,local_y,local_m,n,local_n,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Gather(local_y,local_m,MPI_DOUBLE,y,local_m,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time: %d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line">    <span class="comment">//  for(int i=0;i&lt;m;i++)cout&lt;&lt;y[i]&lt;&lt;" "&lt;&lt;y2[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">free</span>(A),<span class="built_in">free</span>(y),<span class="built_in">free</span>(y2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Scatter(<span class="literal">NULL</span>,local_m*n,MPI_DOUBLE,local_A,local_m*n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(x,n,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    Mat_vec_mul2(local_A,x,local_y,local_m,n,local_n,MPI_COMM_WORLD);</span><br><span class="line">    MPI_Gather(local_y,local_m,MPI_DOUBLE,<span class="literal">NULL</span>,local_m,MPI_DOUBLE,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(local_A);<span class="built_in">free</span>(local_y);<span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个程序使用了多进程的方式进行了优化，但事实上运行时间远远大于串行的版本:</p>
<p>并行：<br><img src="https://i.loli.net/2020/04/18/m9ekwjVqoBa5Ylz.png" alt="image.png"></p>
<p>串行：<br><img src="https://i.loli.net/2020/04/18/G52aMcmoqxkrdhP.png" alt="image.png"></p>
<h2 id="MPI派生数据类型"><a href="#MPI派生数据类型" class="headerlink" title="MPI派生数据类型"></a>MPI派生数据类型</h2><p>显然，进程之间通信是非常非常慢的。如果主进程要往其他进程广播一个整数，两个浮点数，有没有方法能用一次通信的方法解决呢？<br>MPI为了解决这个问题，提供了用户自定义的派生数据类型。<br>我们可以用MPI_Type_create_struct函数创建由不同基本数据类型的元素所组成的派生数据类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Type_create_struct</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> array_of_clocklengths[],</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Aint array_of_displacements[],MPI_Datatype array_of_types[],MPI_Datatype* new_type_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数表明我们创建的数据类型有多少个元素；第二个参数表示每个元素是单个的数据还是一个数组；第三个参数表示每个元素相对于第一个元素的内存地址偏移量；第四个参数表示每个元素的类型；第5个参数表示创建的类型。</p>
<p>比如我们要创建一种数据类型，包含一个int，两个double，可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b,c;</span><br><span class="line">MPI_Aint a_addr,b_addr,c_addr;</span><br><span class="line">MPI_Get_address(&amp;a,&amp;a_addr);</span><br><span class="line">MPI_Get_address(&amp;b,&amp;b_addr);</span><br><span class="line">MPI_Get_address(&amp;c,&amp;c_addr);</span><br><span class="line">MPI_Aint array_of_displacements[<span class="number">3</span>]=&#123;<span class="number">0</span>,b_addr-a_addr,c_addr-a_addr&#125;;</span><br><span class="line"><span class="keyword">int</span> array_of_blocklengths[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">MPI_Datatype array_of_types[<span class="number">3</span>]=&#123;MPI_INT,MPI_DOUBLE,MPI_DOUBLE&#125;;</span><br><span class="line">MPI_Datatype <span class="keyword">input_mpi_t</span>;</span><br><span class="line">MPI_Type_create_struct(<span class="number">3</span>,array_of_blocklengths,array_of_displacements,array_of_types,&amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line">MPI_Type_commit(&amp;<span class="keyword">input_mpi_t</span>);</span><br></pre></td></tr></table></figure>

<p>MPI_Get_address()用于获得第一个指针参数的绝对地址，把这个地址赋值给第二个参数指向的地址空间。<br>再调用完MPI_Type_create_struct()函数之后，还需要调用MPI_Type_commit()函数向通信子提交这一数据类型。之后，就可以像使用普通数据类型一样使用input_mpi_t了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(my_rank==<span class="number">0</span>)&#123;</span><br><span class="line">    a=<span class="number">1</span>,b=<span class="number">1.1</span>,c=<span class="number">2.2</span>;</span><br><span class="line">    MPI_Bcast(&amp;a,<span class="number">1</span>,<span class="keyword">input_mpi_t</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    MPI_Bcast(&amp;a,<span class="number">1</span>,<span class="keyword">input_mpi_t</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In process %d: a=%d b=%f c=%f\n"</span>,my_rank,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">pytorch学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 00:19:35" itemprop="dateCreated datePublished" datetime="2020-04-22T00:19:35+08:00">2020-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tensor与Autograd详解"><a href="#Tensor与Autograd详解" class="headerlink" title="Tensor与Autograd详解"></a>Tensor与Autograd详解</h1><p>参考自《深度学习框架PyTorch入门与实践》</p>
<h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><h3 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h3><p>创建Tensor的方法有很多:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Tensor(*size)</td>
<td>基础构造函数</td>
</tr>
<tr>
<td>ones(*size)</td>
<td>全为 1 Tensor</td>
</tr>
<tr>
<td>zeros(*size)</td>
<td>全为 0 Tensor</td>
</tr>
<tr>
<td>eyes(*size)</td>
<td>对角线为1，其他为0</td>
</tr>
<tr>
<td>arange(s,e,step)</td>
<td>从s到e，步长为step</td>
</tr>
<tr>
<td>linspace(s,e,step)</td>
<td>从s到e，均分为step份</td>
</tr>
<tr>
<td>rand/randn(*sizes)</td>
<td>均匀/标准分布</td>
</tr>
<tr>
<td>normal(mean,std)/uniform(from,to)</td>
<td>正态分布/均匀分布</td>
</tr>
<tr>
<td>randperm(m)</td>
<td>随机排列</td>
</tr>
</tbody></table>
<p>用Tensor()函数创建tensor时，可以有很多方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=t.Tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])<span class="comment">#用一个list来创建</span></span><br><span class="line">y=t.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">z=t.Tensor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#用几个值来确定Tensor的维度</span></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(y.tolist())</span><br><span class="line">print(z)</span><br><span class="line">a=x</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/bh1INsQH2CDZJui.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">print(x.numel())</span><br><span class="line">y=t.Tensor(x.size())</span><br><span class="line">z=t.Tensor((<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#Tensor的元素是2和3</span></span><br><span class="line">a=t.Tensor(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#Tensor的大小是2*3</span></span><br><span class="line">y,z,a</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/FHmz64MwnYik3U1.png" alt="image.png"></p>
<p>tensor.shape和tensor.size()是一样的:<br><img src="https://i.loli.net/2020/04/21/t1bwdZcOvEFT3hV.png" alt="image.png"></p>
<p>一些其他的创建方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x=t.ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.zeros(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.arange(<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>)<span class="comment">#注意，第二个参数是取不到的</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.arange(<span class="number">1</span>,<span class="number">7.00000000000001</span>,<span class="number">2</span>)<span class="comment">#注意，第二个参数是取不到的</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.linspace(<span class="number">1</span>,<span class="number">10.7</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.randn(<span class="number">3</span>,<span class="number">3</span>)<span class="comment">#均值为0，方差为1的正态分布</span></span><br><span class="line">print(x)</span><br><span class="line">x=t.randperm(<span class="number">20</span>)</span><br><span class="line">print(x)</span><br><span class="line">x=t.eye(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/2IY1rnLE3aWm98i.png" alt="image.png"></p>
<h2 id="改变形状的操作"><a href="#改变形状的操作" class="headerlink" title="改变形状的操作"></a>改变形状的操作</h2><p>用 view()，squeeze(),unsqueeze(),resize_()等方法可以改变tensor的形状</p>
<h3 id="view"><a href="#view" class="headerlink" title="view()"></a>view()</h3><p>view()用于直接改变形状，但不能改变tensor的大小。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b=t.arange(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">print(b.view(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(b.view(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)) <span class="comment"># -1表示自动计算其大小</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/ErYxRC1MD7Pi5dF.png" alt="image.png"></p>
<h3 id="unsqueeze"><a href="#unsqueeze" class="headerlink" title="unsqueeze()"></a>unsqueeze()</h3><p>unsqueeze()用于增加tensor的维度。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(b)</span><br><span class="line">print(b.unsqueeze(<span class="number">1</span>))<span class="comment">#从 6 变成 6*1</span></span><br><span class="line">print(b.unsqueeze(<span class="number">-2</span>))<span class="comment">#-2 的意思是，增加的那个维度是增加了维度之后的tensor的倒数第二个维度。</span></span><br><span class="line"><span class="comment">#也就是说，从 6 增加成 1*6</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/rSDs8YauxeB5CFb.png" alt="image.png"></p>
<h3 id="squeeze"><a href="#squeeze" class="headerlink" title="squeeze()"></a>squeeze()</h3><p>squeeze()用于压缩大小为一的维度。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.Tensor(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">print(x.squeeze(<span class="number">0</span>))<span class="comment">#第0个维度大小是2，不能压缩</span></span><br><span class="line">print(x.squeeze())<span class="comment">#压缩所有大小为1的维度</span></span><br><span class="line">x.squeeze(<span class="number">2</span>)<span class="comment">#第二个维度大小是1，被压缩</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/s8hv6XkiAx1Ofc2.png" alt="image.png"></p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize_"></a>resize_</h3><p>resize_也可以用来修改形状。不同的是，如果新尺寸超过了原来的尺寸，会自动分配新的内存空间。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.resize_(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">x.resize_(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/Mf1PgbTLKvAqWl8.png" alt="image.png"></p>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>Tensor可以按下标索引:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=t.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a[<span class="number">0</span>])<span class="comment">#第0行</span></span><br><span class="line">print(a[:,<span class="number">2</span>])<span class="comment">#第2列</span></span><br><span class="line">print(a[<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#第1,2行和第2,3列的交叉</span></span><br><span class="line">print(a[:<span class="number">2</span>])<span class="comment">#前两行</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">2</span>])<span class="comment">#前两行</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">1</span>,:<span class="number">2</span>])<span class="comment">#第0行，前两列。形状是1*2</span></span><br><span class="line">print(a[<span class="number">0</span>,:<span class="number">2</span>])<span class="comment">#第0行，前两列。形状是2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/3M8SQftLEpv2UHA.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">print(a&gt;<span class="number">1</span>)</span><br><span class="line">print(a[a&gt;<span class="number">1</span>])<span class="comment">#形状不同</span></span><br><span class="line">print(a*(a&gt;<span class="number">1</span>))<span class="comment">#形状相同</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/93ay4eobRnSIPVs.png" alt="image.png"></p>
<h2 id="选择函数"><a href="#选择函数" class="headerlink" title="选择函数"></a>选择函数</h2><p>选择函数用于从Tensor中选出一部分。</p>
<h3 id="index-select"><a href="#index-select" class="headerlink" title="index_select()"></a>index_select()</h3><p>index_select()用于选出tensor特定维度特定下表的部分。用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.linspace(<span class="number">1</span>, <span class="number">12</span>, steps=<span class="number">12</span>).view(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = torch.index_select(a, <span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">2</span>]))<span class="comment">#0表示第0个维度，0,2表示这一维度下表为0和2的会被选出来。</span></span><br><span class="line">print(b)</span><br><span class="line">print(a.index_select(<span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">2</span>])))</span><br><span class="line">c = a.index_select(<span class="number">1</span>, torch.tensor([<span class="number">1</span>, <span class="number">3</span>]))<span class="comment">#1表示第一个维度</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/3qwKlU4OPgGTNLF.png" alt="image.png"></p>
<h3 id="mask-select"><a href="#mask-select" class="headerlink" title="mask_select()"></a>mask_select()</h3><p>a.mask_select(b)=a[b],没啥好用的</p>
<h3 id="nonzero"><a href="#nonzero" class="headerlink" title="nonzero()"></a>nonzero()</h3><p>用于获得非0元素的下标，用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=t.Tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">print(a.nonzero())</span><br><span class="line">a[a.nonzero()]</span><br></pre></td></tr></table></figure>

<h3 id="gather-和scatter"><a href="#gather-和scatter" class="headerlink" title="gather()和scatter()"></a>gather()和scatter()</h3><p>太复杂了，等用到的时候再搞。</p>
<h2 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h2><p>x[[],[]……[]] 其中第1个列表表示第0个维度要选的东西，第2个列表表示第1个维度要选的东西，以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.arange(<span class="number">0</span>,<span class="number">27</span>).view(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]])<span class="comment">#相当于x[1,1,2]和x[2,2,1]</span></span><br><span class="line">print(x[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>],[<span class="number">0</span>]])<span class="comment">#相当于x[1,0,0]和x[2,0,0]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/21/QqLorfhP7dNG5MU.png" alt="image.png"></p>
<h2 id="Tensor类型"><a href="#Tensor类型" class="headerlink" title="Tensor类型"></a>Tensor类型</h2><p>tensor的元素默认类型是FloatTensor,可以通过t.set_default_tensor_type()修改默认类型。</p>
<p>常见类型有:</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>CPU tensor</th>
<th>GPU tensor</th>
</tr>
</thead>
<tbody><tr>
<td>32bit浮点</td>
<td>torch.FloatTensor</td>
<td>torch.cuda.FloatTensor</td>
</tr>
<tr>
<td>64bit浮点</td>
<td>torch.DoubleTensor</td>
<td>torch.cuda.DoubleTensor</td>
</tr>
<tr>
<td>16bit浮点</td>
<td>16bit浮点只能在GPU里用</td>
<td>torch.cuda.HaltTensor</td>
</tr>
<tr>
<td>8bit无符号整型</td>
<td>torch.ByteTensor</td>
<td>torch.cuda.ByteTensor</td>
</tr>
<tr>
<td>8bit有符号整型</td>
<td>torch.CharTensor</td>
<td>torch.cuda.CharTensor</td>
</tr>
<tr>
<td>16bit有符号整型</td>
<td>torch.ShortTensor</td>
<td>torch.cuda.ShortTensor</td>
</tr>
<tr>
<td>32bit有符号整型</td>
<td>torch.IntTensor</td>
<td>torch.cuda.IntTensor</td>
</tr>
<tr>
<td>64bit有符号整型</td>
<td>torch.LongTensor</td>
<td>torch.cuda.LongTensor</td>
</tr>
</tbody></table>
<p>还可以用type()函数指定类型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t.set_default_tensor_type(<span class="string">"torch.FloatTensor"</span>)</span><br><span class="line">a=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">b=a.int()</span><br><span class="line">print(b)</span><br><span class="line">b=b.type(<span class="string">"torch.DoubleTensor"</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h2 id="逐元素操作"><a href="#逐元素操作" class="headerlink" title="逐元素操作"></a>逐元素操作</h2><p>这些函数会对tensor的每一个元素进行操作，如下表所示:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>abs/sqrt/div/exp/fmod/log/pow</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">pytorch学习笔记1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 10:53:51" itemprop="dateCreated datePublished" datetime="2020-04-21T10:53:51+08:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pytorch-快速入门"><a href="#pytorch-快速入门" class="headerlink" title="pytorch 快速入门"></a>pytorch 快速入门</h1><p>参考自《深度学习框架PyTorch入门与实践》</p>
<h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><p>Tensor是pytorch里最基础的数据结构，可以认为是一个高级数组。它可以包含一个数，一个一维数组，一个二维矩阵或更高维的数组。</p>
<h3 id="Tensor的创建"><a href="#Tensor的创建" class="headerlink" title="Tensor的创建"></a>Tensor的创建</h3><p>创建一个Tensor的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="keyword">as</span> t</span><br><span class="line">x=t.Tensor(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>这种情况下，会生成一个内容全为0的Tensor:<br><img src="https://i.loli.net/2020/04/19/WtVqcS1Re8uTBkY.png" alt="image.png"></p>
<p>随机生成Tensor的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>这样，Tensor里的每一个值都是一个0到1之间的随机数:<br><img src="https://i.loli.net/2020/04/19/VXACsqmWzt1eySY.png" alt="image.png"></p>
<p>用t.ones()能生成全为1的Tensor，用t.zeros()能生成全为0的Tensor:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=t.ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.zeros(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/S5RCF4BJg9xXPNn.png" alt="image.png"></p>
<p>得到Tensor的大小:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">x.size(<span class="number">0</span>),x.size(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/RtMaVJzdsASTm2W.png" alt="image.png"></p>
<h3 id="Tensor运算"><a href="#Tensor运算" class="headerlink" title="Tensor运算"></a>Tensor运算</h3><p>Tensor之间的运算可以用 ‘+’、’-‘、’*’、’/‘等符号实现，也可以用add,sub等函数实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(x+y)</span><br><span class="line">print(x.add(y))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/pHzPvm9Z23ngUxb.png" alt="image.png"></p>
<p>值得注意的是，add函数并不会修改x的值，要实现x+=y,要用add_()函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">y=t.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(x+y)</span><br><span class="line">print(x.add_(y))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/T5GEgdj9xseiNrC.png" alt="image.png"></p>
<h3 id="Tensor与numpy的关系"><a href="#Tensor与numpy的关系" class="headerlink" title="Tensor与numpy的关系"></a>Tensor与numpy的关系</h3><p>Tensor的很多操作跟numpy差不多，它们也可以互相转换:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.ones(<span class="number">3</span>)</span><br><span class="line">y=t.from_numpy(x)</span><br><span class="line">print(y)</span><br><span class="line">z=y.numpy()</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/sNmATBf4jkZvKor.png" alt="image.png"></p>
<p>值得注意的是，Tensor与nump对象的内存是共享的，因此其中一个改变的时候，另一个也会改变:<br><img src="https://i.loli.net/2020/04/19/ihVlkI1KHtDRNBb.png" alt="image.png"></p>
<h3 id="将Tensor转移到cuda上"><a href="#将Tensor转移到cuda上" class="headerlink" title="将Tensor转移到cuda上"></a>将Tensor转移到cuda上</h3><p>可以通过.cuda方法把Tensor转移到GPU上:<br><img src="https://i.loli.net/2020/04/19/ohkZBf2L4yNX7v1.png" alt="image.png"></p>
<h2 id="Autograd"><a href="#Autograd" class="headerlink" title="Autograd"></a>Autograd</h2><p>pytorch的Autograd模块提供了反向传播的功能。</p>
<p>autograd.Variable是Autograd中的核心类，它可以理解为Tensor的升级版。它的backward()方法能够自动计算梯度，提供了反向传播的功能。<br><img src="https://i.loli.net/2020/04/19/cjLrkSo37uFNYxd.png" alt="image.png"><br><img src="https://i.loli.net/2020/04/19/Nq4dSk1gPAbuyYa.png" alt="image.png"></p>
<p>由于y对x的每一个元素的偏导数都是1，所以x.grad是一个2*2的全为1的矩阵。<br>如果我们在调用一次y.backward(),会怎么样？<br><img src="https://i.loli.net/2020/04/19/LhJGUiXtSzNsVP5.png" alt="image.png"></p>
<p>我们发现grad在反向传播的过程中是累加的，所以我们要将grad清零:<br><img src="https://i.loli.net/2020/04/19/PFeDHjOtIfwJ4GM.png" alt="image.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>torch.nn是专门为神经网络设计的模块化接口，可以用来定义和运行神经网络。nn.Module是nn中最重要的类，可以看成是神经网络的封装。</p>
<h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><p>一个网络需要继承nn.Module，并实现它的forward方法，并把具有可学习参数的层放在构造函数<strong>init</strong>中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1=nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>)<span class="comment">#第一个参数是输入通道数，</span></span><br><span class="line">        <span class="comment">#第二个参数是输出通道数，第三个参数是卷积核的大小。</span></span><br><span class="line">        self.conv2=nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        self.fc1=nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>)</span><br><span class="line">        self.fc2=nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3=nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),<span class="number">2</span>)<span class="comment"># 这里的2跟(2,2)的效果是一样的</span></span><br><span class="line">        x=x.view(x.size()[<span class="number">0</span>],<span class="number">-1</span>)</span><br><span class="line">        x=F.relu(self.fc1(x))</span><br><span class="line">        x=F.relu(self.fc2(x))</span><br><span class="line">        x=self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net=Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/2BUZDOilLbWQK9z.png" alt="image.png"></p>
<p>只要实现了forward方法，backward方法就会被自动实现。<br>网络的可学习参数可以通过net.parameters()得到:<br><img src="https://i.loli.net/2020/04/19/jvrHShXGe5PJNa6.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/04/19/SaGqQTxindgX7Ls.png" alt="image.png"></p>
<p>forward函数的输入和输出都是Variable，因此在输入的时候要把Tensor变成Variable:<br><img src="https://i.loli.net/2020/04/19/6Sz2rVmIsYRKj7A.png" alt="image.png"></p>
<p>注意，input是一个4维的向量，其中第一维是batch的大小，神经网络的输入是一个batch，里面可以有很多张图像。第二维是图像的通道数。第三维第四维是图像的大小。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>nn里定义了很多损失函数，如MSELoss用来计算均方误差，CrossEntropyLoss用来计算交叉熵损失。<br><img src="https://i.loli.net/2020/04/19/zpnGxdiSQDK18bX.png" alt="image.png"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>torch.optim 中实现了很多优化方法，可以用它们来对网络的参数进行更新:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.01</span>)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output=net(input)</span><br><span class="line">loss=criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>

<h3 id="CIFAR-10-分类"><a href="#CIFAR-10-分类" class="headerlink" title="CIFAR-10 分类"></a>CIFAR-10 分类</h3><p>CIFAR-10是一个常用的彩色图片数据集，共有10个类别，每张图片的大小都是3<em>32</em>32。<br>我们利用torchvision提供的CIFAR-10数据集来训练一个神经网络，并让它对测试图片进行预测。</p>
<p>首先进行一些准备工作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">import</span> torchvision <span class="keyword">as</span> tv</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToPILImage</span><br><span class="line">show=ToPILImage()</span><br><span class="line"><span class="comment">#show用于将Tensor对象转化为图片，以便于观察结果</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>))])</span><br><span class="line"><span class="comment">#transform 用于对输入图像进行预处理</span></span><br><span class="line">trainset=tv.datasets.CIFAR10(root=<span class="string">'/home/cy/data/'</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">trainloader=t.utils.data.DataLoader(trainset,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#用trainloader加载训练数据，batch_size=4说明一个batch是4张图片,num_worker=2说明用两个线程</span></span><br><span class="line">testset=tv.datasets.CIFAR10(<span class="string">'/home/cy/data/'</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">testloader=t.utils.data.DataLoader(testset,batch_size=<span class="number">4</span>,shuffle=<span class="literal">False</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">classes=(<span class="string">'plane'</span>,<span class="string">'car'</span>,<span class="string">'bird'</span>,<span class="string">'cat'</span>,<span class="string">'deer'</span>,<span class="string">'dog'</span>,<span class="string">'frog'</span>,<span class="string">'horse'</span>,<span class="string">'ship'</span>,<span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>

<p>查看某一张照片:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(data,label)=trainset[<span class="number">100</span>]</span><br><span class="line">print(classes[label])</span><br><span class="line">show((data+<span class="number">1</span>)/<span class="number">2</span>).resize((<span class="number">100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/Z5s9chJX4d1YtxC.png" alt="image.png"></p>
<p>定义一个网络:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1=nn.Conv2d(<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)<span class="comment">#第一个参数是输入通道数，</span></span><br><span class="line">        <span class="comment">#第二个参数是输出通道数，第三个参数是卷积核的大小。</span></span><br><span class="line">        self.conv2=nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        self.fc1=nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>)</span><br><span class="line">        self.fc2=nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3=nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv2(x)),<span class="number">2</span>)<span class="comment"># 这里的2跟(2,2)的效果是一样的</span></span><br><span class="line">        x=x.view(x.size()[<span class="number">0</span>],<span class="number">-1</span>)</span><br><span class="line">        x=F.relu(self.fc1(x))</span><br><span class="line">        x=F.relu(self.fc2(x))</span><br><span class="line">        x=self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net=Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>

<p>定义一个损失函数和优化器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.001</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>开始训练:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    runnint_loss=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i,data <span class="keyword">in</span> enumerate(trainloader,<span class="number">0</span>):</span><br><span class="line">        inputs,labels=data</span><br><span class="line">        inputs,labels=Variable(inputs),Variable(labels)</span><br><span class="line">        <span class="comment">#注意要将输入数据转化成Variable类型，不然无法训练</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs=net(inputs)</span><br><span class="line">        loss=criterion(outputs,labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        runnint_loss+=loss.item()</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2000</span>==<span class="number">1999</span>:</span><br><span class="line">            print(<span class="string">"[%d,%5d] loss: %3f"</span>%(epoch+<span class="number">1</span>,i+<span class="number">1</span>,runnint_loss/<span class="number">2000</span>))</span><br><span class="line">            runnint_loss=<span class="number">0.0</span></span><br><span class="line">print(<span class="string">"Finish trainning"</span>)</span><br></pre></td></tr></table></figure>

<p>查看第一个batch的数据和标签:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataiter=iter(testloader)</span><br><span class="line">images,labels=dataiter.next()</span><br><span class="line">print(<span class="string">"实际的label:"</span>,<span class="string">" "</span>.join(<span class="string">"%08s"</span>%classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br><span class="line">show(tv.utils.make_grid(images/<span class="number">2</span><span class="number">-0.5</span>)).resize((<span class="number">400</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/19/eHPAQtow1Cqi8kM.png" alt="image.png"></p>
<p>查看它们的预测结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outputs=net(Variable(images))</span><br><span class="line">_,predicted=t.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"预测结果:"</span>,<span class="string">""</span>.join(<span class="string">"%8s"</span>%classes[predicted[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<p>查看总正确率:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">correct=<span class="number">0</span></span><br><span class="line">total=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">    images,labels=data</span><br><span class="line">    outputs=net(Variable(images))</span><br><span class="line">    _,predicted=t.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#output.data是一个数组，max返回两个值，第一个是最大值，第二个是最大值所在的位置</span></span><br><span class="line">    total+=labels.size(<span class="number">0</span>)</span><br><span class="line">    correct+=(predicted==labels).sum()</span><br><span class="line">    <span class="comment">#根据最大值所在的位置是否跟labels相等可以判断分类是否正确</span></span><br><span class="line">print(<span class="string">"正确率为:%d %%"</span>%(<span class="number">100</span>*correct/total))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">Pthread学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 10:29:25" itemprop="dateCreated datePublished" datetime="2020-04-21T10:29:25+08:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pthread学习笔记2"><a href="#Pthread学习笔记2" class="headerlink" title="Pthread学习笔记2"></a>Pthread学习笔记2</h1><h2 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h2><p>当多个线程同时修改同一个内存地址时，可能会出现奇奇怪怪的问题。我们根据下面的公式编写一个计算π的程序:<img src="https://i.loli.net/2020/04/21/dVu27OrsI835mlX.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %f\n"</span>,sum);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，当线程数大于1的时候会发现，程序输出的结果是不确定的，而且误差也较1个线程的情况大，甚至运行时间也是较长:<br><img src="https://i.loli.net/2020/04/20/A7KSVsQU3rCmfB9.png" alt="image.png"></p>
<p>这种情况被称为临界区问题，当0号线程把sum取到寄存器并执行运算的时候，1号进程也可能同时把sum取到寄存器，然后0号进程把结果写回内存，随后1号进程也把结果写回内存。这样就导致0号进程的计算结果被覆盖掉了，我们称</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样更新共享资源的语句为一个<strong>临界区</strong>。当多个线程尝试更新一个共享资源时，结果可能是无法预测的。更一般地，当多个线程都要访问共享变量或共享文件这样的共享资源时，如果有一个线程执行了更新操作，就可能产生错误，我们称之为<strong>竞争条件</strong>。</p>
<p>临界区问题可以用忙等待、互斥量和信号量等方法来解决。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>一种解决方法是设置一个标记变量，用于指明临界区可以被哪个线程执行，该执行完之后修改这个标记变量，而不能执行临界区的线程必须一直处于忙等待状态。<br>我们可以将代码修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">flag=(flag+<span class="number">1</span>)%thread_count;</span><br></pre></td></tr></table></figure>

<p>flag是我们说到的标记变量，当flag==当前线程号时，可以执行临界区，否则必须处于忙等待状态。执行完之后要修改flag。</p>
<p>运行结果如下:<br><img src="https://i.loli.net/2020/04/20/C9bXnD8ULhNYq5Q.png" alt="image.png"><br>可以看到，结果是正确了，但运行速度满了很多，甚至比单线程的情况还慢。</p>
<p>当然，由于临界区只能被串行执行，我们应该尽量减少临界区执行的次数，比如，我们可以把Thread_sum函数修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  flag=(flag+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个局部变量来代替sum变量，这样循环的过程中就不会有临界区。<br><img src="https://i.loli.net/2020/04/20/dwGW8O47tUgKjS9.png" alt="image.png"><br>运行结果正确，速度上也有提升。</p>
<p>使用忙等待还会有一个问题:</p>
<p>考虑一个最多可以同时执行2个线程的计算机，我们使用忙等待的方法编写一个5个线程的pthreads程序。假设开始时，操作系统运行0号线程和1号线程，这是没有问题的，此时2,3,4三个线程被挂起。然后假设0号线程运行结束，操作系统将其挂起，然后调度3号线程。由于操作系统的线程调度是随机的，它完全不知道此时只有2号线程能进入临界区，所以3号线程只能一直处于忙等待状态，浪费了时间。</p>
<p>所以，当线程数量大于计算机能同时运行的线程数时，使用忙等待的方法可能会产生问题。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>由于处于忙等待的线程会持续地占用CPU资源，所以忙等待并不是一个特别理想的解决临界区问题的方案。我们可以使用互斥量和信号量。</p>
<p>互斥量是互斥锁的简称，是一个特殊类型的变量，它可以保证每次只有一个线程能进入临界区。</p>
<p>互斥量的变量类型是pthread_mutex_t,必须调用 pthread_mutex_init()函数进行初始化。</p>
<p>当线程执行到临界区前面时，应该调用pthread_mutex_lock()函数。如果此时临界区已经被加了锁(即已经有其他线程执行到了这里)，则它会被卡在临界区外等待；否则它会进入临界区，并把临界区加锁。</p>
<p>当临界区被执行完，线程要用pthread_mutex_unlock函数把临界区解锁。此时，系统会从其他等待的线程选出一个进入临界区。如果有多个等待的线程，操作系统选择哪个线程是随机的的。</p>
<p>互斥量使用完之后要用pthread_mutex_destroy函数将其销毁。</p>
<p>互斥量的示例如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://i.loli.net/2020/04/20/NW65oQeM3yJRjTf.png" alt="image.png"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量(semaphore)可以认为是一种特殊类型的unsigned int，它的类型是sem_t。信号量可以赋值为0,1,……。大多数情况下，我们只用0和1两个值。这种只有0和1值的信号量也称为二元信号量。0对应上了锁的互斥量，1对应没上锁的互斥量。</p>
<p>初始化信号量的方法是调用sem_init(),它的原型是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中第二个参数直接置为0就可以了，第三个参数是初始值。</p>
<p>如果我们要用信号量来解决临界区问题，可以先创建一个全局信号量，初始值为1。在临界区前调用sem_wait()函数,这个函数的意义是:如果信号量为0则阻塞；如果是非0值则减1然后进入临界区。临界区执行完之后，调用sem_post()函数将信号量置为1。</p>
<p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;//注意要加这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">sem_t</span> my_semaphore;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sem_wait(&amp;my_semaphore);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %d\n"</span>,my_rank);</span><br><span class="line">  sem_post(&amp;my_semaphore);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  sem_init(&amp;my_semaphore,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用信号量还可以控制线程执行的顺序，如发送消息问题。我们可以给每个线程分配一个信号量，初始化为0，给每个线程一个char*，指向收到的消息。每一个线程把消息放到下一个线程后将下一个线程的信号量置为1，然后等待上一个线程的消息。代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MAX 100</span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">char</span>** messages;</span><br><span class="line"><span class="keyword">sem_t</span>* semaphores;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">long</span> dest=(my_rank+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">char</span>* my_msg=<span class="built_in">malloc</span>(MSG_MAX*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(my_msg,<span class="string">"Hello to %ld from %ld"</span>,dest,my_rank);</span><br><span class="line">  messages[dest]=my_msg;</span><br><span class="line">  sem_post(&amp;semaphores[dest]);</span><br><span class="line">  sem_wait(&amp;semaphores[my_rank]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %ld &gt; %s\n"</span>,my_rank,messages[my_rank]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">2</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  semaphores=(<span class="keyword">sem_t</span>*)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>));</span><br><span class="line">  messages=(<span class="keyword">char</span>**)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示:<br><img src="https://i.loli.net/2020/04/20/4KqbjiQeJC1RFW7.png" alt="image.png"></p>
<p>但如果我们把sem_wait那一行去掉，会出现这样的变化:<br><img src="https://i.loli.net/2020/04/21/rf15jbtTWmpuEoZ.png" alt="image.png"><br>第0号线程没有收到消息的时候就调用printf函数，自然就得不到想要的结果。</p>
<p>像上面这种一个线程需要等待另一个线程执行某种操作的同步方式，有时称为<strong>生产者-消费者同步模型</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reeeeeeeeeein</p>
  <div class="site-description" itemprop="description">SYSU 计算机专业大二在读</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reeeeeeeeeein</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>