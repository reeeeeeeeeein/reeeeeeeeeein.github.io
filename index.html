<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SYSU 计算机专业大二在读">
<meta property="og:type" content="website">
<meta property="og:title" content="reeeeeeeeeein的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="reeeeeeeeeein的博客">
<meta property="og:description" content="SYSU 计算机专业大二在读">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reeeeeeeeeein">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>reeeeeeeeeein的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
<div class="bg_content">
<canvas id="canvas"></canvas>
</div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">reeeeeeeeeein的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%94_%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%94_%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计算机网络实验五_文件传输实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 22:52:40" itemprop="dateCreated datePublished" datetime="2020-06-13T22:52:40+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件传输实验"><a href="#文件传输实验" class="headerlink" title="文件传输实验"></a>文件传输实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>学习利用套接字传送文件。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>WSL，gcc</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="写一个Ftp客户端程序，用FTP协议下载多个文件到指定目录"><a href="#写一个Ftp客户端程序，用FTP协议下载多个文件到指定目录" class="headerlink" title="写一个Ftp客户端程序，用FTP协议下载多个文件到指定目录"></a>写一个Ftp客户端程序，用FTP协议下载多个文件到指定目录</h3><p>把上次的mytelnet客户端稍作修改，让接受消息的线程在收到227 Entering Passive Mode(103,26,79,35,219,79). 这个消息后自动计算端口号，并绑定一个套接字，启动一个新的线程来接受文件内容。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN          20000                  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> File_Size          2000000                 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> host[<span class="number">50</span>];</span><br><span class="line">ofstream out;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">char</span>* buf)</span></span>&#123;</span><br><span class="line">  fgets(buf,BUFLEN,<span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">int</span> len=<span class="built_in">strlen</span>(buf);</span><br><span class="line">  buf[len<span class="number">-1</span>]=<span class="string">'\r'</span>,buf[len]=<span class="string">'\n'</span>,buf[++len]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">file_recv</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_sock=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">char</span>* buf=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>((File_Size)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">int</span> c1;</span><br><span class="line">  <span class="keyword">while</span>(c1=recv(my_sock,buf,File_Size,<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    out.write(buf,c1);</span><br><span class="line">  &#125;</span><br><span class="line">  out.close();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">client_recv</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_sock=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">char</span>* buf=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>((BUFLEN+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1=recv(my_sock,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">"227"</span>,<span class="number">3</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">char</span>* tem=buf;</span><br><span class="line">      <span class="keyword">while</span>(*tem!=<span class="string">')'</span>)tem++;</span><br><span class="line">      <span class="keyword">while</span>(*tem!=<span class="string">','</span>)tem--;</span><br><span class="line">      <span class="keyword">int</span> port1=strtol(tem+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">      tem--;</span><br><span class="line">      <span class="keyword">while</span>(*tem!=<span class="string">','</span>)tem--;</span><br><span class="line">      <span class="keyword">int</span> port2=strtol(tem+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">      port2=(port2&lt;&lt;<span class="number">8</span>)+port1;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;port2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>             <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">      <span class="keyword">char</span>    buf[BUFLEN+<span class="number">1</span>];              <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">      <span class="keyword">int</span>     sock;                       <span class="comment">/* socket descriptor            */</span></span><br><span class="line">      <span class="keyword">int</span>     cc;                         <span class="comment">/* recv character count         */</span></span><br><span class="line">      <span class="keyword">pthread_t</span> thread_handle2;</span><br><span class="line">      sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);   <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                          <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">      <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                      <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">      <span class="built_in">sin</span>.sin_family = AF_INET;                        <span class="comment">// 因特网地址簇</span></span><br><span class="line">      <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">      <span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">      <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)port2);         <span class="comment">// 设置服务器端口号</span></span><br><span class="line">      <span class="keyword">int</span> ret=connect(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line">      pthread_create(&amp;thread_handle2,<span class="literal">NULL</span>,file_recv,(<span class="keyword">void</span>*)sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">"221"</span>,<span class="number">3</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  out.open(argv[<span class="number">3</span>],ios::out);</span><br><span class="line">  <span class="built_in">strcpy</span>(host,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,host);</span><br><span class="line">  <span class="keyword">char</span>    *service = <span class="string">"21"</span>;        <span class="comment">/* server port to connect       */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>         <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">  <span class="keyword">char</span>    buf[BUFLEN+<span class="number">1</span>];          <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">  <span class="keyword">int</span>     sock;                   <span class="comment">/* socket descriptor            */</span></span><br><span class="line">  <span class="keyword">int</span>     cc;                     <span class="comment">/* recv character count         */</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">  sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                      <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                      <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                        <span class="comment">// 因特网地址簇</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line"><span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service));         <span class="comment">// 设置服务器端口号</span></span><br><span class="line">  <span class="keyword">int</span> ret=connect(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line">  pthread_create(&amp;thread_handle,<span class="literal">NULL</span>,client_recv,(<span class="keyword">void</span>*)sock);</span><br><span class="line">  <span class="keyword">char</span> tem[<span class="number">10</span>][<span class="number">100</span>]=&#123;<span class="string">"user net\r\n\0"</span>,<span class="string">"pass 123456\r\n\0"</span>,<span class="string">"pasv\r\n\0"</span>,<span class="string">""</span>,<span class="string">"quit\r\n\0"</span>&#125;;</span><br><span class="line">  <span class="built_in">sprintf</span>(tem[<span class="number">3</span>],<span class="string">"retr .%s\r\n\0"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,tem[i]);</span><br><span class="line">    <span class="keyword">int</span> c1=send(sock,tem[i],<span class="built_in">strlen</span>(tem[i]),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error !\n"</span>);</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;                          <span class="comment">// 关闭监听套接字</span></span><br><span class="line">  pthread_join(thread_handle,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">  getchar();                              <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行截屏及说明"><a href="#运行截屏及说明" class="headerlink" title="运行截屏及说明"></a>运行截屏及说明</h4><p>这个有点坑，一个是斜杠和反斜杠不能搞错，另一个是传大文件的时候要多recv几次，不然一次recv收不下来。<br>由于我是在wsl里完成的实验，因此命令行的最后一个参数用 /mnt/e 把文件放置在windows系统的e盘。<br><img src="https://i.loli.net/2020/06/13/5daU4Ao8g7Tfpei.png" alt="image.png"><br><img src="https://i.loli.net/2020/06/13/49E1uSgbnCUfPyF.png" alt="image.png"></p>
<h3 id="通过建立TCP连接实现一对一的聊天和传输文件功能"><a href="#通过建立TCP连接实现一对一的聊天和传输文件功能" class="headerlink" title="通过建立TCP连接实现一对一的聊天和传输文件功能"></a>通过建立TCP连接实现一对一的聊天和传输文件功能</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>在客户和服务器之间建立TCP连接之后，任何一方可以输入并执行命令：</p>
<p>rdir d:\test            设置接收文件的目录d:\test<br>chat hello              向对方发送聊天字符串“hello”或者 &gt;hello (非命令即可)<br>send c:\temp\ftp.pdf    向对方发送文件ftp.pdf，接收方对重名文件加编号。<br>quit                    退出程序</p>
<h4 id="数据包设计（仅作参考）"><a href="#数据包设计（仅作参考）" class="headerlink" title="数据包设计（仅作参考）"></a>数据包设计（仅作参考）</h4><p>一个包由三部分构成：结构1，结构2(多种类型)，数据。其中：结构1和结构2分别包含数据类型和数据长度。<br>在接收结构1之后，通过数据类型确定结构2，不同数据类型的结构2可以不同，再通过结构2中的数据长度接收数据。<br>接收结构和数据均要根据该结构或数据的长度接收。 要累计已接收的字节数，直到全部接收完毕，再接收下一部分。</p>
<h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><p>客户端：(p2pClient.cpp)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 20000 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_SIZE 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 300</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">char</span> dest_folder[<span class="number">100</span>]=<span class="string">"./new"</span>;</span><br><span class="line">ofstream out;</span><br><span class="line"><span class="keyword">sem_t</span> my_semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">300</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fileSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(<span class="keyword">char</span> *fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = fopen(fileName, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">size_t</span> size = ftell(fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getFileName</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* tem=pathName;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'\0'</span>)</span><br><span class="line">        tem++;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'/'</span> &amp;&amp; tem!=pathName)</span><br><span class="line">        tem--;</span><br><span class="line">    <span class="keyword">return</span> tem==pathName?tem:tem+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fgets(buf, BUFLEN, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    buf[len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unpack</span><span class="params">(struct FileStruct *fileStruct, <span class="keyword">char</span> *file_content, <span class="keyword">char</span> *folder_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Full_name[FILE_NAME_LEN];</span><br><span class="line">    <span class="built_in">sprintf</span>(Full_name, <span class="string">"%s/%s"</span>, folder_name, fileStruct-&gt;fileName);</span><br><span class="line">    <span class="comment">//  printf("%s\n",Full_name);</span></span><br><span class="line">    FILE *file = fopen(Full_name, <span class="string">"wb"</span>);</span><br><span class="line">    fwrite(file_content, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), fileStruct-&gt;fileSize, file);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_suffix</span><span class="params">(<span class="keyword">char</span> *new_filename, <span class="keyword">int</span> occur_time, <span class="keyword">char</span> *old_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tem = old_filename;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'\0'</span>)</span><br><span class="line">        tem++;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'.'</span> &amp;&amp; tem != old_filename)</span><br><span class="line">        tem--;</span><br><span class="line">    <span class="keyword">if</span> (tem != old_filename)</span><br><span class="line">    &#123;</span><br><span class="line">        *tem = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(new_filename, <span class="string">"%s(%d).%s"</span>, old_filename, occur_time, tem + <span class="number">1</span>);</span><br><span class="line">        *tem = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(new_filename, <span class="string">"%s(%d)"</span>, old_filename, occur_time);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">client_recv</span><span class="params">(<span class="keyword">void</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_sock = (<span class="keyword">long</span>)in;</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((BUFLEN + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = recv(my_sock, buf, BUFSIZ, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="number">-1</span> || c1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"接收消息错误!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 &lt;= <span class="number">300</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[c1] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"收到消息:\n%s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> file_name[FILE_NAME_LEN];</span><br><span class="line">            <span class="keyword">char</span> full_file_name[FILE_NAME_LEN];</span><br><span class="line">            <span class="built_in">memcpy</span>(file_name, buf, FILE_NAME_LEN);</span><br><span class="line"><span class="comment">//            printf("file name: %s",file_name);</span></span><br><span class="line">            sem_wait(&amp;my_semaphore);</span><br><span class="line">            <span class="keyword">if</span> (mp.count(<span class="built_in">string</span>(file_name)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> new_file_name[FILE_NAME_LEN];</span><br><span class="line">                add_suffix(new_file_name, mp[<span class="built_in">string</span>(file_name)], file_name);</span><br><span class="line">                <span class="built_in">strcpy</span>(file_name, new_file_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(full_file_name, <span class="string">"%s/%s"</span>, dest_folder, file_name);</span><br><span class="line">            mp[<span class="built_in">string</span>(file_name)]++;</span><br><span class="line">            sem_post(&amp;my_semaphore);</span><br><span class="line">            out.open(full_file_name, ios::out);</span><br><span class="line"></span><br><span class="line">            out.write(buf + <span class="keyword">sizeof</span>(FileStruct), <span class="built_in">strlen</span>(buf + <span class="keyword">sizeof</span>(FileStruct)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件已经被写入到 %s!\n"</span>, full_file_name);</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//    printf("%s", host);</span></span><br><span class="line">    <span class="keyword">char</span> *service = argv[<span class="number">2</span>]; <span class="comment">/* server port to connect       */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>  <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN + <span class="number">1</span>];    <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">    <span class="keyword">int</span> sock;                <span class="comment">/* socket descriptor            */</span></span><br><span class="line">    <span class="keyword">int</span> cc;                  <span class="comment">/* recv character count         */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">    <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;     <span class="comment">// 因特网地址簇</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    <span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service));           <span class="comment">// 设置服务器端口号</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line"></span><br><span class="line">    sem_init(&amp;my_semaphore, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thread_handle, <span class="literal">NULL</span>, client_recv, (<span class="keyword">void</span> *)sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input(buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">"&gt;quit"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出成功!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;chat"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            send(sock, buf + <span class="number">6</span>, <span class="built_in">strlen</span>(buf + <span class="number">6</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"消息发送成功!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;send"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            struct FileStruct f;</span><br><span class="line">            f.fileSize = getFileSize(buf + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span>(f.fileSize==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error file name!\n"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(f.fileName, getFileName(buf + <span class="number">6</span>));</span><br><span class="line">            <span class="keyword">char</span> *File_pack = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FILE_SIZE);</span><br><span class="line">            <span class="built_in">memcpy</span>(File_pack, &amp;f, <span class="keyword">sizeof</span>(FileStruct));</span><br><span class="line">            FILE *tem_file = fopen(buf + <span class="number">6</span>, <span class="string">"r"</span>);</span><br><span class="line">            <span class="keyword">char</span> *content = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(f.fileSize);</span><br><span class="line">            fread(content, f.fileSize, <span class="number">1</span>, tem_file);</span><br><span class="line">            fclose(tem_file);</span><br><span class="line">            <span class="built_in">memcpy</span>(File_pack + <span class="keyword">sizeof</span>(FileStruct), content, f.fileSize);</span><br><span class="line">            send(sock, File_pack, <span class="keyword">sizeof</span>(FileStruct) + f.fileSize, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件发送成功!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;rdir"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(&amp;my_semaphore);</span><br><span class="line">            <span class="built_in">strcpy</span>(dest_folder, buf + <span class="number">6</span>);</span><br><span class="line">            mp.clear();</span><br><span class="line">            sem_post(&amp;my_semaphore);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件夹路径已被修改!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(thread_handle, <span class="literal">NULL</span>);</span><br><span class="line">    close(sock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">    getchar(); <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 20000 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_SIZE 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 300</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">char</span> dest_folder[<span class="number">100</span>]=<span class="string">"./new"</span>;</span><br><span class="line">ofstream out;</span><br><span class="line"><span class="keyword">sem_t</span> my_semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">300</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fileSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(<span class="keyword">char</span> *fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = fopen(fileName, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">size_t</span> size = ftell(fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getFileName</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* tem=pathName;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'\0'</span>)</span><br><span class="line">        tem++;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'/'</span> &amp;&amp; tem!=pathName)</span><br><span class="line">        tem--;</span><br><span class="line">    <span class="keyword">return</span> tem==pathName?tem:tem+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fgets(buf, BUFLEN, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    buf[len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unpack</span><span class="params">(struct FileStruct *fileStruct, <span class="keyword">char</span> *file_content, <span class="keyword">char</span> *folder_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Full_name[FILE_NAME_LEN];</span><br><span class="line">    <span class="built_in">sprintf</span>(Full_name, <span class="string">"%s/%s"</span>, folder_name, fileStruct-&gt;fileName);</span><br><span class="line">    <span class="comment">//  printf("%s\n",Full_name);</span></span><br><span class="line">    FILE *file = fopen(Full_name, <span class="string">"wb"</span>);</span><br><span class="line">    fwrite(file_content, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), fileStruct-&gt;fileSize, file);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_suffix</span><span class="params">(<span class="keyword">char</span> *new_filename, <span class="keyword">int</span> occur_time, <span class="keyword">char</span> *old_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tem = old_filename;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'\0'</span>)</span><br><span class="line">        tem++;</span><br><span class="line">    <span class="keyword">while</span> (*tem != <span class="string">'.'</span> &amp;&amp; tem != old_filename)</span><br><span class="line">        tem--;</span><br><span class="line">    <span class="keyword">if</span> (tem != old_filename)</span><br><span class="line">    &#123;</span><br><span class="line">        *tem = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(new_filename, <span class="string">"%s(%d).%s"</span>, old_filename, occur_time, tem + <span class="number">1</span>);</span><br><span class="line">        *tem = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(new_filename, <span class="string">"%s(%d)"</span>, old_filename, occur_time);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">client_recv</span><span class="params">(<span class="keyword">void</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_sock = (<span class="keyword">long</span>)in;</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((BUFLEN + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = recv(my_sock, buf, BUFSIZ, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="number">-1</span> || c1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"接收消息错误!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 &lt;= <span class="number">300</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[c1] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"收到消息:\n%s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> file_name[FILE_NAME_LEN];</span><br><span class="line">            <span class="keyword">char</span> full_file_name[FILE_NAME_LEN];</span><br><span class="line">            <span class="built_in">memcpy</span>(file_name, buf, FILE_NAME_LEN);</span><br><span class="line"><span class="comment">//            printf("file name: %s",file_name);</span></span><br><span class="line">            sem_wait(&amp;my_semaphore);</span><br><span class="line">            <span class="keyword">if</span> (mp.count(<span class="built_in">string</span>(file_name)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> new_file_name[FILE_NAME_LEN];</span><br><span class="line">                add_suffix(new_file_name, mp[<span class="built_in">string</span>(file_name)], file_name);</span><br><span class="line">                <span class="built_in">strcpy</span>(file_name, new_file_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(full_file_name, <span class="string">"%s/%s"</span>, dest_folder, file_name);</span><br><span class="line">            mp[<span class="built_in">string</span>(file_name)]++;</span><br><span class="line">            sem_post(&amp;my_semaphore);</span><br><span class="line">            out.open(full_file_name, ios::out);</span><br><span class="line"></span><br><span class="line">            out.write(buf + <span class="keyword">sizeof</span>(FileStruct), <span class="built_in">strlen</span>(buf + <span class="keyword">sizeof</span>(FileStruct)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件已经被写入到 %s!\n"</span>, full_file_name);</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">   <span class="comment">// printf("%s", host);</span></span><br><span class="line">    <span class="keyword">char</span> *service = <span class="string">"50500"</span>;      <span class="comment">/* server port to connect       */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>, <span class="title">fsin</span>;</span> <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN + <span class="number">1</span>];         <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">    <span class="keyword">int</span> sock, ssock, alen;        <span class="comment">/* socket descriptor            */</span></span><br><span class="line">    <span class="keyword">int</span> cc;                       <span class="comment">/* recv character count         */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">    <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;     <span class="comment">// 因特网地址簇</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    <span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service)); <span class="comment">// 设置服务器端口号</span></span><br><span class="line"></span><br><span class="line">    bind(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 绑定监听的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">    listen(sock, <span class="number">5</span>); <span class="comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span></span><br><span class="line"></span><br><span class="line">    ssock = accept(sock, (struct sockaddr *)&amp;fsin, (<span class="keyword">socklen_t</span> *)&amp;alen); <span class="comment">// 如果在连接请求队列中有连接请求，则接受连接请求并建立连接，返回该连接的套接字，否则，本语句被阻塞直到队列非空。fsin包含客户端IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">    sem_init(&amp;my_semaphore, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thread_handle, <span class="literal">NULL</span>, client_recv, (<span class="keyword">void</span> *)ssock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input(buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">"&gt;quit"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出成功!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;chat"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            send(ssock, buf + <span class="number">6</span>, <span class="built_in">strlen</span>(buf + <span class="number">6</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"消息发送成功!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;send"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            struct FileStruct f;</span><br><span class="line">            f.fileSize = getFileSize(buf + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span>(f.fileSize==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"文件名错误!\n"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(f.fileName, getFileName(buf + <span class="number">6</span>));</span><br><span class="line">            <span class="keyword">char</span> *File_pack = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FILE_SIZE);</span><br><span class="line">            <span class="built_in">memcpy</span>(File_pack, &amp;f, <span class="keyword">sizeof</span>(FileStruct));</span><br><span class="line">            FILE *tem_file = fopen(buf + <span class="number">6</span>, <span class="string">"r"</span>);</span><br><span class="line">            <span class="keyword">char</span> *content = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(f.fileSize);</span><br><span class="line">            fread(content, f.fileSize, <span class="number">1</span>, tem_file);</span><br><span class="line">            fclose(tem_file);</span><br><span class="line">            <span class="built_in">memcpy</span>(File_pack + <span class="keyword">sizeof</span>(FileStruct), content, f.fileSize);</span><br><span class="line">            send(ssock, File_pack, <span class="keyword">sizeof</span>(FileStruct) + f.fileSize, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件发送成功!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"&gt;rdir"</span>, buf, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(&amp;my_semaphore);</span><br><span class="line">            <span class="built_in">strcpy</span>(dest_folder, buf + <span class="number">6</span>);</span><br><span class="line">            mp.clear();</span><br><span class="line">            sem_post(&amp;my_semaphore);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件夹路径已被修改!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(thread_handle, <span class="literal">NULL</span>);</span><br><span class="line">    close(sock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">    getchar(); <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务器运行截屏"><a href="#服务器运行截屏" class="headerlink" title="服务器运行截屏"></a>服务器运行截屏</h4><p><img src="https://i.loli.net/2020/06/13/1txqygFRInASXGC.png" alt="image.png"><br>可以看到文件确实被写入到e盘了。<br><img src="https://i.loli.net/2020/06/13/2pLw8JSBtGHMnci.png" alt="image.png"></p>
<h4 id="客户端运行截屏"><a href="#客户端运行截屏" class="headerlink" title="客户端运行截屏"></a>客户端运行截屏</h4><p> <img src="https://i.loli.net/2020/06/13/daP5Z6nM7rxFfiC.png" alt="image.png"></p>
<h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>遇到的最大问题可能还是对套接字程序设计不够熟悉，有些函数只能照着之前的模板来用，导致程序里的很多代码都是复制粘贴的。还有就是ftp协议的send和recv是有点坑，服务器发送的消息长度比较短，对于大的文件一次传不完。<br>总的来说这次实验不是很难，掌握了原理之后完成起来比较简单。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B_%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B_%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">操作系统实验四_中断控制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 18:20:29" itemprop="dateCreated datePublished" datetime="2020-06-13T18:20:29+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验报告"><a href="#操作系统实验报告" class="headerlink" title="操作系统实验报告"></a>操作系统实验报告</h1><p>[toc]</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1、PC系统的中断机制和原理</p>
<p>2、理解操作系统内核对异步事件的处理方法</p>
<p>3、掌握中断处理编程的方法</p>
<p>4、掌握内核中断处理代码组织的设计方法</p>
<p>5、了解查询式I/O控制方式的编程方法</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1、知道PC系统的中断硬件系统的原理</p>
<p>2、掌握x86汇编语言对时钟中断的响应处理编程方法</p>
<p>3、重写和扩展实验三的的内核程序，增加时钟中断的响应处理和键盘中断响应。</p>
<p>4、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>Windows 10</li>
<li>WSL （Windows Subsystem for Linux） [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。</li>
<li>gcc version 7.5.0：C 语言程序编译器，Ubuntu 自带。</li>
<li>ld  version 2.3.0:  链接器，Ubuntu自带</li>
<li>NASM version 2.13.02：汇编程序编译器，通过<code>sudo apt install nasm</code>安装在 WSL 上。</li>
<li>Oracle VM VirtualBox ：轻量开源的虚拟机软件，安装在Windows下。</li>
<li>VSCode - Insiders v1.33.0：好用的文本编辑器，有丰富的插件，可以用它来打开WSL中的文件夹，用它自带的终端执行make命令。</li>
<li>GNU Make 4.1：安装在 Ubuntu 下，一键编译并连接代码，生成最终的文件。</li>
<li>Bochs 2.1.1：安装在Windows下，用于调试代码。</li>
</ul>
<h3 id="自制工具"><a href="#自制工具" class="headerlink" title="自制工具"></a>自制工具</h3><p>​由于我的虚拟机和Bochs都安装在Windows下，所以需要将WSL中生成的文件写入至Windows的磁盘，这可以用我编写的工具 do 来解决，只需要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;do 文件名 写入的扇区</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​由于<a href="https://reeeeeeeeeein.github.io/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">上次实验</a>已经写好了操作系统内核，这次只用在里面修改即可。首先学习x86中断系统，明白时钟中断的原理，然后用时间中断实现”风火轮“，用一个其他中断实现用户程序敲击键盘显示’OUCH!OUCH!’的功能。</p>
<h3 id="设置中断入口点"><a href="#设置中断入口点" class="headerlink" title="设置中断入口点"></a>设置中断入口点</h3><p>​为了方便地使用中断，可以编写一个中断服务程序，再修改中断号对应的中断向量表。修改中断向量表的操作对不同中断是相似的，只是中断号和中断服务程序的地址不同而已，我们把这部分内容写成一个宏，放置在entry.asm里，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%macro set_ivt 2</span><br><span class="line">;第一个参数表示第几号中断，第二个参数表示中断服务程序的位置</span><br><span class="line">push ax</span><br><span class="line">push es</span><br><span class="line">push bx</span><br><span class="line">push si</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">xor ax,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ax,%1</span><br><span class="line">mov bx,4</span><br><span class="line">xor dx,dx</span><br><span class="line">mul bx;中断号*4后得到中断向量表中对应的地址</span><br><span class="line">mov si,ax</span><br><span class="line">xor dx,dx</span><br><span class="line">mov ax,%2</span><br><span class="line">mov bx,16;把位置除以16，得到偏移量和段地址</span><br><span class="line">div bx</span><br><span class="line">mov word [es:si],dx;前两个字节放偏移量</span><br><span class="line">mov word [es:si+2],ax;后两个字节放段地址</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop si</span><br><span class="line">pop bx</span><br><span class="line">pop es</span><br><span class="line">pop ax</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure>

<h3 id="编写时钟中断"><a href="#编写时钟中断" class="headerlink" title="编写时钟中断"></a>编写时钟中断</h3><p>​x86系统会自动产生时钟中断，为了实现’’风火轮’的效果，我们可以修改中断向量表中0x08号中断对应的内容，让它指向我们编写的中断服务程序。中断服务程序很简单，只用在内存中放置一个变量表示当前是显示’-‘、’\‘还是’/‘即可。但值得注意的是开始时要关中断，返回前要开中断，且要加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 0x1c</span><br><span class="line">mov al,20h</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>

<p>​这几行代码，没有这些代码会出现莫名其妙的错误，一直找不到原因。</p>
<p>​写完之后，在内核入口处加上一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_ivt 8h,_int_8h</span><br></pre></td></tr></table></figure>

<p>​就可以修改中断向量表了。</p>
<h3 id="编写-33号中断"><a href="#编写-33号中断" class="headerlink" title="编写 33号中断"></a>编写 33号中断</h3><p>​编写33号中断以实现在屏幕下方显示”OUCH!OUCH!”的功能，然后在用户程序中每次敲击键盘时调用33号中断。判断用户是否敲击键盘，只用调用0x16号中断即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 16h</span><br><span class="line">jz do</span><br><span class="line">int 33</span><br></pre></td></tr></table></figure>

<p>同样，写完之后加上一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_ivt 33,_int_33</span><br></pre></td></tr></table></figure>

<p>​就可以运行了。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>​编写一个makefile文件，然后就可以在VSCode自带的终端里输入make完成大量的工作。这次的makefile与上次没有任何区别，不再赘述。</p>
<p>​用bochs运行,可以看到风火轮的效果：<br><img src="https://i.loli.net/2020/06/12/FhemI2Kxtn9Du7c.png" alt="image-20200529153811786.png"></p>
<p><img src="https://i.loli.net/2020/06/12/B2jz3rXtkOyVm6Q.png" alt="image-20200529153848248.png"></p>
<p>​进入用户程序，敲击键盘：</p>
<p><img src="https://i.loli.net/2020/06/12/pKMRmZtx73rEOhP.png" alt="image-20200529153920257.png"></p>
<p>​可以看到显示了 ‘OUCH!OUCH!’，并且风火轮还在转动。</p>
<p>​提交的文件夹中还附带了一个录屏视频，可以查看。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​在完成这次实验过程中遇到的主要困难有：</p>
<ol>
<li><p>编写完0x08号中断后，操作系统运行的时候经常莫名其妙地卡住，无法正常运行。找了半天我也没想明白问题出在哪。于是我只好把BIOS的0x08号中断 “扣” 出来，然后在它上面进行修改，然后就能正常运行了。</p>
</li>
<li><p>本来是打算在显示 “OUCH!OUCH!” 的时候顺便显示系统的时间的，但BOCHS的时间系统似乎比正常的要快很多，导致完全无法显示正常的时间，而用Virtual Box又无法正常执行，于是只能把那一段代码删掉。</p>
<p>​总的来说，这次实验算比较简单了，只需要将原有的操作系统内核稍作修改即可。但又十分重要，毕竟操作系统的很多内容都要靠时钟中断来完成。我对这些内容掌握的还不够扎实，以后还要加强。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E5%9B%9B_%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E5%9B%9B_%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计算机网络实验四_文件打包实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 18:17:49" itemprop="dateCreated datePublished" datetime="2020-06-13T18:17:49+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件打包实验"><a href="#文件打包实验" class="headerlink" title="文件打包实验"></a>文件打包实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握文件打包的方法</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>C语言字符串函数：<a href="http://msdn.microsoft.com/zh-cn/library/f0151s4x(v=vs.110).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/library/f0151s4x(v=vs.110).aspx</a><br>C语言程序设计：<a href="http://www.runoob.com/cprogramming/" target="_blank" rel="noopener">http://www.runoob.com/cprogramming/</a><br>C语言函数分类：<a href="http://msdn.microsoft.com/zh-cn/library/2aza74he(v=vs.110).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/library/2aza74he(v=vs.110).aspx</a></p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>WSL+ gcc</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="把输入的结构数据保存到文件中"><a href="#把输入的结构数据保存到文件中" class="headerlink" title="把输入的结构数据保存到文件中"></a>把输入的结构数据保存到文件中</h3><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>循环输入员工(Person)的信息，每输入一个员工的信息，立即写入文件(Persons.stru)，直到输入的姓名为exit时跳出循环。<br>Person的信息表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> username[USER_NAME_LEN];      <span class="comment">// 员工名</span></span><br><span class="line">   <span class="keyword">int</span> level;                         <span class="comment">// 工资级别</span></span><br><span class="line">   <span class="keyword">char</span> email[EMAIL_LEN];             <span class="comment">// email地址</span></span><br><span class="line">   DWORD sendtime;                    <span class="comment">// 发送时间</span></span><br><span class="line">   <span class="keyword">time_t</span> regtime;                    <span class="comment">// 注册时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="完成后截屏运行结果"><a href="#完成后截屏运行结果" class="headerlink" title="完成后截屏运行结果"></a>完成后截屏运行结果</h4><p><img src="https://i.loli.net/2020/06/13/kaM6TqbwDrl2i8K.png" alt="image.png"></p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_NAME_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMAIL_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_BUF_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_BUF_LEN 300</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> userName[USER_NAME_LEN];</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line">  <span class="keyword">char</span> email[EMAIL_LEN];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sendtime;</span><br><span class="line">  <span class="keyword">time_t</span> regtime;</span><br><span class="line">&#125;person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> text_buf[BUF_LEN];</span><br><span class="line"><span class="keyword">int</span> level_buf;</span><br><span class="line"><span class="keyword">char</span> pts[TIME_BUF_LEN];</span><br><span class="line"><span class="keyword">time_t</span> now;</span><br><span class="line"><span class="keyword">char</span> person_buf[PERSON_BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  FILE* file=fopen(<span class="string">"Person.txt"</span>,<span class="string">"wb"</span>);</span><br><span class="line">  <span class="keyword">if</span>(file==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File open error!\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,text_buf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"exit"</span>,text_buf)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Exit input!\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strncpy</span>(person.userName,text_buf,USER_NAME_LEN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"level:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;level_buf);</span><br><span class="line">    person.level=level_buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"email:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,text_buf);</span><br><span class="line">    <span class="built_in">strncpy</span>(person.email,text_buf,EMAIL_LEN);</span><br><span class="line">    time(&amp;now);</span><br><span class="line">    person.sendtime=(<span class="keyword">long</span> <span class="keyword">long</span>)now;</span><br><span class="line">    person.regtime=now;</span><br><span class="line">    <span class="built_in">memcpy</span>(person_buf,&amp;person,<span class="keyword">sizeof</span>(struct Person));</span><br><span class="line">    <span class="keyword">if</span>(fwrite(person_buf,PERSON_BUF_LEN,<span class="number">1</span>,file)!=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Write file error!\n"</span>);</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从文件读出结构数据并显示出来"><a href="#从文件读出结构数据并显示出来" class="headerlink" title="从文件读出结构数据并显示出来"></a>从文件读出结构数据并显示出来</h3><h4 id="完成后截屏运行结果-1"><a href="#完成后截屏运行结果-1" class="headerlink" title="完成后截屏运行结果"></a>完成后截屏运行结果</h4><p><img src="https://i.loli.net/2020/06/13/FNUq791M6cytlPu.png" alt="image.png"></p>
<h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_NAME_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMAIL_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_BUF_LEN 300</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> userName[USER_NAME_LEN];</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line">  <span class="keyword">char</span> email[EMAIL_LEN];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sendtime;</span><br><span class="line">  <span class="keyword">time_t</span> regtime;</span><br><span class="line">&#125;person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> person_buf[PERSON_BUF_LEN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  FILE* file2=fopen(<span class="string">"Person.txt"</span>,<span class="string">"rb"</span>);</span><br><span class="line">  <span class="keyword">while</span>(fread(person_buf,PERSON_BUF_LEN,<span class="number">1</span>,file2)!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//    printf("%s",person_buf);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;person,person_buf,PERSON_BUF_LEN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"姓名:%s  级别:%d  电子邮件:%s  发送时间%s  注册时间%s\n"</span>,person.userName,person.level,person.email,ctime(&amp;person.sendtime),ctime(&amp;person.regtime));</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打包文件-FilePack-c"><a href="#打包文件-FilePack-c" class="headerlink" title="打包文件 (FilePack.c)"></a>打包文件 (FilePack.c)</h3><h4 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h4><p>(1) 先输入打包文件名（含路径）；<br>(2) 循环输入要打包的文件名（含路径），每输入一个，就把该文件的文件名（最多300字节）、文件大小(long)和文件内容写入文件FileSet.pak中，当输入文件名为exit时跳出循环。<br>当前文件夹下有FilePack和FilePack.c等多个文件<br><img src="https://i.loli.net/2020/06/13/GM4pROQSgc5djvn.png" alt="image.png"></p>
<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p><img src="https://i.loli.net/2020/06/13/EtCqsHoPmU91iyQ.png" alt="image.png"><br>生成的dest文件：<br><img src="https://i.loli.net/2020/06/13/owWin5OECPtcKRq.png" alt="image.png"></p>
<h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_BUF_LEN 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 300</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> fileName[<span class="number">300</span>];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> fileSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(<span class="keyword">char</span> * fileName)</span></span>&#123;</span><br><span class="line">  FILE* fp=fopen(fileName,<span class="string">"r"</span>);</span><br><span class="line">  fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span> = ftell(fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getFileName</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(*pathName!=<span class="string">'\0'</span>)pathName++;</span><br><span class="line">  <span class="keyword">while</span>(*pathName!=<span class="string">'/'</span>)pathName--;</span><br><span class="line">  <span class="keyword">return</span> pathName+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> text_buf[BUF_LEN];</span><br><span class="line"><span class="keyword">time_t</span> now;</span><br><span class="line"><span class="keyword">char</span> person_buf[PERSON_BUF_LEN];</span><br><span class="line"><span class="keyword">char</span> file_NAME[FILE_NAME_LEN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"输入要目标文件名（含路径）："</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,text_buf);</span><br><span class="line">  FILE* file3=fopen(text_buf,<span class="string">"wb"</span>);</span><br><span class="line">  <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    now++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入要打包的#%d文件（含路径）："</span>,now);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,text_buf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(text_buf,<span class="string">"exit"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"打包结束！\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span> <span class="title">f</span>;</span></span><br><span class="line">    f.fileSize=getFileSize(text_buf);</span><br><span class="line">    <span class="built_in">strcpy</span>(f.fileName,getFileName(text_buf));</span><br><span class="line">    <span class="keyword">int</span> a=fwrite(&amp;f,<span class="keyword">sizeof</span>(struct FileStruct),<span class="number">1</span>,file3);</span><br><span class="line">    FILE* tem_file=fopen(text_buf,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">char</span>* content=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(f.fileSize);</span><br><span class="line">    fread(content,f.fileSize,<span class="number">1</span>,tem_file);</span><br><span class="line">    fclose(tem_file);</span><br><span class="line">    fwrite(content,f.fileSize,<span class="number">1</span>,file3);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解包文件-FileUnpack-c"><a href="#解包文件-FileUnpack-c" class="headerlink" title="解包文件 (FileUnpack.c)"></a>解包文件 (FileUnpack.c)</h3><h4 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h4><p>(1)输入解包路径<br>(2)输入打包文件名，然后解包其中每一个文件,有重名文件时文件名加上序号（从2开始）。</p>
<p>先把几个文件打包进dest文件中，然后解包.</p>
<p>运行结果：<br><img src="https://i.loli.net/2020/06/13/UCjz28hKyHmlagR.png" alt="image.png"><br>new文件夹的内容变为：<br><img src="https://i.loli.net/2020/06/13/PEgrhOMU2NFCVBu.png" alt="image.png"></p>
<p>五个文件均可打开，显示内容正常，字节数与源文件相同：<br><img src="https://i.loli.net/2020/06/13/spHRybxaojB6feG.png" alt="image.png"></p>
<h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_BUF_LEN 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 300</span></span><br><span class="line"><span class="comment">//#define FILE_CONTENT_LEN 100000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> fileName[<span class="number">300</span>];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> fileSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(<span class="keyword">char</span> * fileName)</span></span>&#123;</span><br><span class="line">  FILE* fp=fopen(fileName,<span class="string">"r"</span>);</span><br><span class="line">  fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span> = ftell(fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getFileName</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(*pathName!=<span class="string">'\0'</span>)pathName++;</span><br><span class="line">  <span class="keyword">while</span>(*pathName!=<span class="string">'/'</span>)pathName--;</span><br><span class="line">  <span class="keyword">return</span> pathName+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unpack</span><span class="params">(struct FileStruct* fileStruct,<span class="keyword">char</span>* file_content,<span class="keyword">char</span>* folder_name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* Full_name[FILE_NAME_LEN];</span><br><span class="line">  <span class="built_in">sprintf</span>(Full_name,<span class="string">"%s/%s"</span>,folder_name,fileStruct-&gt;fileName);</span><br><span class="line"><span class="comment">//  printf("%s\n",Full_name);</span></span><br><span class="line">  FILE* file=fopen(Full_name,<span class="string">"wb"</span>);</span><br><span class="line">  fwrite(file_content,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),fileStruct-&gt;fileSize,file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_suffix</span><span class="params">(<span class="keyword">char</span>* new_filename,<span class="keyword">int</span> occur_time,<span class="keyword">char</span>* old_filename)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* tem=old_filename;</span><br><span class="line">  <span class="keyword">while</span>(*tem!=<span class="string">'\0'</span>)tem++;</span><br><span class="line">  <span class="keyword">while</span>(*tem!=<span class="string">'.'</span>&amp;&amp;tem!=old_filename)tem--;</span><br><span class="line">  <span class="keyword">if</span>(tem!=old_filename)&#123;</span><br><span class="line">    *tem=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(new_filename,<span class="string">"%s(%d).%s"</span>,old_filename,occur_time,tem+<span class="number">1</span>);</span><br><span class="line">    *tem=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(new_filename,<span class="string">"%s(%d)"</span>,old_filename,occur_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> text_buf[BUF_LEN];</span><br><span class="line"><span class="keyword">char</span> person_buf[PERSON_BUF_LEN];</span><br><span class="line"><span class="keyword">char</span> file_NAME[FILE_NAME_LEN];</span><br><span class="line"><span class="keyword">char</span> dest_folder[FILE_NAME_LEN];</span><br><span class="line"><span class="keyword">char</span>* file_content;</span><br><span class="line"><span class="keyword">char</span> file_names[BUF_LEN][FILE_NAME_LEN];</span><br><span class="line"><span class="keyword">int</span> occur_times[BUF_LEN];</span><br><span class="line"><span class="keyword">int</span> file_name_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"输入要目标文件夹："</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,dest_folder);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"输入要解压的文件："</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,file_NAME);</span><br><span class="line">  FILE* f=fopen(file_NAME,<span class="string">"rb"</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">FileStruct</span> <span class="title">fileStruct</span>;</span></span><br><span class="line">  <span class="keyword">while</span>(fread(&amp;fileStruct,<span class="keyword">sizeof</span>(struct FileStruct),<span class="number">1</span>,f)!=<span class="number">0</span>)&#123;</span><br><span class="line">    file_content=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(fileStruct.fileSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,fileStruct.fileSize);</span><br><span class="line">    fread(file_content,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),fileStruct.fileSize,f);</span><br><span class="line">    <span class="keyword">int</span> ok=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;file_name_count;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(file_names[i],fileStruct.fileName)==<span class="number">0</span>)&#123;</span><br><span class="line">        occur_times[i]++;</span><br><span class="line">        <span class="keyword">int</span> occur_time=occur_times[i];</span><br><span class="line">        add_suffix(file_NAME,occur_time,fileStruct.fileName);</span><br><span class="line">        <span class="built_in">strcpy</span>(fileStruct.fileName,file_NAME);</span><br><span class="line">        ok=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(file_names[file_name_count],fileStruct.fileName);</span><br><span class="line">      occur_times[file_name_count++]++;</span><br><span class="line">    &#125;</span><br><span class="line">    Unpack(&amp;fileStruct,file_content,dest_folder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与同学互测并截屏运行结果"><a href="#与同学互测并截屏运行结果" class="headerlink" title="与同学互测并截屏运行结果"></a>与同学互测并截屏运行结果</h3><p>对同学发过来的这个文件进行解包：<br><img src="https://i.loli.net/2020/06/13/v39SGnLaDsRVrKZ.png" alt="image.png"><br>解包正常：<br><img src="https://i.loli.net/2020/06/13/lQrjKA6Xvik7PIe.png" alt="image.png"><br><img src="https://i.loli.net/2020/06/13/PgRAF8jXKC1qyBM.png" alt="image.png"><br>把我的dest文件发给同学后，解包结果如下：<br><img src="https://i.loli.net/2020/06/13/Az5Zb1d6rvpytV4.png" alt="image.png"><br>结果正常，证明不同操作系统的打包文件也可以被互相解包。</p>
<h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>这次实验算很简单了，并没有用到计算机网络中的什么知识，唯一比较难的是对文件的读写操作，通过查阅资料也能解决。借着这次实验复习了一下c语言中的各种基础知识，也算是一个不错的收获吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%89_%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%89_%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计算机网络实验三_应用层实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 17:59:15" itemprop="dateCreated datePublished" datetime="2020-06-13T17:59:15+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用层实验"><a href="#应用层实验" class="headerlink" title="应用层实验"></a>应用层实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握应用层的基本工作原理和实现方法</p>
<h2 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h2><p>telnet，WSL</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="HTTP协议的实验"><a href="#HTTP协议的实验" class="headerlink" title="HTTP协议的实验"></a>HTTP协议的实验</h3><h4 id="从学校网站（www-sysu-edu-cn）找一个网页下载"><a href="#从学校网站（www-sysu-edu-cn）找一个网页下载" class="headerlink" title="从学校网站（www.sysu.edu.cn）找一个网页下载"></a>从学校网站（<a href="http://www.sysu.edu.cn）找一个网页下载" target="_blank" rel="noopener">www.sysu.edu.cn）找一个网页下载</a></h4><p>http请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/cn/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/cn/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>http响应：</p>
<p><img src="https://i.loli.net/2020/06/12/fc8tQs7VDFN2Azb.png" alt="image.png"></p>
<h4 id="从学校网站（www-sysu-edu-cn）找一个图片下载"><a href="#从学校网站（www-sysu-edu-cn）找一个图片下载" class="headerlink" title="从学校网站（www.sysu.edu.cn）找一个图片下载"></a>从学校网站（<a href="http://www.sysu.edu.cn）找一个图片下载" target="_blank" rel="noopener">www.sysu.edu.cn）找一个图片下载</a></h4><p>http请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/images/content/2020-02/20200202145357635528.jpg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>http响应：<br><img src="https://i.loli.net/2020/06/12/xadvFyCmpj5ZQ1U.png" alt="image.png"></p>
<h4 id="在http请求的头部行中加入If-Modified-Since-Sat-16-May-2020-14-57-17-GMT从学校网站下载-2-的图片"><a href="#在http请求的头部行中加入If-Modified-Since-Sat-16-May-2020-14-57-17-GMT从学校网站下载-2-的图片" class="headerlink" title="在http请求的头部行中加入If-Modified-Since: Sat, 16 May 2020 14:57:17 GMT从学校网站下载(2)的图片"></a>在http请求的头部行中加入If-Modified-Since: Sat, 16 May 2020 14:57:17 GMT从学校网站下载(2)的图片</h4><p>http请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/images/content/2020-02/20200202145357635528.jpg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">If-Modified-Since</span>: Sat, 16 May 2020 14:57:17 GMT</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>http响应：<br><img src="https://i.loli.net/2020/06/12/FZI987nMwqS1kly.png" alt="image.png"><br>没有修改</p>
<h4 id="用流水线方式实现前面（1）（2），即把它们的请求拷贝到一起后发送出去（可能太长，第一部分可以只有看到末尾）。注意：connection都要是keep-alive"><a href="#用流水线方式实现前面（1）（2），即把它们的请求拷贝到一起后发送出去（可能太长，第一部分可以只有看到末尾）。注意：connection都要是keep-alive" class="headerlink" title="用流水线方式实现前面（1）（2），即把它们的请求拷贝到一起后发送出去（可能太长，第一部分可以只有看到末尾）。注意：connection都要是keep-alive"></a>用流水线方式实现前面（1）（2），即把它们的请求拷贝到一起后发送出去（可能太长，第一部分可以只有看到末尾）。注意：connection都要是keep-alive</h4><p>http请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/cn/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="string">/2012/images/content/2020-02/20200202145357635528.jpg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>http响应：</p>
<p><img src="https://i.loli.net/2020/06/12/9HFT6bqkSwU2ZJX.png" alt="image.png"><br><img src="https://i.loli.net/2020/06/12/zgjC4bKplyZfP8d.png" alt="image.png"></p>
<h4 id="用（1）的地址取回网页的一部分-100-200-400"><a href="#用（1）的地址取回网页的一部分-100-200-400" class="headerlink" title="用（1）的地址取回网页的一部分(100-200,400-)"></a>用（1）的地址取回网页的一部分(100-200,400-)</h4><p>http请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/2012/cn/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line">Range:bytes=100-200,400-</span><br><span class="line"><span class="attribute">Host</span>: www.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>http响应：<br><img src="https://i.loli.net/2020/06/12/rqLnHle6ON9vahC.png" alt="image.png"></p>
<h3 id="FTP协议的实验"><a href="#FTP协议的实验" class="headerlink" title="FTP协议的实验"></a>FTP协议的实验</h3><p>FTP服务器：IP地址为103.26.79.35，端口号为 21 （用户名：net，密码：123456）</p>
<h4 id="上传用学号命名的一个文本文件-学号-txt"><a href="#上传用学号命名的一个文本文件-学号-txt" class="headerlink" title="上传用学号命名的一个文本文件(学号.txt)"></a>上传用学号命名的一个文本文件(学号.txt)</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/PWFYa3yUe6iAsIp.png" alt="image.png"></p>
<p>数据连接的截屏：<br><img src="https://i.loli.net/2020/06/12/qo5dxYUXb14OncS.png" alt="image.png"></p>
<h4 id="查看当前目录内容-太多则选择一些-，并标注出-1-中自己上传的文件"><a href="#查看当前目录内容-太多则选择一些-，并标注出-1-中自己上传的文件" class="headerlink" title="查看当前目录内容(太多则选择一些)，并标注出(1)中自己上传的文件"></a>查看当前目录内容(太多则选择一些)，并标注出(1)中自己上传的文件</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/NlTCaqWweoUxYP9.png" alt="image.png"><br>数据连接的截屏：<br><img src="https://i.loli.net/2020/06/12/6cigMTpH9Yf8ZGz.png" alt="image.png"></p>
<h4 id="下载-1-中自己上传的文本文件"><a href="#下载-1-中自己上传的文本文件" class="headerlink" title="下载(1)中自己上传的文本文件"></a>下载(1)中自己上传的文本文件</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/mpTiJE269bklfB3.png" alt="image.png"><br>数据连接的截屏：<br><img src="https://i.loli.net/2020/06/12/1HvXrUNtFSlw5kn.png" alt="image.png"></p>
<h4 id="下载-ebook下的一个二进制文件-例如，-pdf文件"><a href="#下载-ebook下的一个二进制文件-例如，-pdf文件" class="headerlink" title="下载/ebook下的一个二进制文件(例如，.pdf文件)"></a>下载/ebook下的一个二进制文件(例如，.pdf文件)</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/FuVImgrxpcSaWRn.png" alt="image.png"><br>数据连接的截屏：<br><img src="https://i.loli.net/2020/06/12/DrEndlhq8gpuxKm.png" alt="image.png"></p>
<h4 id="采用断点续传下载一个-text下的一个文本文件的一部分"><a href="#采用断点续传下载一个-text下的一个文本文件的一部分" class="headerlink" title="采用断点续传下载一个/text下的一个文本文件的一部分"></a>采用断点续传下载一个/text下的一个文本文件的一部分</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/U4q9VatxmWEXpZR.png" alt="image.png"><br>数据连接的截屏：<br><img src="https://i.loli.net/2020/06/12/Y96GhpoX2aHBTkC.png" alt="image.png"></p>
<h4 id="分两次上传一个文本文件-（使用APPE命令）"><a href="#分两次上传一个文本文件-（使用APPE命令）" class="headerlink" title="分两次上传一个文本文件 （使用APPE命令）"></a>分两次上传一个文本文件 （使用APPE命令）</h4><p>控制连接的请求响应信息：<br><img src="https://i.loli.net/2020/06/12/n7pk4x8IoPFDuq2.png" alt="image.png"></p>
<p>第一次数据连接的截屏<br> <img src="https://i.loli.net/2020/06/12/CB4MkDntdXWKo1w.png" alt="image.png"><br>第一次ftp目录的截屏（包含上传文件）：<br> <img src="https://i.loli.net/2020/06/12/VjeiDKMav8R4nqU.png" alt="image.png"><br>第二次数据连接的截屏<br> <img src="https://i.loli.net/2020/06/12/BZvNxW2V8JLkMeg.png" alt="image.png"><br>第二次ftp目录的截屏（包含上传文件）：<br> <img src="https://i.loli.net/2020/06/12/a6LcYAVPBD28zm1.png" alt="image.png"><br>修改时间改变了。</p>
<h3 id="SMTP协议的实验"><a href="#SMTP协议的实验" class="headerlink" title="SMTP协议的实验"></a>SMTP协议的实验</h3><h4 id="通过我的QQ邮箱发一封没有附件的邮件到我的中大邮箱"><a href="#通过我的QQ邮箱发一封没有附件的邮件到我的中大邮箱" class="headerlink" title="通过我的QQ邮箱发一封没有附件的邮件到我的中大邮箱"></a>通过我的QQ邮箱发一封没有附件的邮件到我的中大邮箱</h4><p>请求和响应信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HELO 1347453756</span><br><span class="line">AUTH LOGIN</span><br><span class="line">*******</span><br><span class="line">*******</span><br><span class="line">MAIL FROM:&lt;1347453756@qq.com&gt;</span><br><span class="line">RCPT TO:&lt;zhangjr35@mail2.sysu.edu.cn&gt;</span><br><span class="line">data</span><br><span class="line">Date:Sat, 16 May 2020 21:52:50 +0800</span><br><span class="line">From: &quot;1347453756&quot; &lt;1347453756@qq.com&gt;</span><br><span class="line">To: &quot;zhangjr35&quot;&lt;zhangjr35@sysu.edu.cn&gt;</span><br><span class="line">Subject: I am zjr</span><br><span class="line">This a mail from zjr to zjr</span><br><span class="line">.</span><br><span class="line">QUIT</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/06/12/rQmARxzFNJK1sPn.png" alt="image.png"><br>打开中大邮箱，发现确实可以收到：<br><img src="https://i.loli.net/2020/06/12/RvhTS1JioGKjP9w.png" alt="image.png"></p>
<h4 id="通过我的QQ邮箱发一封带附件-二进制文件-的邮件-MIME-txt-到我的中大邮箱"><a href="#通过我的QQ邮箱发一封带附件-二进制文件-的邮件-MIME-txt-到我的中大邮箱" class="headerlink" title="通过我的QQ邮箱发一封带附件(二进制文件)的邮件(MIME.txt)到我的中大邮箱"></a>通过我的QQ邮箱发一封带附件(二进制文件)的邮件(MIME.txt)到我的中大邮箱</h4><p>请求和响应信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HELO 1347453756</span><br><span class="line">AUTH LOGIN</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">MAIL FROM:&lt;1347453756@qq.com&gt;</span><br><span class="line">RCPT TO:&lt;zhangjr35@mail2.sysu.edu.cn&gt;</span><br></pre></td></tr></table></figure>

<p>邮件内容:<br><img src="https://i.loli.net/2020/06/13/F4IDPiYUErxkmJy.png" alt="image.png"><br>收到结果：<br><img src="https://i.loli.net/2020/06/13/UwXPdqLKjSC2nhR.png" alt="image.png"></p>
<h4 id="通过中大邮箱发送另一个带附件的邮件给QQ邮箱。可以先给你自己发一封带附件的邮件-再通过查看源码截取该响应报文的一部分，参见MIME-txt"><a href="#通过中大邮箱发送另一个带附件的邮件给QQ邮箱。可以先给你自己发一封带附件的邮件-再通过查看源码截取该响应报文的一部分，参见MIME-txt" class="headerlink" title="通过中大邮箱发送另一个带附件的邮件给QQ邮箱。可以先给你自己发一封带附件的邮件,再通过查看源码截取该响应报文的一部分，参见MIME.txt"></a>通过中大邮箱发送另一个带附件的邮件给QQ邮箱。可以先给你自己发一封带附件的邮件,再通过查看源码截取该响应报文的一部分，参见MIME.txt</h4><p>找了半天也没有找到查看源码的地方在哪。。。。。。只能放弃了。</p>
<h4 id="从你的邮箱发一份邮件到同学的邮箱"><a href="#从你的邮箱发一份邮件到同学的邮箱" class="headerlink" title="从你的邮箱发一份邮件到同学的邮箱"></a>从你的邮箱发一份邮件到同学的邮箱</h4><p>请求和响应信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HELO 1347453756</span><br><span class="line">AUTH LOGIN</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">MAIL FROM:&lt;1347453756@qq.com&gt;</span><br><span class="line">RCPT TO:zhanghb55@mail2.sysu.edu.cn</span><br></pre></td></tr></table></figure>

<p>邮件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">Date: Thu, 17 Apr 2014 20:30:07 +0800</span><br><span class="line">From: &#x3D;?utf-8?B?zjr?&#x3D; &lt;1347453756@qq.com&gt;</span><br><span class="line">To: zhanghb55 &lt;zhanghb55@mail2.sysu.edu.cn&gt;</span><br><span class="line">Subject: hbnb</span><br><span class="line">Mime-Version: 1.0</span><br><span class="line">Content-Type: multipart&#x2F;mixed;</span><br><span class="line">  boundary&#x3D;&quot;----&#x3D;_001_NextPart061116676577_&#x3D;----&quot;</span><br><span class="line"></span><br><span class="line">This is a multi-part message in MIME format.</span><br><span class="line"></span><br><span class="line">------&#x3D;_001_NextPart061116676577_&#x3D;----</span><br><span class="line">Content-Type: multipart&#x2F;alternative;</span><br><span class="line">  boundary&#x3D;&quot;----&#x3D;_002_NextPart640832068374_&#x3D;----&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------&#x3D;_002_NextPart640832068374_&#x3D;----</span><br><span class="line">Content-Type: text&#x2F;plain;charset&#x3D;&quot;GB2312&quot;</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line"></span><br><span class="line">aGJuYmhibmI&#x3D;</span><br><span class="line"></span><br><span class="line">------&#x3D;_002_NextPart640832068374_&#x3D;------</span><br><span class="line"></span><br><span class="line">------&#x3D;_001_NextPart061116676577_&#x3D;------</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>实验结果：<br><img src="https://i.loli.net/2020/06/13/WALJP5sdqBV6UGN.png" alt="image.png"><br>好像时间不对。。。为了避免麻烦同学就没改了。</p>
<h3 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h3><h4 id="查看我的QQ邮箱中每个邮件大小"><a href="#查看我的QQ邮箱中每个邮件大小" class="headerlink" title="查看我的QQ邮箱中每个邮件大小"></a>查看我的QQ邮箱中每个邮件大小</h4><p>请求和响应信息：<br><img src="https://i.loli.net/2020/06/13/PaQbJpXNz4CHEqF.png" alt="image.png"></p>
<h4 id="取回我的QQ邮箱的最后一封邮件的邮件唯一标识符"><a href="#取回我的QQ邮箱的最后一封邮件的邮件唯一标识符" class="headerlink" title="取回我的QQ邮箱的最后一封邮件的邮件唯一标识符"></a>取回我的QQ邮箱的最后一封邮件的邮件唯一标识符</h4><p>请求和响应信息：<br>用 UIDL 命令即可<br> <img src="https://i.loli.net/2020/06/13/TBsv5m1RZiCpVO9.png" alt="image.png"></p>
<h4 id="取回zsureceiver5-sina-com最后一封邮件"><a href="#取回zsureceiver5-sina-com最后一封邮件" class="headerlink" title="取回zsureceiver5@sina.com最后一封邮件"></a>取回<a href="mailto:zsureceiver5@sina.com">zsureceiver5@sina.com</a>最后一封邮件</h4><p>请求和响应信息：<br>用RETR命令即可<br> <img src="https://i.loli.net/2020/06/13/krUMFTZn6vVHDez.png" alt="image.png"></p>
<h4 id="取回三-1-中发到你邮箱的邮件"><a href="#取回三-1-中发到你邮箱的邮件" class="headerlink" title="取回三(1)中发到你邮箱的邮件"></a>取回三(1)中发到你邮箱的邮件</h4><p>请求和响应信息：<br>先用list命令看一下有多少封，取出最后一封即可。<br><img src="https://i.loli.net/2020/06/13/ujNOFE6DytKpcZz.png" alt="image.png"></p>
<p>五、mytelent源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN          20000                  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">char</span>* buf)</span></span>&#123;</span><br><span class="line">  fgets(buf,BUFLEN,<span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">int</span> len=<span class="built_in">strlen</span>(buf);</span><br><span class="line">  buf[len<span class="number">-1</span>]=<span class="string">'\r'</span>,buf[len]=<span class="string">'\n'</span>,buf[++len]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">client_recv</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_sock=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">char</span>* buf=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>((BUFLEN+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1=recv(my_sock,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* ptr,**pptr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hptr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">32</span>];</span><br><span class="line">  ptr=argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>((hptr=gethostbyname(ptr))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    perror(<span class="string">"gethostbyname"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pptr=hptr-&gt;h_addr_list;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* host=inet_ntop(hptr-&gt;h_addrtype,*pptr,str,<span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,host);</span><br><span class="line">  <span class="keyword">char</span>    *service = argv[<span class="number">2</span>];        <span class="comment">/* server port to connect       */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>             <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">  <span class="keyword">char</span>    buf[BUFLEN+<span class="number">1</span>];              <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">  <span class="keyword">int</span>     sock;                       <span class="comment">/* socket descriptor            */</span></span><br><span class="line">  <span class="keyword">int</span>     cc;                        <span class="comment">/* recv character count         */</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">  sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                      <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                      <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                        <span class="comment">// 因特网地址簇</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line"><span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service));         <span class="comment">// 设置服务器端口号</span></span><br><span class="line">  <span class="keyword">int</span> ret=<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line">  pthread_create(&amp;thread_handle,<span class="literal">NULL</span>,client_recv,(<span class="keyword">void</span>*)sock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    input(buf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"exit"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"退出成功!\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c1=send(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sock);                             <span class="comment">// 关闭监听套接字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">  getchar();                              <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>这次实验内容很多，我花了很长时间才完成。遇到的困难主要有:<br>1.windows系统下Telnet用不了，并不清楚为什么。折腾了一番之后只能在wsl(一个能在windows下跑的linux子系统)下用telnet。不过后来看到实验要自己写一个telnet，就又写了一个。<br>2.在写Telnet的过程中也遇到了很多问题，一个是不知道怎么把域名转为ip地址，后来在一篇博客上找到了相关的函数。第二个问题是连接网页的时候总是报 400 错误，找了半天发现是回车符的问题，把所有的\n改为\r\n后就解决了。其他的部分就简单了，我一开始以为要写很久，后来发现只要把实验二的客户端代码改一下就完成了。<br>3.对MIME格式文件不是很熟悉，看了很久才看明白（可能是上课听讲不认真）。<br>总的来说这次实验还是很有价值的，一方面锻炼了编程能力，另一方面也学到了很多应用层的相关知识，期待下一个实验的到来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9B%B8%E4%BC%BC%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9B%B8%E4%BC%BC%E5%BA%A6/" class="post-title-link" itemprop="url">时间序列相似度</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 21:55:02" itemprop="dateCreated datePublished" datetime="2020-06-06T21:55:02+08:00">2020-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="时间序列相似度度量标准实现"><a href="#时间序列相似度度量标准实现" class="headerlink" title="时间序列相似度度量标准实现"></a>时间序列相似度度量标准实现</h1><h2 id="预备知识：样本相似度度量标准"><a href="#预备知识：样本相似度度量标准" class="headerlink" title="预备知识：样本相似度度量标准"></a>预备知识：样本相似度度量标准</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="距离型"><a href="#距离型" class="headerlink" title="距离型"></a>距离型</h4><p>以差值为基础的相似度计算方法，通常值越小越相似。</p>
<h5 id="例子1：-欧式距离"><a href="#例子1：-欧式距离" class="headerlink" title="例子1： 欧式距离"></a>例子1： 欧式距离</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的欧式距离：</p>
<p>$d_{L^p}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert^p)^{\frac 1p}$</p>
<p>当 $p=1$ 时，距离为 $d_{L^1}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert)$，也称为曼哈顿距离。</p>
<p>当 $p=2$ 时，距离为 $d_{L^2}=(\sum\limits_{k=1}^{n}\left\vert x_k-y_k \right\vert^2)^{\frac 12}$，也称为欧几里得距离</p>
<p>当 $p\rightarrow \infin$ 时，距离为 $d_{L^\infin}=\max\limits_{1\le k \le n}\left\vert x_k-y_k \right\vert$</p>
<h5 id="例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）"><a href="#例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）" class="headerlink" title="例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）"></a>例子2：马氏距离（可以看成欧式距离使用协方差矩阵达成的标准化形式）</h5><p>两个向量的马氏距离为：</p>
<p>$$d(\vec x,\vec y)=\sqrt{(\vec x-\vec y)^{T}\sum^{-1}(\vec x-\vec y)}$$</p>
<p>其中，$\sum$ 为 $\vec x$ 和 $\vec y$ 的协方差矩阵。</p>
<p>为什么要用马氏距离？欧式距离不行吗？考虑下面这个例子：</p>
<p><img src="https://i.loli.net/2020/06/06/3b2wpQVOKTmXFaG.png" alt="image-20200602210843484.png"></p>
<p>上图中，红圆圈是数据点的均值，绿色的×和红色的×到均值的欧式距离是相等的，但我们可以明显地看到，绿色的×应该属于这个分布，红色的×不属于。这是因为</p>
<ol>
<li><p>不同维度(x轴，y轴)之间存在相关性(在这里表现为x轴与y轴存在正相关)。</p>
</li>
<li><p>不同方向上变化幅度不同，把图顺时针旋转45度，可以看到横向上变化较大，竖向上变化较小(有些资料把这一点称为量纲不同和方差不同)。</p>
</li>
</ol>
<p>用马氏距离就可以消除这种差别，它相当于把欧式距离进行了标准化。</p>
<h4 id="夹角型"><a href="#夹角型" class="headerlink" title="夹角型"></a>夹角型</h4><p>以乘积为基础的相似度计算方法，通常值越大越相似。可以通过取相反数达成值越小越相似。</p>
<h5 id="例子1：夹角余弦"><a href="#例子1：夹角余弦" class="headerlink" title="例子1：夹角余弦"></a>例子1：夹角余弦</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的夹角 $\theta$ 满足：</p>
<p>$cos\theta=\frac{\sum\limits_{k=1}^{n}x_k<em>y_k}{\sqrt{\sum\limits_{k=1}^{n}x_k^2}</em>\sqrt{\sum\limits_{k=1}^{n}y_k^2}}$</p>
<h5 id="例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）"><a href="#例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）" class="headerlink" title="例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）"></a>例子2：相关系数（其实也可以看成夹角余弦通过每个特征减均值达成的标准化形式）</h5><p>假设时间序列 $X={x_1,x_2……x_n}，Y={y_1,y_2……y_n}$，则可以定义它们之间的Pearson相关系数 $cor(X,Y)$ 满足：</p>
<p>$cor(X,Y)=\frac{\sum\limits_{k=1}^{n}(x_k-\bar x)<em>(y_k-\bar y)}{\sqrt{\sum\limits_{k=1}^{n}(x_k-\bar x)^2}</em>\sqrt{\sum\limits_{k=1}^{n}(x_k-\bar x)^2}}$</p>
<h2 id="针对特殊结构数据"><a href="#针对特殊结构数据" class="headerlink" title="针对特殊结构数据"></a>针对特殊结构数据</h2><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><p>核心需要：对齐</p>
<p>什么是对齐：样本特征的互相配对。</p>
<p>为什么要对齐：样本的相似度是根据样本特征的相似度累加/平均的，结构化数据的特征直接对齐了，但时间序列的每一时刻值可能没有天然强对齐关系。</p>
<p>得到样本相似度度量的实际处理：不同对齐策略下的相似度度量最值</p>
<p>不同对齐策略指对对齐的搜索空间的不同约束，搜索空间的大小会导致不同的复杂度。</p>
<p>时间序列对齐策略的潜在需求：</p>
<p>保序性（单调性）：例如T1:a, b, c; T2:x, y, z，无论怎么配对，T1配对出的匹配序列T2‘顺序满足y不会在x前面，z不会再x,y前面。</p>
<h4 id="保端点型对齐策略"><a href="#保端点型对齐策略" class="headerlink" title="保端点型对齐策略"></a>保端点型对齐策略</h4><p>可以一对多，需要全部点（时间序列各个时刻的值）都找到配对（从而开始点一定配对开始点，结束点一定配对结束点，也满足连续性）</p>
<p>比较适合的场景：语音相似度识别</p>
<h5 id="典型例子：DTW（-Dynamic-Time-Warping，动态时间规整）：保端点型对齐策略下的距离型度量"><a href="#典型例子：DTW（-Dynamic-Time-Warping，动态时间规整）：保端点型对齐策略下的距离型度量" class="headerlink" title="典型例子：DTW（[Dynamic Time Warping，动态时间规整）：保端点型对齐策略下的距离型度量"></a>典型例子：DTW（[Dynamic Time Warping，动态时间规整）：保端点型对齐策略下的距离型度量</h5><p><img src="https://pic4.zhimg.com/v2-343ad369c65bd575f40d17f10ae523ef_b.jpg" alt="img"></p>
<p>上图就是DTW对齐策略的一个例子。</p>
<p>最基本的DTW可以用动态规划(dp)来实现。具体的，假设时间序列 $X={x_1,x_2……x_m}，Y={y_1,y_2……y_n}$ ，用 $dp[i][j] ,i\le m,j\le n$ 来表示 $X$ 的前 $i$ 个点和 $Y$ 的前 $j$ 个点能取得的最小距离，定义状态转移方程为：</p>
<p>​                    $$dp[i][j]=\begin{cases} dist(1,1),i=1,j=1 \ dp[i-1][j]+dist(i,1)，i&gt;1,j=1 \ dp[i][j-1]+dist(1,j),i=1,j&gt;1\min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j-1])+dist(i,j),i&gt;1,j&gt;1  \end{cases}$$</p>
<p>其中 $dist(i,j)=(X[i]-Y[j])^2$ 。</p>
<p>为了将结果可视化，可以将距离矩阵（即 dist ）绘制出来，如 $X=[3,6,8],Y=[2,4,8,7]$ 时，距离矩阵如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/7BRvN3TzMlkayhE.png" alt="image-20200604221146644.png"></p>
<p>要达到一个最小距离，相当于从左上角走到右下角，且每次只允许往右、往下或者往右下走，使得走过的数字的和最小。显然在这个图里应该这样走：</p>
<p><img src="https://i.loli.net/2020/06/06/TBKFsEo1PH26Cqk.png" alt="image-20200604221539941.png"></p>
<h6 id="DTW的优点"><a href="#DTW的优点" class="headerlink" title="DTW的优点"></a>DTW的优点</h6><p>DTW能处理长度不同的时间序列，这是它比传统的距离算法强的地方。而且对很多时间序列，用DTW进行距离计算明显更合理。</p>
<h6 id="DTW的缺点"><a href="#DTW的缺点" class="headerlink" title="DTW的缺点"></a>DTW的缺点</h6><p>用距离来度量相似度的算法的时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 的 ，而DTW算法在时间和空间上都是 $O(nm)$ 的。对于较长的时间序列，直接进行计算显然开销太大，于是要引进一些优化的方法。</p>
<p>以下的变种是基于缩减搜索空间得到的变种。</p>
<h5 id="DTW变种1：greedy-DTW"><a href="#DTW变种1：greedy-DTW" class="headerlink" title="DTW变种1：greedy-DTW"></a>DTW变种1：greedy-DTW</h5><p>来自论文《Time2Graph: Revisiting Time Series Modeling with Dynamic Shapelets》的附录A.1的Algorithm 5</p>
<p>这种算法是用贪心的思想，即每次选择所有能走的点里代价最小的点。为了避免出现沿着边缘走的情况，设置一个窗口 $w$ ，规定走到的位置 $x,y$ 满足 $|x-y|\le w$ 。比如说，对时间序列 $X=[2,3,5,7,1],Y=[4,2,8,6,4]$，dist矩阵和走过的路线是这样子的：</p>
<p><img src="https://i.loli.net/2020/06/06/jBuzlAnGoPLRsEt.png" alt="image-20200605171339497.png"> </p>
<h6 id="greedy-DTW的优点"><a href="#greedy-DTW的优点" class="headerlink" title="greedy-DTW的优点"></a>greedy-DTW的优点</h6><p>它最大的优点是速度快，只需要 $O(n+m)$ 的时间复杂度就可以完成计算。</p>
<h6 id="greedy-DTW的缺点"><a href="#greedy-DTW的缺点" class="headerlink" title="greedy-DTW的缺点"></a>greedy-DTW的缺点</h6><p>缺点也很明显，贪心算法无法保证取得全局最优解，容易”误入歧途”。</p>
<h5 id="DTW变种2：Fast-DTW"><a href="#DTW变种2：Fast-DTW" class="headerlink" title="DTW变种2：Fast-DTW"></a>DTW变种2：Fast-DTW</h5><p>来自论文《FastDTW: Toward Accurate Dynamic Time Warping in Linear Time and Space》</p>
<p>可参考<a href="https://www.cnblogs.com/kemaswill/archive/2013/04/18/3029078.html" target="_blank" rel="noopener">https://www.cnblogs.com/kemaswill/archive/2013/04/18/3029078.html</a></p>
<p>这种方法的基本策略是递归。FastDTW 算法如下：</p>
<p>对于两个时间序列 $X=[1,2,3,4],Y=[3,4,5,6]$，首先将它们的长度缩短为一半，变成 $X’=[1.5,3.5],Y’=[3.5,5.5]$ ，相对应的，矩阵从 4×4 变成了 2×2，如下图所示：</p>
<p><img src="https://i.loli.net/2020/06/06/2DJK9mwILQdhzRv.png" alt="image-20200606011018301.png"></p>
<p>然后，对压缩后的时间序列递归地应用 FastDTW找到一条路径（由于这里的时间序列长度只有2，就可以直接找到不用递归），如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/PZmMsNckqW7uLiw.png" alt="image-20200606011233288.png"></p>
<p>在原来的矩阵中给这条路径经过的块打上标记，如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/D5UwZMiRAbcaQKo.png" alt="image-20200606011749696.png"></p>
<p>为了增大搜索范围，对路径以 $r$ 为半径拓展，即将与路径的距离小于等于 $r$ 的路径打上标记。$r=1$ 时，如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/gxuzD853QrbXlkT.png" alt="image-20200606012002821.png"></p>
<p>这样，就得到了我们的搜索路径，然后只用在这条路径里找就可以了。看起来，搜索路径并不比原来的矩阵小多少，但当时间序列长度足够大时，搜索路径会很小，因为它是 $O(n*r)$ 的，证明略。</p>
<h6 id="Fast-DTW的优点"><a href="#Fast-DTW的优点" class="headerlink" title="Fast-DTW的优点"></a>Fast-DTW的优点</h6><p>最大的优点显然是速度快，如下图所示（顺便吐槽一句，04年的时候执行一个 $n=1000$ 的 $O(n^2)$ 算法竟然要0.92秒，而今天的计算机可能不用0.01秒，看来计算机领域的发展还是很快的）：</p>
<p><img src="https://i.loli.net/2020/06/06/J91Eogx3DBsAKqh.png" alt="image-20200606012512919.png"></p>
<p><img src="https://i.loli.net/2020/06/06/Dz9jpLuveJbEXVK.png" alt="image-20200606012619988.png"></p>
<p>对于 $N=1000$ 左右的时间序列，用 $r=20$ 的 Fast-DTW 会比 DTW 快了 4-5倍。当 $N$ 不断增大时，加速效果还会更明显。</p>
<h6 id="Fast-DTW的缺点"><a href="#Fast-DTW的缺点" class="headerlink" title="Fast-DTW的缺点"></a>Fast-DTW的缺点</h6><p>由于这种方法得到的是较优解，因此我们有必要关注它的误差。定义误差如下所示：</p>
<p><img src="https://i.loli.net/2020/06/06/6OEouycJ5bAe72W.png" alt="image-20200606013024726.png"></p>
<p>经过试验得到误差大小：</p>
<p><img src="https://i.loli.net/2020/06/06/DsCXq1VcRS74I9a.png" alt="image-20200606013005315.png"></p>
<p>可以看到，当 $r=20$ 时，平均误差已经小于 $1%$ 。虽然误差仍然存在，但已经基本可以忽略。</p>
<p>还有一个缺点是编程难度较DTW大。</p>
<h5 id="DTW变种3：constrained-DTW"><a href="#DTW变种3：constrained-DTW" class="headerlink" title="DTW变种3：constrained DTW"></a>DTW变种3：constrained DTW</h5><p>来自论文《Searching and mining trillions of time series subsequences under dynamic time warping》</p>
<p>这篇文章对几种已有的剪枝策略进行了讨论，对它们的下界和时间复杂度进行了比较进行了比较，如下图所示：</p>
<p><img src="https://i.loli.net/2020/06/06/XqjekxGlUFdMbVJ.png" alt="image-20200606141816713.png"></p>
<p>一般认为在虚线下方的剪枝策略是没用的，因为至少存在一种下界更高且时间复杂度更低的策略。</p>
<p>最终作者决定用这种策略：先用 $LB_{Kim}FL$ ，如果不能大于 $Best_so_far$ ，则再用 $LB_{Keogh}EQ$ ，还是不行就用 $LB_{Keogh}EC$，再不行就用 $Early_abandoning_DTW$ 。</p>
<p>至于cDTW，似乎这篇论文并没有提到，查了其他的资料，大概就是把DTW的路径限制在对角线旁边的样子。</p>
<h4 id="平移型对齐策略"><a href="#平移型对齐策略" class="headerlink" title="平移型对齐策略"></a>平移型对齐策略</h4><p>只可一对一，允许两边边界的点（端点及端点附近点）找不到配对，满足连续性。</p>
<p>比较适合的场景：时钟不共享而有一定偏差的两条时间序列</p>
<h5 id="典型例子：cross-correlation：平移型对齐策略下的夹角型度量"><a href="#典型例子：cross-correlation：平移型对齐策略下的夹角型度量" class="headerlink" title="典型例子：cross-correlation：平移型对齐策略下的夹角型度量"></a>典型例子：cross-correlation：平移型对齐策略下的夹角型度量</h5><p>可参考论文&lt;&lt;k-Shape: Efficient and Accurate Clustering of Time Series&gt;&gt;的3.1节的介绍</p>
<p>cross-correlation的定义与卷积类似，对于函数 $f(x)$ 和 $g(x)$ ，它们的 cross-correlation 定义为 </p>
<p>$$h(x)=\int_{-\infin}^{+\infin}f(t)g(x+t)dt$$。事实上，把 + 号改为 - 号就是卷积了。两个已经标准化了的时间序列 $\vec x=(x_1,…,x_m)$ 和 $\vec  y=(y_1,…,y_m)$ 的 cross-correlation 可以这样定义：$CC(\vec x,\vec y)=(c_1,c_2,…,c_{2*m-1})$</p>
<p>其中：$c_{k+m}=\begin{cases}\sum\limits_{l=1}^{m-k}x_{l+k}y_l,k&gt;0\ \vec x · \vec y ,k=0 \ \sum\limits_{l=1-k}^{m}x_{l+k}y_l,k&lt;0 \end{cases}$</p>
<p>然后在 $CC(\vec x,\vec y)$ 中找到一个最大的，记为 $CC_w(\vec x,\vec y)$，定义 $NCC_c(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{\sqrt{R_0(\vec x,\vec x)·R_0(\vec y,\vec y)}}$。这样就把距离归化到 $[-1,1]$。再定义 $SBD(\vec x,\vec y)=1-NCC_c(\vec x,\vec y)$ ，则得到 向量 $\vec x$ 和向量 $\vec y$ 的 SBD（Shape-based distance）距离，对于形状接近的时间序列，这个值接近于0，否则接近于2。</p>
<p>值得注意的是，直接计算两个长为 $m$ 的时间序列的SBD距离是 $O(m^2)$ 的，但我们知道两个序列的卷积可以 $O(mlogm)$ 地计算，而)卷积只用把 $\vec x$ 翻转一下就变成了 $CC(\vec x,\vec y)$，因此，计算 SBD 距离也是 $O(mlogm)$ 的。这会比 $O(m^2)$ 的 DTW 算法快很多。</p>
<p>以下的变种是基于不同标准化思路得到的变种。</p>
<p>&lt;&lt;k-Shape: Efficient and Accurate Clustering of Time Series&gt;&gt;的3.1节的公式8的3个变种</p>
<p>定义 $NCC_b(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{m}$ 这样的结果并不会归一化到一个区间，有啥规律我也看不出来…</p>
<p>定义 $NCC_u(\vec x,\vec y)=\frac{CC_w(\vec x,\vec y)}{w-|w-m|}$，这样的结果是上面有多少项相乘，则结果就除以多少。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A3/" class="post-title-link" itemprop="url">并行与分布式计算作业3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 16:14:54" itemprop="dateCreated datePublished" datetime="2020-05-15T16:14:54+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并行与分布式计算作业3"><a href="#并行与分布式计算作业3" class="headerlink" title="并行与分布式计算作业3"></a>并行与分布式计算作业3</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>​        利用LLVM （C、C++）或者Soot （Java）等工具检测多线程程序中潜在的数据竞争以及是否存在不可重入函数，给出案例程序并提交分析报告。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        用pthreads编写一个简单的并行程序，用附带了ThreadSanitizer的clang对代码进行编译，在终端运行，查看数据竞争情况。再根据ThreadSanitizer的输出结果对代码进行修改，通过忙等待、互斥量和信号量等方法对临界区加锁，消除数据竞争。</p>
<p>​        编写一个检测程序中是否存在不可重入函数的程序，它读取一个IR文件，判断其中的每一个函数是否是不可重入的。</p>
<h2 id="检测数据竞争"><a href="#检测数据竞争" class="headerlink" title="检测数据竞争"></a>检测数据竞争</h2><p>​        根据<br>    $$\pi=4<em>(\sum_{n=1}^{\infty}(-1)^{n-1}</em>\frac{1}{2n-1})$$</p>
<p>​        编写一个计算$\pi$值的并行程序,代码见code1.c:</p>
<p>​        通过命令行参数得到线程数量和要计算的范围。在第33行创建多个线程，每个线程负责计算一部分内容，把结果累加到全局变量sum上。由于多个线程是并行执行的，且会对sum进行修改，所以会出现问题。不用ThreadSanitizer时，程序运行结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/yzVAJMmTWxp6ihv.png" alt="image-20200424185518501.png"></p>
<p>​        可以看到，每次运行结果都不一样，有时偏大有时偏小，说明数据竞争现象确实存在。</p>
<p>​        用ThreadSanitizer检测，结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/RvzdrZ8S3Im7VEh.png" alt="image-20200424190726679.png"></p>
<p>​        可以看到，运行结果显示存在data race，在第21行，刚好就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        一个很自然的想法是，给每个线程创建一个局部变量，把要计算的值加到这个局部变量上，最后再对所有线程求一次和。只需将Thread_sum函数修改为这样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样看似正常，但运行后发现，第24行仍然是多个线程同时修改一个全局变量，仍然存在数据竞争现象:</p>
<p><img src="https://i.loli.net/2020/05/15/hL9vPbIAzw6tsuG.png" alt="image-20200424194846838.png"></p>
<h2 id="解决数据竞争"><a href="#解决数据竞争" class="headerlink" title="解决数据竞争"></a>解决数据竞争</h2><p>​        尝试用忙等待、互斥量和信号量来解决数据竞争问题。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>​        忙等待就是设置一个标记变量，用于指明临界区可以被哪个线程执行，该执行完之后修改这个标记变量，而不能执行临界区的线程必须一直处于忙等待状态。</p>
<p>​        这只用定义一个flag，再对上面的第24行修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">flag=(flag+<span class="number">1</span>)%thread_count;</span><br></pre></td></tr></table></figure>

<p>​        完整代码保存在code2.c</p>
<p>​        ThreadSanitizer似乎不支持用忙等待的方法对临界区加锁:</p>
<p><img src="https://i.loli.net/2020/05/15/hIrN26FVJad5EDu.png" alt="image-20200424221456398.png"></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>​        互斥量能保证同一时间只有一个线程在执行临界区的代码，其他线程只能等待。等当前线程执行完之后，会从等待的线程中随机选一个进入临界区。</p>
<p>​        这只用定义一个互斥量mutex，再将临界区代码修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>​        完整代码保存在code3.c</p>
<p>​        用ThreadSanitizer测试，结果正常，没有warning:<br><img src="https://i.loli.net/2020/05/15/eZdkjpxIVoaWmLY.png" alt="image-20200424220329505.png"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​        信号量(semaphore)可以认为是一种特殊类型的unsigned int，它的类型是sem_t。信号量可以赋值为0,1,……。大多数情况下，我们只用0和1两个值。这种只有0和1值的信号量也称为二元信号量。0对应上了锁的互斥量，1对应没上锁的互斥量。</p>
<p>​        如果我们要用信号量来解决临界区问题，可以先创建一个全局信号量，初始值为1。在临界区前调用sem_wait()函数,这个函数的意义是:如果信号量为0则阻塞；如果是非0值则减1然后进入临界区。临界区执行完之后，调用sem_post()函数将信号量置为1。<del>好像跟互斥量没啥区别</del></p>
<p>​        这也只用定义一个信号量my_semaphore，在main函数里初始化，再将临界区代码修改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;my_semaphore);</span><br><span class="line">sum+=my_sum;</span><br><span class="line">sem_post(&amp;my_semaphore);</span><br></pre></td></tr></table></figure>

<p>​        完整代码见code4.c</p>
<p>​        测试一下，也很正常:</p>
<p><img src="https://i.loli.net/2020/05/15/BVSGmTND7Hr42ke.png" alt="image-20200424221059782.png"></p>
<h2 id="检测不可重入函数"><a href="#检测不可重入函数" class="headerlink" title="检测不可重入函数"></a>检测不可重入函数</h2><p>​        利用clang可以生成c语言程序对应的中间表示，下面这个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  B(<span class="number">1</span>);</span><br><span class="line">  val=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    会被转化为</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define void @C(i32) #0 &#123;</span><br><span class="line">  %2 = alloca i32,<span class="built_in"> align </span>4</span><br><span class="line">  store i32 %0, i32* %2,<span class="built_in"> align </span>4</span><br><span class="line">  call void @B(i32 1)</span><br><span class="line">  store i32 1, i32* @val,<span class="built_in"> align </span>4</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们不关心其他的内容，只需要知道:</p>
<ol>
<li><p>函数定义以“define”开始，这一行的第一个  ‘@’  和  ‘(‘  之间的字符串是函数的名字。</p>
</li>
<li><p>调用一个其他函数会以 “call” 开始， 这一行的第一个  ‘@’  和  ‘(‘  之间的字符串是被调用函数的名字。</p>
</li>
<li><p>访问一个全局变量时会用到 ‘@’ ,访问其他变量会用到 ‘%’ 。</p>
<p>此外，被其他函数调用但没有在程序中定义的函数，像printf()函数等，都默认为不可重入函数。</p>
</li>
</ol>
<p>​       知道了这些，就可以写一个程序来检测程序中的不可重入函数了。做法很简单，把函数理解为一个点，把调用关系理解为边，A调用了B就连一条B-&gt;A的边。然后将访问了全局变量的函数和在程序中没有给出定义的函数标记为不可重入函数，从这些 “原生的” 不可重入函数开始进行深度优先搜索，凡是访问到的点都是不可重入函数。深度优先搜索的示例代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;<span class="comment">//用链式前向星的方法存边。这里是遍历u节点的每一条出边。</span></span><br><span class="line">    <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v])&#123;<span class="comment">//如果这个节点没有被访问过</span></span><br><span class="line">      vis[v]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(bkcr[v]!=<span class="number">-1</span>)bkcr[v]=<span class="number">1</span>;<span class="comment">//-1代表的是"原生的" 不可重入函数，1是由于调用了不可重入函数而成为不可重入函数的函数</span></span><br><span class="line">      dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        完整代码见code5.cpp</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​        编写一个test.c，里面有几个函数调用来调用去，如下图所示:</p>
<p><img src="https://i.loli.net/2020/05/15/WJbH2ApZY98dwGE.png" alt="image-20200504124549947.png"></p>
<p>​        用clang生成中间代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O0 -S -emit-llvm ./<span class="built_in">test</span>/test.c -o input.ll</span><br></pre></td></tr></table></figure>

<p>​        进行检测，输出如下:</p>
<p><img src="https://i.loli.net/2020/05/15/NiJcqHf8RXYGzL5.png" alt="image-20200504124714169.png"></p>
<p>​        结果符合预期。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        用ThreadSanitizer可以方便地检测多线程中存在的数据竞争问题，检测到临界区后，可以用互斥量和信号量对它进行加锁。利用llvm可以生成程序的中间代码，然后可以检测其中是否有不可重入函数。</p>
<p>​        这次实验完成的比较简单，主要是因为之前学过一点pthread，还写了篇<a href="https://reeeeeeeeeein.github.io/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" target="_blank" rel="noopener">学习笔记</a>，于是直接把代码和博客的内容拿过来用了(<del>抄自己的博客不算抄吧</del>)。检测不可重入函数稍微有点复杂，不过只要对llvm的中间代码有了基本的了解，学过一些图论算法，解决起来也不算困难。</p>
<p>​        一个比较大的收获是学会了使用ThreadSanitizer来检查数据竞争，大大方便了以后编写多线程程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/" class="post-title-link" itemprop="url">操作系统实验三_操作系统内核</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 15:10:51" itemprop="dateCreated datePublished" datetime="2020-05-15T15:10:51+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验三-操作系统内核"><a href="#操作系统实验三-操作系统内核" class="headerlink" title="操作系统实验三_操作系统内核"></a>操作系统实验三_操作系统内核</h1><p>[toc]</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1、加深理解操作系统内核概念<br>2、了解操作系统开发方法<br>3、掌握汇编语言与高级语言混合编程的方法<br>4、掌握独立内核的设计与加载方法<br>5、加强磁盘空间管理工作</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1、知道独立内核设计的需求<br>2、掌握一种x86汇编语言与一种C高级语言混合编程的规定和要求<br>3、设计一个程序，以汇编程序为主入口模块，调用一个C语言编写的函数处理汇编模块定义的数据，然后再由汇编模块完成屏幕输出数据，将程序生成COM格式程序，在DOS或虚拟环境运行。<br>4、汇编语言与高级语言混合编程的方法，重写和扩展实验二的的监控程序，从引导程序分离独立，生成一个COM格式程序的独立内核。<br>5、再设计新的引导程序，实现独立内核的加载引导，确保内核功能不比实验二的监控程序弱，展示原有功能或加强功能可以工作。<br>6、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>Windows 10</li>
<li>WSL （Windows Subsystem for Linux） [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。</li>
<li>gcc version 7.5.0：C 语言程序编译器，Ubuntu 自带。</li>
<li>ld  version 2.3.0:  链接器，Ubuntu自带</li>
<li>NASM version 2.13.02：汇编程序编译器，通过<code>sudo apt install nasm</code>安装在 WSL 上。</li>
<li>Oracle VM VirtualBox ：轻量开源的虚拟机软件，安装在Windows下。</li>
<li>VSCode - Insiders v1.33.0：好用的文本编辑器，有丰富的插件，可以用它来打开WSL中的文件夹，用它自带的终端执行make命令。</li>
<li>GNU Make 4.1：安装在 Ubuntu 下，一键编译并连接代码，生成最终的文件。</li>
<li>Bochs 2.1.1：安装在Windows下，用于调试代码。</li>
</ul>
<h3 id="自制工具"><a href="#自制工具" class="headerlink" title="自制工具"></a>自制工具</h3><p>​        由于我的虚拟机和Bochs都安装在Windows下，所以需要将WSL中生成的文件写入至Windows的磁盘，这可以用我编写的工具 do 来解决，只需要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;do 文件名 写入的扇区</span><br></pre></td></tr></table></figure>

<p>​        就可以了。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        首先了解c语言程序与汇编语言程序混合编译的方法，再开发操作系统内核，它具有两个主要功能:</p>
<ul>
<li><p>提供加载用户程序的方法，用户可以将程序写入磁盘，然后让操作系统执行这些用户程序。</p>
</li>
<li><p>控制键盘输入和屏幕输出，使得用户可以与操作系统交互。</p>
</li>
</ul>
<p>​        再将上一次实验的4个程序放进磁盘，让操作系统执行它们，查看执行结果是否正确。</p>
<h3 id="c与汇编混合编译"><a href="#c与汇编混合编译" class="headerlink" title="c与汇编混合编译"></a>c与汇编混合编译</h3><p>​        由于操作系统内核非常复杂，只用汇编语言是很难完成的，因此需要使用c语言和汇编语言的混合编译，生成可执行的二进制文件。</p>
<p>​        可以用gcc将一个c语言程序编译生成汇编语言文件，如对下面这个test.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=i386 -m16 -ffreestanding -fno-PIE -masm=intel -S test.c -o test.asm</span><br></pre></td></tr></table></figure>

<p>​        会生成一个x86格式的汇编语言文件test.asm。它的内容很复杂，但我们只用关注一些关键的地方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	push	ebp;函数开始时，总要push ebp，保护这个寄存器</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	.cfi_offset 5, -8</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	.cfi_def_cfa_register 5</span><br><span class="line">	push	3 ;传递参数用push，把参数压到栈里，被调用的函数就能发现</span><br><span class="line">	call	f ;这里调用了f这个函数,用的是call指令</span><br><span class="line">	add	esp, 4 ;由于前面的ret和pop指令，现在esp指向的值就是3，也就是刚才传的参数，所以把esp+&#x3D;3，会让栈恢复到函数调用之前的状态</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	.cfi_restore 5</span><br><span class="line">	.cfi_def_cfa 4, 4</span><br><span class="line">	ret ;返回只用一条ret指令就可以了。由于我的test.c文件没有return 0，所以gcc帮我补上了一条ret指令</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>​         f  函数是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	push	ebp ;这里也是要push ebp</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	.cfi_offset 5, -8</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	.cfi_def_cfa_register 5</span><br><span class="line">	mov	eax, DWORD PTR [ebp+8] ;main函数用了call指令，esp要减4；前面push 了 ebp ，esp又要减4，所以esp+8才是我们传递给f函数的参数。</span><br><span class="line">	inc	eax ;返回一个值，可以把它放在eax里</span><br><span class="line">	pop	ebp ;这里把ebp pop 掉，esp+&#x3D;4</span><br><span class="line">	.cfi_restore 5</span><br><span class="line">	.cfi_def_cfa 4, 4</span><br><span class="line">	ret ;这里返回，esp+&#x3D;4</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>​        看来c语言生成的汇编程序也不算神秘，除了一些奇奇怪怪的指令，跟我们写的汇编程序也没有很大差别。通过上述分析，我们对函数调用和传递参数过程有了更深入的了解。</p>
<p>​        接着，我们编写一个汇编程序（msg.asm）和c程序（count.c）混合编程实例。汇编模块中定义一个字符串（为了方便，假设它以’\n’结尾），调用C语言的函数，统计其中某个字符出现的次数，汇编模块显示统计结果。</p>
<p>​        c程序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;*str!=<span class="string">'\n'</span>;str++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">'e'</span>)i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中，汇编程序调用c程序的函数的过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 0</span><br><span class="line">push string; string 是一个标号，占2个字节，但c语言的指针是4个字节，于是要把前两个字节置为0，就在上面多push一个0</span><br><span class="line">push 0;call会压栈2个字节，但c语言中默认的是压栈4个字节，如果我们不压栈4个字节，c程序中栈的位置会错乱</span><br><span class="line">call count</span><br></pre></td></tr></table></figure>

<p>​        函数返回会把返回值放在eax寄存器，然后汇编程序可以调用 10h 号中断把它显示出来。</p>
<p>​        编写makefile文件（makefile2）如下:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">kernel:msg.o count.o my_mbr</span></span><br><span class="line">	ld -m elf_i386 -N --oformat binary -Ttext 0x7e00 msg.o count.o -o kernel</span><br><span class="line">	<span class="comment">#ld 用于将汇编程序生成的二进制文件和c程序生成的二进制文件链接起来， -Ttest用于指定程序的起始位置为0x7e00处</span></span><br><span class="line">	./do kernel 1 <span class="comment"># 将kernel文件写入磁盘的第一个扇区</span></span><br><span class="line">    ./do my_mbr 0 <span class="comment"># my_mbr是引导扇区程序，它会将kernel文件加载到0x7e00处</span></span><br><span class="line"><span class="section">msg.o:msg.asm</span></span><br><span class="line">	nasm -felf msg.asm -o msg.o <span class="comment"># 如果不加 -felf 参数好像就不能调用c程序中的函数</span></span><br><span class="line">	nm msg.o &gt; tem.txt <span class="comment">#用 nm 命令来分析符号表，输出重定向到tem.txt文件</span></span><br><span class="line"><span class="section">count.o:count.asm</span></span><br><span class="line">	gcc -march=i386 -m16 -mpreferred-stack-boundary=2 -ffreestanding -fno-PIE -masm=intel -c count.c -o count.o</span><br><span class="line">	<span class="comment">#这里跟上文的编译方式基本一样，不同的是 -c 参数指定生成 .o 文件</span></span><br><span class="line">	nm count.o &gt;&gt; tem.txt  <span class="comment">#用 nm 命令来分析符号表，输出重定向到tem.txt文件的末端</span></span><br><span class="line"><span class="section">my_mbr:my_mbr.asm</span></span><br><span class="line">	nasm my_mbr.asm -o my_mbr</span><br></pre></td></tr></table></figure>

<p>​        在VSCode自带终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f makefile2</span><br></pre></td></tr></table></figure>

<p>​        就完成了编译、链接和写入磁盘的工作，非常方便。得到的符号表如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000001a t _end #因为msg.asm里将_start声明为全局变量，_end没有，所以这一行是 小写字母t 表示这是局部变量</span><br><span class="line">00000000 T _start #这一行是大写字母T表示全局变量</span><br><span class="line">         U count</span><br><span class="line">0000001c t string</span><br><span class="line">00000000 T count</span><br><span class="line">0000003f T main</span><br></pre></td></tr></table></figure>

<p>​        用bochs运行，结果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/BiZqJkC7Qdv3Ueu.png" alt="image-20200509142152549.png"></p>
<p>​        运行结果正常。</p>
<h3 id="开发操作系统内核"><a href="#开发操作系统内核" class="headerlink" title="开发操作系统内核"></a>开发操作系统内核</h3><p>​        理论上来说，用纯C语言开发内核也是可以的，但要用到很多内嵌汇编，会使程序看起来令人不适。为此，我把 C 程序中需要用到的大量汇编语言代码放置在entry.asm中，c程序只需要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号</span><br></pre></td></tr></table></figure>

<p>​        就可以调用entry.asm 里的各种过程。</p>
<h4 id="汇编程序部分"><a href="#汇编程序部分" class="headerlink" title="汇编程序部分"></a>汇编程序部分</h4><p>​        这部分的内容在entry.asm这个文件中，主要分为三部分。从第6行到第13行是第一部分，主要负责将控制权交给C程序中的main函数，当main函数返回时停机。</p>
<p>​        从第15行到第71行_load_program过程，用于加载用户程序。将程序从磁盘加载到内存可以调用  16h 号中断来实现，但我一调用就会出bug，于是我只能用《x86汇编语言：从实模式到保护模式》这本书里提供的代码。</p>
<p>​        调用这个过程之前要将用户程序被加载到的位置放置在dx中，用户程序在磁盘中的起始扇区放置在si中，用户程序的所占扇区数放置在bx中。</p>
<p>​        从第73行到第111行是clear过程，用于将屏幕清空。这个过程十分简单，不必赘述。</p>
<h4 id="C程序部分"><a href="#C程序部分" class="headerlink" title="C程序部分"></a>C程序部分</h4><p>​        main.c这个文件中的内容是操作系统内核的主要部分。它包括基础I/O操作、工具函数和各种用户交互命令。</p>
<h5 id="I-O-操作"><a href="#I-O-操作" class="headerlink" title="I/O 操作"></a>I/O 操作</h5><p>​        为了方便输入输出，我首先编写了getchar()、putchar()、getline()、put()这4个函数。</p>
<p>​        第23行到第32行的内容是 getchar() 函数，它通过调用 16h 号中断来得到一个输入字符。如果这个字符的值是13（回车符的键盘码），则返回 ‘\n’ 。</p>
<p>​        第34行到第86行的内容是putchar() 函数，它接受一个字符类型的参数，将字符打印到屏幕上。打印的位置由locr 、 locc 这两个全局变量来决定。</p>
<p>​        当要打印的字符是一个普通的字符时，调用 10h 号中断在当前光标处输出这个字符，并调整locr 和 locc 两个变量的值；</p>
<p>​        当要打印的字符是回车符时，将locc置0，将locr++，调用 10h 号中断设置光标的位置为 locc 和 locr 指定的位置；</p>
<p>​        当要打印的字符是退格符时，首先修改 locc 和 locr 两个变量的值，保证这两个值始终都是下一次打印的字符在的屏幕上的位置。然后调用10h号中断修改当前光标的位置为为 locc 和 locr 指定的位置，将这个位置的值清0。</p>
<p>​        getline()函数接受一个字符类型的指针，不断调用getchar()，把读进来的字符存到字符串里，读到回车符就终止，给字符串加上一个 ‘\0’ 。</p>
<p>​        put()函数接受一个字符类型的指针，不断调用putchar()输出它，遇到 ‘\0’ 就终止。</p>
<h5 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h5><p>​        为了方便，我编写了 int_to_str () , str_to_int () 和 strcmp () 这几个函数。意思很明显，内容也缺乏技术含量，不再赘述。</p>
<h5 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h5><p>​        程序会不断循环，每次都用getline读取用户输入的命令，并进行交互，共有clear、help、load 和 quit  4种交互命令。</p>
<p>​        clear命令会将屏幕清空，这只需调用前面说过的entry.asm里的_clear过程就可以了。</p>
<p>​        help命令会打印提示信息。</p>
<p>​        quit命令会终止操作系统内核的执行。</p>
<p>​        load命令是最重要的命令。设计这个命令的初衷是，假设用户有一块装有我的操作系统内核的硬盘，但他完全不懂电脑，只会将程序写入硬盘。这个命令可以让他将程序加载到内存中并运行，而完全不需要修改操作系统的代码。</p>
<p>​        load命令会打印一条提示信息提示，提示用户输入程序在磁盘中的起始位置，再打印一条提示信息，提示用户输入程序在磁盘中占用的扇区数。然后调用 _load_program 过程将程序加载进内存0xa000处，设置es、ds寄存器的值，并将控制权交给用户程序。用户程序运行结束后，操作系统会将es、ds寄存器的值清0，并清空屏幕。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>​        编写一个makefile文件，然后就可以在VSCode自带的终端里输入make完成大量的工作:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">user_programs=user_program_1 user_program_2 user_program_3 user_program_4</span><br><span class="line"><span class="section">all: kernel my_mbr <span class="variable">$(user_programs)</span></span></span><br><span class="line">	./do kernel 1 <span class="comment"># kernel 文件是生成的操作系统内核二进制文件</span></span><br><span class="line">	./do my_mbr 0 <span class="comment"># my_mbr 是引导扇区程序</span></span><br><span class="line"><span class="section">kernel:entry.o main.o  </span></span><br><span class="line">	ld -m elf_i386 -N --oformat binary -Ttext 0x7e00 entry.o main.o -o kernel</span><br><span class="line">	<span class="comment"># 这里将 entry.o 和 main.o 链接成kernel文件，参数在上文介绍过了，不再赘述</span></span><br><span class="line">	nm entry.o &gt; symbol_table.txt <span class="comment">#分析符号表，结果在 symbol_table.txt</span></span><br><span class="line">	nm main.o &gt;&gt; symbol_table.txt</span><br><span class="line"><span class="section">entry.o:entry.asm</span></span><br><span class="line">	nasm -felf <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">	gcc -march=i386 -m16 -mpreferred-stack-boundary=2 -ffreestanding -fno-PIE -masm=intel -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#参数在上文已经介绍过了，不再赘述</span></span><br><span class="line"><span class="section">my_mbr:my_mbr.asm</span></span><br><span class="line">	nasm my_mbr.asm -o my_mbr</span><br><span class="line"><span class="section">user_program_1:user_program_1.asm # user_program是一些用户程序，把它们分别写入到第10,20,30,40个扇区，然后可以在操作系统中加载它们</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 10</span><br><span class="line"><span class="section">user_program_2:user_program_2.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 20</span><br><span class="line"><span class="section">user_program_3:user_program_3.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 30</span><br><span class="line"><span class="section">user_program_4:user_program_4.asm</span></span><br><span class="line">	nasm <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	./do <span class="variable">$@</span> 40</span><br></pre></td></tr></table></figure>



<p>​        用bochs运行，依次输入load,10,1（第一个用户程序在磁盘的第10个扇区，大小为1个扇区）：</p>
<p><img src="https://i.loli.net/2020/05/15/W6c7UZwH2i3zbQ5.png" alt="image-20200509201901481.png"></p>
<p>​        效果拨群：</p>
<p><img src="https://i.loli.net/2020/05/15/82qvaxiGgCT6WH1.png" alt="image-20200509202009328.png"></p>
<p>​        按下Ctrl+C，返回操作系统:</p>
<p><img src="https://i.loli.net/2020/05/15/qVfBGdirO8TMtHz.png" alt="image-20200509202136463.png"></p>
<p>​        再依次输入load，20，2 加载第二个程序:</p>
<p><img src="https://i.loli.net/2020/05/15/pB162ZyeUJmLlri.png" alt="image-20200509205136902.png"></p>
<p>​        效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/pUdtYiPCSu12Ff4.png" alt="image-20200509205234324.png"></p>
<p>​        输入 load 40 4 后效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/p8iS1qwUP7LyH3X.png" alt="image-20200509205342547.png"></p>
<p>​        输入load 30 3 后效果如下:</p>
<p><img src="https://i.loli.net/2020/05/15/h4wkFUQot7C6lSY.png" alt="image-20200509205446870.png"></p>
<p>​        输入help打印提示信息:</p>
<p><img src="https://i.loli.net/2020/05/15/8FmgjUR9kdExCrw.png" alt="image-20200509205640183.png"></p>
<p>​        输入clear清空:</p>
<p><img src="https://i.loli.net/2020/05/15/oRcXPSM4mfpLC13.png" alt="image-20200509205739629.png"></p>
<p><img src="https://i.loli.net/2020/05/15/krx9MFn3uqolZsK.png" alt="image-20200510163248587.png"></p>
<p>​        输入quit可以退出操作系统：</p>
<p><img src="https://i.loli.net/2020/05/15/Ap3aekdBQ1SIJXP.png" alt="image-20200509205827461.png"></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​        这次实验算得上是很硬核了，用到了很多x86汇编的知识，还要用 ld 这种完全不熟的工具，用gcc里各种奇奇怪怪的参数，甚至为了方便我还学了一下makefile <del>（好像早就该学了吧）</del>    ，遇到的困难也有很多，主要有：</p>
<ul>
<li><p>​        对汇编语言不够了解。主要是函数调用和传参那里，非常麻烦，之前从没有深入了解过。而且C语言程序编译生成的汇编代码跟自己写的在风格上有很大差别，让我很不适应。一开始的时候只能看懂一些关键的语句的意思，好在我看多了之后还是克服了心中的 “恐惧感” 。</p>
</li>
<li><p>​        debug实在是太麻烦了。虽然我会使用bochs调试程序，但很多bug非常隐蔽，包括但不限于:</p>
<ol>
<li><p>在键盘中输入alt+tab切换屏幕，导致后面的输入无法被bochs读入。至今我都没想到解决的办法，好在不影响我写程序。</p>
</li>
<li><p>向c语言的函数传字符串常量会出错。这个问题好像不止我一个遇到，其他的同学和网上的<a href="https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">博客</a>也有这样的问题。我至今也没找到原因，只能把字符串常量改为char*类型。</p>
</li>
<li><p>向指向int类型的指针传short类型变量的地址。我声明了一个short变量，调用 str_to_int (char* s，int* val) 函数的时候把它的地址传了进去，本来我觉得反正都会进行类型转换，没啥问题。可是我执行了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*val=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>之后，问题就来了: short类型变量是2个字节，但 val 指针是int类型的指针，上面的操作会把内存中4个字节全部置为0。更要命的是，由于第一个参数先压栈，第二个字符后压栈，val指向的后面两个字节刚好就是 s 字符串的前两个字节，于是这个函数就不会得到正确的结果。当我想到这个问题时，我不禁为这世上有如此巧妙的bug而感到震惊。</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2020/05/15/QxwsYLrkB8vln9G.png" alt="image-20200509000616841.png"></p>
<p> <img src="https://i.loli.net/2020/05/15/PwOi6rSZyXVCknb.png" alt="image-20200509000427794.png"></p>
<ol start="3">
<li><p>int 16h 读键盘会导致光标位置出错。这是一个很奇怪的bug，不调用int 16h时，用int 10h 中断（ah=3）来读取光标位置可以正常运行，当我用 int 16h 读键盘输入后，用int 10h 中断（ah=03）就完全得不到正确结果，但在光标处打印字符却没有问题。我最终也没整明白这其中的缘由，只能放弃使用int 10h 中断来读取光标位置，改用 locc locr 这两个变量。</p>
<p>我后来想到，debug不一定要对着bochs的那些汇编代码一行行看，用内核输入输出函数也能帮助我debug，这样稍微缓解了我的压力。</p>
</li>
</ol>
<ul>
<li>​        很多工具不会用。说出来有点丢脸，在这次实验之前我从来没用过 ld 这个工具，当我看到老师给的ppt里那一串参数时，突然认识到自己是多么不学无术。经过我反复地尝试、不断地失败后，我总算学会了如何使用ld和gcc完成C程序与汇编程序混合编译<del>事实上只是能跑起来而已，学会是不可能学会的</del>。</li>
</ul>
<p>​        虽然困难很多，但收获也同样不少。通过这次实验，我大大加强了对汇编语言和C语言的了解，对操作系统的工作方式的认识也更加深入了。同时，完成操作系统内核的开发也算是一件很鼓舞人心的事情，这让我有了更多的勇气和兴趣来进一步学习更深的知识。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">https://wu-kan.cn/_posts/2019-03-28-%E7%94%A8%E6%B1%87%E7%BC%96%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8/</a> （今年大三的学长，博客写的很不错）</li>
<li><a href="https://blog.csdn.net/a200710716/article/details/45936643" target="_blank" rel="noopener">https://blog.csdn.net/a200710716/article/details/45936643</a> （关于键盘输入的ASCII码的资料）</li>
<li><a href="https://www.cnblogs.com/johnshao/archive/2011/06/13/2079638.html" target="_blank" rel="noopener">https://www.cnblogs.com/johnshao/archive/2011/06/13/2079638.html</a> （int 10h 中断的详细介绍）</li>
<li><a href="https://blog.csdn.net/ZCMUCZX/article/details/80462394?locationNum=4&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/ZCMUCZX/article/details/80462394?locationNum=4&amp;fps=1</a> （int 16h 中断的详细介绍）</li>
<li><a href="https://blog.csdn.net/daydayup654/article/details/78630341" target="_blank" rel="noopener">https://blog.csdn.net/daydayup654/article/details/78630341</a> （ ld 工具的详细介绍）</li>
<li><a href="http://c.biancheng.net/view/661.html" target="_blank" rel="noopener">http://c.biancheng.net/view/661.html</a> （gcc 的各种使用姿势）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C_%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C_%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">操作系统实验二_加载用户程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 14:57:12" itemprop="dateCreated datePublished" datetime="2020-05-15T14:57:12+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验二-加载用户程序"><a href="#操作系统实验二-加载用户程序" class="headerlink" title="操作系统实验二_加载用户程序"></a>操作系统实验二_加载用户程序</h1><p>众所周知，引导扇区程序会将操作系统加载到内存中，并把计算机的控制权交给操作系统。问题来了，引导扇区程序是怎么加载用户程序的？</p>
<p>这是一个复杂的问题，为了回答这个问题，首先我们需要了解用户程序的内容有什么样的格式，其次我们需要知道处理器与硬盘交互的方式，最后还要知道引导扇区程序怎么把控制权交给用户程序。</p>
<h2 id="用户程序header段"><a href="#用户程序header段" class="headerlink" title="用户程序header段"></a>用户程序header段</h2><p>在引导扇区程序中，处理器从0x7c00处开始执行代码。然而，对于引导扇区程序会把用户程序加载到哪一个位置，用户程序是不知道的。那就有问题了，如果我在用户程序中要访问数据段中的一个数据，却连这个数据在内存中的位置都不知道，还怎么访问呢？</p>
<p>分段的方法能很好的解决这个问题。用户程序被分为几段，每一段有一个起始地址，如果我们要访问一个数据，只需给出它在段中的偏移地址即可。用户程序会告诉引导扇区程序自己有几个段，每个段相对于程序开始处的偏移是多少，引导扇区程序会给用户程序在内存中分配一个位置，比如说，0xd000，然后假设用户程序的数据段相对于程序开始处偏移为0x100，则数据段会被加载到内存中的0xd100处。然后，引导扇区程序把ds置为0xd10，这样，用户程序就可以用段地址和偏移地址访问内存了。</p>
<p>为了告诉引导扇区程序一些必要的信息，用户程序会有一个header段，里面包含了程序的长度、第一条指令的位置、其他段的个数和其他段的相对偏移量。如图所示:</p>
<p><img src="https://i.loli.net/2020/04/27/WtKF7V15MsSwuJQ.png" alt="image-20200427172648671.png"></p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart&#x3D;0 align&#x3D;16 ;SECTION表明这是一个段的开头，vstart&#x3D;0表明这个段里的所有标号</span><br><span class="line">;都用的是偏移地址，align&#x3D;16表明这个段的起始位置要为16的倍数</span><br><span class="line">length dd program_end;program_end标号在程序的尾部，可以用来得到程序的长度</span><br><span class="line">codeentry dw start;start标号指向程序的第一条指令的位置</span><br><span class="line">          dd section.code_1.start;section.code_1.start指的是code_1这个段的开始位置，第一条指令在这个段里面</span><br><span class="line">          ;根据上面两行，可以知道用户程序的第一条指令的位置</span><br><span class="line">segment_table dw (header_end-code_1_segment)&#x2F;4;段表的长度，即这个程序还有几个段</span><br><span class="line">code_1_segment dd section.code_1.start;code_1段的开始位置</span><br><span class="line">data_1_segment dd section.data_1.start;data_1段的开始位置</span><br><span class="line">stack_segment dd section.stack.start;stack段的开始位置</span><br><span class="line">header_end:</span><br></pre></td></tr></table></figure>

<p>有了这个header段，引导扇区程序就能得到加载用户程序所必须的信息。由于引导扇区程序要将用户程序加载进内存，我们也成引导扇区程序为<strong>加载器</strong>。</p>
<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p>我们来看一下加载器会做些什么。</p>
<p>首先，我们默认加载器知道用户程序在磁盘中的哪一个扇区，也明确了用户程序会被加载到哪一个位置。在加载器的开头，会有一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_sector equ 100</span><br></pre></td></tr></table></figure>

<p>这是一个伪指令，相当于%define first_sector 100。</p>
<p>然后，加载器像其他程序一样，会有一个段声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align&#x3D;16 vstart&#x3D;0x7c00</span><br></pre></td></tr></table></figure>

<p>注意这里vstart=0x7c00。也就是说，后面的标号的值都要加上0x7c00。接下来是正常的设置堆栈段和栈指针的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure>

<p>然后要处理的是用户程序在内存中的起始位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[cs:start_loc]</span><br><span class="line">mov dx,[cs:start_loc+2]</span><br><span class="line">mov bx,16</span><br><span class="line">div bx</span><br><span class="line">mov es,ax</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>一开始时cs寄存器是0，start_loc标号在程序的尾部，内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_loc: dd 0x10000</span><br></pre></td></tr></table></figure>

<p>这个值就是用户程序会被加载到的位置。</p>
<p>由于0x10000是一个20位的数，于是只能用dx:ax两个寄存器来存储。我们将dx:ax除以16，商保存在ax中，将它赋值给es和ds。这样，ds和es就是用户程序的起始段地址。接下来我们读入第一个扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor bx,bx</span><br><span class="line">xor di,di</span><br><span class="line">mov si,first_sector</span><br><span class="line">call read_disk</span><br></pre></td></tr></table></figure>

<p>call指令意思是过程调用，它会先将ip的值保存至栈中，转而取执行read_disk位置的指令。事实上，它就相当于高级语言中的函数。向这个”函数”传递参数的方式是把要用到值放在其他寄存器中。</p>
<p>既然我们要读磁盘，我们得知道把要读哪一个扇区和读出来的内容放在哪里告诉磁盘。这里我们把扇区的位置放置在di:si中，读出来的内容放在[ds:bx]里 。做完这些工作，就可以调用read_disk了，它的内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">read_disk:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,1</span><br><span class="line">out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f3</span><br><span class="line">mov ax,si</span><br><span class="line">out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f4</span><br><span class="line">mov al,ah</span><br><span class="line">out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f5</span><br><span class="line">mov ax,di</span><br><span class="line">out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f6</span><br><span class="line">mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">or al,ah                        ;LBA地址27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f7</span><br><span class="line">mov al,0x20                     ;读命令</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">disk_ok?:</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88</span><br><span class="line">cmp al,0x08</span><br><span class="line">jne disk_ok?</span><br><span class="line"></span><br><span class="line">mov cx,256</span><br><span class="line">mov dx,0x1f0</span><br><span class="line"></span><br><span class="line">read_content:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne read_content</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>看起来很复杂，但只要一条条分析，还是能分析清楚的。首先是把ax,bx,cx,dx 4个寄存器push到栈中。因为我们要修改它们的值，得先把它们保护起来，等这个过程要返回了，就把它们pop回去。</p>
<p>从第7行到第30行，是在向I/O端口读写信息，这些端口是独立编址的。从I/O端口读入信息用in指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,dx</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in ax,dx</span><br></pre></td></tr></table></figure>

<p>dx是要访问的端口号，al、ax是用来保存读入的值。注意不能用其他的寄存器。</p>
<p>相应的，向I/O端口写入信息，要用out指令，用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,al</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out dx,ax</span><br></pre></td></tr></table></figure>

<p>dx是访问的端口号，al、ax是要写入的值。</p>
<p>in、out指令的dx参数也可以用立即数代替。</p>
<p>主硬盘端口分配的端口号是0x1f0-0x1f7。</p>
<p>其中，0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<p>0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。</p>
<p>0x1f2端口用于设置要读取的扇区数量，0x1f3-0x1f6端口用于设置起始扇区号。扇区号有28个字节，0-7字节要放在0x1f3里，8-15字节要放在0x1f4里，16-23字节要放在0x1f5里，24-27字节要放在0x1f6里。0x1f6的高4位置为1110。</p>
<p>端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送 读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第 7 位置 “1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第 3 位置“1”，意思是准备好了，请求主机发送或者接收数据。</p>
<p>了解了这些后，第7-30行的代码也就很容易理解了。</p>
<p>第32-36行是在不断判断硬盘是否准备好，如果没有则继续循环。</p>
<p>第38行将cx置为256，因为一个扇区是512个字节，一次读出2个字节。第39行将dx置为0x1f0，即从0x1f0读入数据。</p>
<p>第41-47行不断将数据读入到[ds:bx]处，然后将bx+=2。</p>
<p>最后恢复ax,bx,cx,dx寄存器，注意顺序要反过来。</p>
<p>第一次读完磁盘后，用户程序的第一个扇区就已经在内存里了。接下来要进行一些很重要的工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov dx,[bx+2]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov bx,512</span><br><span class="line">div bx</span><br><span class="line">cmp dx,0</span><br><span class="line">je tem1</span><br><span class="line">inc ax</span><br></pre></td></tr></table></figure>

<p>用户程序的前4个字节是用户程序的大小，先把它读入到ds:ax中，然后除以512，得到用户程序在磁盘中的扇区数。注意，如果用户程序的大小恰好为512的倍数，则除法指令结束后，ax的值就是用户程序占的扇区数，此时dx为0；否则，这个数字要加1。</p>
<p>接下来要读入其他扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tem1:</span><br><span class="line">dec ax</span><br><span class="line">mov cx,ax</span><br><span class="line">cmp cx,0</span><br><span class="line">je tem3</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">tem2:</span><br><span class="line">xor bx,bx</span><br><span class="line">inc si</span><br><span class="line">mov ax,ds</span><br><span class="line">add ax,0x20</span><br><span class="line">mov ds,ax</span><br><span class="line">call read_disk</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne tem2</span><br></pre></td></tr></table></figure>

<p>首先将ax减1(刚才已经读了一个扇区了)。如果ax==0，则跳过下面的工作；否则进入tem2这个循环。</p>
<p>循环里每次将si加1(ds:si是要读的扇区号)，将ds+=0x20(写入内存的位置每次往后推512个字节)，将bx置为0，然后调用read_disk过程读入扇区。</p>
<p>把扇区读完了，接下来要确定用户程序的第一条指令的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tem3:</span><br><span class="line">mov dx,[0x08]</span><br><span class="line">mov ax,[0x06]</span><br><span class="line">call segment_reloc</span><br></pre></td></tr></table></figure>

<p>回忆一下，第一条指令的位置是通过 段地址(第一条指令所在段的首地址)+偏移地址(第一条指令相对于段地址的差值) 给出的。在[ds:bx+0x06]到[ds:bx+0x09]之间的是段地址。我们把它的值与用户程序在内存中的首地址相加，就得到了这个段的真实地址，再把它右移4位，送到ax寄存器中。上述过程会被执行很多次（有好几个段），所以我们把它写成一个segment_reloc过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push dx</span><br><span class="line"></span><br><span class="line">add ax,[cs:start_loc]</span><br><span class="line">add dx,[cs:start_loc+0x02]</span><br><span class="line">shr ax,4</span><br><span class="line">shl dx,12</span><br><span class="line">or ax,dx</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>shr指令是右移4位，shl指令是左移12位，or指令把ax和dx合起来（ax的高4位为0，dx的低12位为0）。</p>
<p>得到真实段地址右移4位的值后，把它送回[ds:0x06]处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x06],ax</span><br></pre></td></tr></table></figure>

<p>接下来要读段表。首先从[ds:0x0a]处取出一个字放到cx中，表示段表的大小，然后将bx置为0x0c，这是段表的首地址相对用户程序起始处的偏移地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov cx,[0x0a]</span><br><span class="line">mov bx,0x0c</span><br></pre></td></tr></table></figure>

<p>接下来要一个个读:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">segment_table_reloc:</span><br><span class="line">mov dx,[bx+0x02]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">call segment_reloc</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,4</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne segment_table_reloc</span><br></pre></td></tr></table></figure>

<p>这部分内容跟开始时读段表差不多，不再赘述。</p>
<p>折腾完这些，加载器的工作差不多完成了，可以把控制权交给用户程序了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far [0x04]</span><br></pre></td></tr></table></figure>

<p>jmp far是 16 位间接绝对远转移。上面一条指令会从 ds:0x04 处取出6个字节，把前两个字节作为一个字，它是指令的偏移地址；后4个字节被当成一个双字，是指令所在段的地址（这个地址已经被我们重定位过了）。这样就能跳到用户程序的第一条指令了。注意，此时ds,es的值都是用户程序在内存中的首地址右移4位的值。</p>
<h2 id="用户程序其他内容"><a href="#用户程序其他内容" class="headerlink" title="用户程序其他内容"></a>用户程序其他内容</h2><p>看看用户程序会做什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SECTION code_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">start:</span><br><span class="line">mov ax,[stack_segment]</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,stack_end</span><br><span class="line"></span><br><span class="line">mov ax,[data_1_segment]</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,msg</span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">xor ax,ax</span><br><span class="line">mov di,0</span><br><span class="line"></span><br><span class="line">do:</span><br><span class="line">mov al,[bx]</span><br><span class="line">inc bx</span><br><span class="line">mov [es:di],al</span><br><span class="line">inc di</span><br><span class="line">mov byte [es:di],0x07</span><br><span class="line">inc di</span><br><span class="line">dec cx</span><br><span class="line">cmp cx,0</span><br><span class="line">jne do</span><br><span class="line"></span><br><span class="line">jmp near $</span><br><span class="line"></span><br><span class="line">SECTION data_1 align&#x3D;16 vstart&#x3D;0</span><br><span class="line">msg db &#39;hello world!&#39;</span><br><span class="line"></span><br><span class="line">SECTION stack align&#x3D;16 vstart&#x3D;0</span><br><span class="line">resb 256</span><br><span class="line">stack_end:</span><br><span class="line">SECTION trail align&#x3D;16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>

<p>第1行声明了一个段，第3行就是我们期待已经的第一条指令。前3条指令用于设置段指针和段寄存器的值。</p>
<p>第7，8行两行设置数据段寄存器ds的值，第9,10行两行设置附加段寄存器es的值。</p>
<p>从第12行开始是一个很正常的显示字符串的工作，不再赘述。</p>
<p>第32行声明了数据段，里面只有一个字符串。</p>
<p>第35行声明了堆栈段，里面用resb指令保留了256个字节。注意，stack_end标号是在resb指令的后面，因为栈指针的值是不断减小的。</p>
<p>最后，第38行声明了一个trail段，它没什么用，值得注意的是它没有vstart=0这个定义，所以标号program_end的值是从0开始算的，所以它的值就是用户程序的大小。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>用bochs运行，结果如下:</p>
<p><img src="https://i.loli.net/2020/04/27/j79IMNP2pcyd46C.png" alt="image-20200427174119405.png"></p>
<p>效果拨群。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80_%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80_%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">操作系统实验一_引导扇区程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 14:56:04" itemprop="dateCreated datePublished" datetime="2020-05-15T14:56:04+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统实验一-引导扇区程序"><a href="#操作系统实验一-引导扇区程序" class="headerlink" title="操作系统实验一_引导扇区程序"></a>操作系统实验一_引导扇区程序</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​        锻炼编写汇编语言程序的能力，增加对操作系统启动方式的了解，学习bochs调试工具、NASM编译工具的使用。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>​        设计IBM_PC的一个引导扇区程序，程序功能是：用字符‘A’从屏幕左边某行位置45度角下斜射出，保持一个可观察的适当速度直线运动，碰到屏幕的边后产生反射，改变方向运动，如此类推，不断运动；在此基础上，增加你的个性扩展，如同时控制两个运动的轨迹，或炫酷动态变色，个性画面，如此等等，自由不限。还要在屏幕某个区域特别的方式显示你的学号姓名等个人信息。将这个程序的机器码放进放进第三张虚拟软盘的首扇区，并用此软盘引导你的XXXPC，直到成功。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​        使用NASM来编译代码，由于VSCode里可以使用终端，所以我用VSCode来编写汇编代码，然后可以方便的在终端里用NASM。<br>​        用《x86汇编语言-从实模式到保护模式》这本书附带的fixvhdwr来将二进制文件写入至硬盘，然后使用bochs2.1.1来对程序进行调试，调试无误后把二进制文件放到VirtualBox运行。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​        我计划按实验要求的方法在屏幕上循环显示”reeeeeeeeeein”,并且字符的颜色不相同,每显示一些字符之后就把屏幕刷新。如下图所示:</p>
<p><img src="https://i.loli.net/2020/04/23/b3kvIO5Efi6KDJj.png" alt="image.png"></p>
<p>​        首先我们要确定当前要显示的位置，这就需要知道是在哪一行哪一列。于是我在程序末尾分配两个变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locr: db 0 ;当前所在行</span><br><span class="line">locc: db 0 ;当前所在列</span><br></pre></td></tr></table></figure>

<p>​        为了方便，以后直接用locr指代[ds:locr]这个位置存储的值，其他变量也是同理。</p>
<p>​        知道了当前位置，还需要知道下一个位置。下一个位置无非是由当前位置往左往右往上往下得到，于是我又分配了两个变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_or_d: db 0 ;上还是下，0是下，1是上</span><br><span class="line">l_or_r: db 0 ;0右，1左</span><br></pre></td></tr></table></figure>

<p>​        要显示”reeeeeeeeeein”,得知道现在要显示的是第几个字符，还要把这个字符串存储起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words: db &#39;r&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;i&#39;,&#39;n&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc: db 0 ;当前显示第几个字母</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%define name_length 13;字符串的长度为13</span><br></pre></td></tr></table></figure>

<p>​        为了美观，背景颜色就用默认的黑色，而字符的前景颜色用颜色表里I=1的8个颜色:<br><img src="https://i.loli.net/2020/04/23/u9dmARTcgSlZJGt.png" alt="image.png"><br>​        所以分配一个变量存储当前的颜色:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: db 8;颜色从8显示到15</span><br></pre></td></tr></table></figure>

<p>​        在我的电脑上，bochs和VirtualBox虚拟机的屏幕宽度都是80个字符。于是我设置可显示的宽度为80，可显示的高度为17。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%define width 80</span><br><span class="line">%define height 17</span><br></pre></td></tr></table></figure>

<p>​        要刷新屏幕，得用一个计数器，当它减到0就刷新一次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%define flush_seq 300</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_or_not: dw flush_seq;注意这里只能dw不能db，因为300&gt;255</span><br></pre></td></tr></table></figure>

<p>​        此外，为了显示我的””知识产权”，我会屏幕下方显示”made by zjr”这个字符串。</p>
<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><h4 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h4><p>​        把上面这些工作做完了，就可以开始编写一些重要的代码了。首先看一下显示字符的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">do:</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov al,[ds:locr]</span><br><span class="line">  imul bx,ax,width</span><br><span class="line">  mov ax,bx</span><br><span class="line">  xor bx,bx</span><br><span class="line">  mov bl,[ds:locc]</span><br><span class="line">  add ax,bx</span><br><span class="line">  add ax,ax</span><br><span class="line">  mov di,ax;到这里，es:di就是我们要访问的位置</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov al,[ds:loc]</span><br><span class="line">  mov si,ax</span><br><span class="line">  mov al,[ds:si+words]</span><br><span class="line">  mov [es:di],al</span><br><span class="line">  mov al,[ds:color]</span><br><span class="line">  mov byte [es:di+1],al</span><br><span class="line">  inc al</span><br><span class="line">  cmp al,16</span><br><span class="line">  jne tem0</span><br><span class="line">  mov al,8</span><br><span class="line">  tem0:</span><br><span class="line">  mov [ds:color],al</span><br><span class="line">  inc byte [ds:loc]</span><br><span class="line">  cmp byte [ds:loc],name_length</span><br><span class="line">  jne tem1</span><br><span class="line">  mov byte [ds:loc],0</span><br></pre></td></tr></table></figure>

<p>​        当前显示的位置是:</p>
<p>$$<br>locr*width+locc<br>$$</p>
<p>​        第二行把ax清0(这是有必要的，如果ah的值不为0可能得到错误的结果)。把locr的内容放到al里，然后第四行把ax和width相乘，结果放到bx。</p>
<p>​        第五行到第十行是把bx放到ax，并把locc加到ax里，然后ax乘2。ax乘2的原因是显示屏上显示一个字符要2个字节。最后把ax放到di里。这样，es:di就是我们当前要显示的位置。</p>
<p>​        从第11行到第15行是找到要显示的字符。首先取出loc，再用$ds:words+loc$得到要显示的字符的位置，最后把这个字符取出来，放到$es:di$里。</p>
<p>​        第16行开始是在确定字符的前景颜色，这跟找到字符是差不多的。注意color要自增一次，自增完之后要判断它是否等于16，如果等于，就把color置为8。</p>
<p>​        第24行开始是对loc的自增，然后判断是否是8，是的话就置为0。</p>
<h4 id="下一个位置"><a href="#下一个位置" class="headerlink" title="下一个位置"></a>下一个位置</h4><p>​        显示了当前的字符后，要确定下一个字符的位置，这就需要u_or_d和l_or_r这两个变量。u_or_d取值为0，则locr要加1，否则locr要减1；l_or_r取值为0，则locc加1，否则locc要减1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tem1:</span><br><span class="line">  cmp byte [ds:u_or_d],0</span><br><span class="line">  je tem2</span><br><span class="line">    dec byte [ds:locr]</span><br><span class="line">    jmp tem3</span><br><span class="line">  tem2:</span><br><span class="line">    inc byte [ds:locr]</span><br><span class="line">  tem3:</span><br><span class="line"></span><br><span class="line">  cmp byte [ds:l_or_r],0</span><br><span class="line">  je tem4</span><br><span class="line">    dec byte [ds:locc]</span><br><span class="line">    jmp tem5</span><br><span class="line">  tem4:</span><br><span class="line">    inc byte [ds:locc]</span><br></pre></td></tr></table></figure>



<p>​        先看1到7行:判断u_or_d是否为0，是则跳到tem2，把locr加1；否则把locr减1，然后跳到tem3,不执行tem2那里的操作。其实就是一个if-else语句。</p>
<p>​        10到16行基本与之相同，不再赘述。</p>
<h4 id="调整方向"><a href="#调整方向" class="headerlink" title="调整方向"></a>调整方向</h4><p>​        接下来，要判断方向要不要调整。如果locr到达height-1，则要把u_or_d改为1；如果locr到达0，则要把u_or_d改为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tem5:</span><br><span class="line"> cmp byte [ds:locr],height-1</span><br><span class="line"> jne tem6</span><br><span class="line"> mov byte [ds:u_or_d],1</span><br><span class="line"></span><br><span class="line"> tem6:</span><br><span class="line"> cmp byte [ds:locr],0</span><br><span class="line"> jne tem7</span><br><span class="line"> mov byte [ds:u_or_d],0</span><br><span class="line"></span><br><span class="line"> tem7:</span><br><span class="line"> cmp byte [ds:locc],width-1</span><br><span class="line"> jne tem8</span><br><span class="line"> mov byte [ds:l_or_r],1</span><br><span class="line"></span><br><span class="line"> tem8:</span><br><span class="line"> cmp byte [ds:locc],0</span><br><span class="line"> jne tem9</span><br><span class="line"> mov byte [ds:l_or_r],0</span><br></pre></td></tr></table></figure>

<p>​        先判断locr是否等于height-1，不等于就跳到tem6位置，不执行第4行。如果等于就执行第4行，把u_or_d改为1；再判断它是否为0，是的话就执行第9行，把u_or_d改为0。值得注意的是，两个判断语句是相互独立的，所以第三行不能调到tem7，而是要跳到tem6。</p>
<p>​        第11行往后跟前面基本是一样的。</p>
<h4 id="其他工作"><a href="#其他工作" class="headerlink" title="其他工作"></a>其他工作</h4><p>​        每打印一个字符，会让程序暂停一段时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tem9:</span><br><span class="line">  mov ah,86h</span><br><span class="line">  mov cx,0x1E</span><br><span class="line">  mov dx,0x8480     </span><br><span class="line">  int 15h</span><br></pre></td></tr></table></figure>



<p>​        考虑到如果屏幕字符很多会很影响观看体验，所以每打印300个字符会把屏幕刷新一遍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp word [ds:flush_or_not],0</span><br><span class="line">jne tem10</span><br><span class="line">mov word [ds:flush_or_not],flush_seq</span><br><span class="line">jmp flush</span><br><span class="line">tem10:</span><br><span class="line">  dec word [ds:flush_or_not]</span><br><span class="line">jmp do</span><br></pre></td></tr></table></figure>

<p>​        当flush_or_not等于0时，把它重新置为flush_seq，然后跳到flush段的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flush:</span><br><span class="line">  mov ax,width</span><br><span class="line">  imul bx,ax,height</span><br><span class="line">  xor ax,ax</span><br><span class="line">  mov di,ax</span><br><span class="line">  flush_do:</span><br><span class="line">    add di,di</span><br><span class="line">    mov byte [es:di],0</span><br><span class="line">    mov byte [es:di+1],0</span><br><span class="line">    inc ax</span><br><span class="line">    mov di,ax</span><br><span class="line">    cmp ax,bx</span><br><span class="line">    jl flush_do</span><br></pre></td></tr></table></figure>

<p>​        首先用width和height相乘，得到要刷新的总字节数。然后执行循环，当ax&lt;bx时继续，否则退出。循环里把di*2，然后将es:di和es:di+1置为0(注意一个字符占的位置是两个字节)，最后ax+1，将di置为ax。</p>
<p>​        把上面这段代码放在do标志前面，这样程序开始的时候就会把屏幕刷新。</p>
<p>​        在程序开始的地方要设置段寄存器和附加段寄存器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x7c0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br></pre></td></tr></table></figure>

<p>​        在屏幕下方打印”made by zjr”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,width</span><br><span class="line">imul bx,ax,height+2</span><br><span class="line">add bx,bx</span><br><span class="line">mov di,bx</span><br><span class="line">xor cx,cx</span><br><span class="line">mov si,cx</span><br><span class="line">do2:</span><br><span class="line">  mov al,[ds:si+my_name]</span><br><span class="line">  mov [es:di],al</span><br><span class="line">  inc di</span><br><span class="line">  inc di</span><br><span class="line">  inc si</span><br><span class="line">  cmp si,name2_length</span><br><span class="line">  jne do2</span><br></pre></td></tr></table></figure>

<p>​        由于显示”reeeeeeeeeein”的位置是左上角(0,0)到右下角(height-1,width-1),可以让”maded by zjr”字符串在(height+2,0)开始显示，于是用bx存储$width<em>(height+2)</em>2$，把它复制给di，然后就可以用es:di直接访问要存储的位置。此后进入循环，用si做循环变量，每次用[ds:si+my_name]得到要打印的字符，赋值给al，再把它送到到打印的位置。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>​        在VSCode里新建终端，输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NASM proj.asm -o p</span><br></pre></td></tr></table></figure>

<p>​        得到一个二进制文件。然后使用fixvhdwr把它写到一个文件格式为vhd的虚拟硬盘:</p>
<p><img src="https://i.loli.net/2020/05/15/m2Colb69jveKOUz.png" alt="image-20200423194702107.png"></p>
<p>​        然后选择这个二进制文件:</p>
<p><img src="https://i.loli.net/2020/05/15/Bfj7THwEq84MxRX.png" alt="image-20200423194811099.png"></p>
<p>​        写入完成后，可以用bochs打开:</p>
<p><img src="https://i.loli.net/2020/05/15/QbgTUBG2pA81Frx.png" alt="image-20200423195008833.png"></p>
<p>​        可以看到，结果符合预期。</p>
<p>​        然后可以用VirtualBox验证一下:</p>
<p>​        首先把刚才生成的二进制文件保存为img格式:</p>
<p><img src="https://i.loli.net/2020/05/15/r73KEhFymjLkSWv.png" alt="image-20200423195208552.png"></p>
<p>​        新建一个虚拟机:</p>
<p><img src="https://i.loli.net/2020/05/15/7bDsRBiTzPXmWfC.png" alt="image-20200423195406846.png"></p>
<p>​        点击右边的存储，往里面添加刚才创建的img文件作为软驱:</p>
<p><img src="https://i.loli.net/2020/05/15/LBQdsMFyj1ur3ft.png" alt="image-20200423195524820.png"></p>
<p>在系统一栏设置启动顺序为软驱优先:</p>
<p><img src="https://i.loli.net/2020/05/15/tUvoYS4eaLFDqKQ.png" alt="image-20200423195708890.png"></p>
<p>​        启动后就能看到结果：</p>
<p><img src="https://i.loli.net/2020/05/15/6czsDHAn1IuLJgB.png" alt="image-20200423195854503.png"></p>
<p>​        (似乎在virtualbox里显示的比bochs慢，并不知道为什么)</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>​        这次实验整体难度不算特别大，只对编写汇编代码有较基本的要求。我本来在2月份的时候就已经完成了，但只录了视频，没有写实验报告就交上去了，结果两个月过后，代码找不到了，实验报告也写不成了，没办法，只能重新写一遍，就算是练习吧。</p>
<p>​        虽然写的代码并不多，但还是有不少奇奇怪怪的bug,比如:</p>
<p><img src="https://i.loli.net/2020/05/15/beE8Kg6wa3mCvxu.png" alt="image-20200423200349299.png"></p>
<p>​        这里loc变量长度是一个字节，而si是一个16位的寄存器。把loc赋值给si后，尽管我加了个byte，但第36行的[ds:si]还是会取两个字节的值。一开始loc后面是没有变量的，运行结果十分正常，后来我在后面加了一个<img src="https://i.loli.net/2020/05/15/Bn3PD8pvrxhe72w.png" alt="image-20200423200602504.png"></p>
<p>​        取[ds:si]的时候就得到一个很大的值。这个bug困扰了我很久，直至我想起来si是个16位寄存器。</p>
<p>​        类似于这样的bug还有很多，不再一一列举。以后我得多练习汇编语言编程，为以后其他的实验做准备。</p>
<p>​        本次实验最大的收获还是增强了汇编语言编程能力，此外我还学会了用bochs进行debug，这对以后做实验是一个很大的帮助。还有的就是感谢TA推荐了Typora这个编写MarkDown文档的工具，确实比我之前用的VSCode插件好用很多，也算是一个意外之喜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_chat%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_chat%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计算机网络实验二_chat实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-14T00:00:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-15 14:40:00" itemprop="dateModified" datetime="2020-05-15T14:40:00+08:00">2020-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络实验2-Chat实验"><a href="#计算机网络实验2-Chat实验" class="headerlink" title="计算机网络实验2_Chat实验"></a>计算机网络实验2_Chat实验</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>利用客户/服务器(Client/Sever或CS)模式实现一个多人聊天(群聊)程序。其功能是每个客户发送给服务器的消息都会传送给所有的客户端。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>采用linux编程，调用pthread库</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1.编写多人聊天程序，要求客户端和服务器都采用多线程方式进行编程。每个客户端都采用TCP协议连接服务器并保持连接。服务器同时与所有客户端建立和保持连接。每个客户端输入的消息都会通过服务器转发给所有客户。</p>
<p>客户端程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN          2000                  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * main - TCP client for TIME service</span></span><br><span class="line"><span class="comment"> *------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">client_recv</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_sock=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">char</span>* buf=<span class="keyword">new</span> <span class="keyword">char</span>[BUFSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1=recv(my_sock,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message received: %s\n"</span>,buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>    *host = <span class="string">"127.0.0.1"</span>;        <span class="comment">/* server IP to connect         */</span></span><br><span class="line">        <span class="keyword">char</span>    *service = <span class="string">"50500"</span>;         <span class="comment">/* server port to connect       */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>             <span class="comment">/* an Internet endpoint address */</span></span><br><span class="line">        <span class="keyword">char</span>    buf[BUFLEN+<span class="number">1</span>];              <span class="comment">/* buffer for one line of text  */</span></span><br><span class="line">        <span class="keyword">int</span>     sock;                       <span class="comment">/* socket descriptor            */</span></span><br><span class="line">        <span class="keyword">int</span>     cc;                         <span class="comment">/* recv character count         */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> thread_handle;</span><br><span class="line">        sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                         <span class="comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                      <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_family = AF_INET;                        <span class="comment">// 因特网地址簇</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">      <span class="comment">//  printf("%d\n",sin.sin_addr.s_addr);               // 设置服务器IP地址(32位)</span></span><br><span class="line">        <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service));         <span class="comment">// 设置服务器端口号</span></span><br><span class="line">        <span class="keyword">int</span> ret=connect(sock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，</span></span><br><span class="line">        pthread_create(&amp;thread_handle,<span class="literal">NULL</span>,client_recv,(<span class="keyword">void</span>*)sock);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"请输入要发送的消息:"</span>);</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"exit"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出成功!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> c1=send(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(sock);                             <span class="comment">// 关闭监听套接字</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按回车键继续..."</span>);</span><br><span class="line">        getchar();                              <span class="comment">// 等待任意按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_socks 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> buf_size 1000</span></span><br><span class="line"><span class="keyword">int</span>* socks[max_socks],now_loc;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span>* pts=<span class="keyword">new</span> <span class="keyword">char</span>[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = recv(my_sock, pts, buf_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pts[c1]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"服务器收到消息: %s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">/* argc: 命令行参数个数， 例如：C:\&gt; TCPServer 8080</span></span></span><br><span class="line"><span class="function"><span class="comment">                  argc=2 argv[0]="TCPServer",argv[1]="8080" */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_handles=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(max_socks*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">fsin</span>;</span> <span class="comment">/* the from address of a client       */</span></span><br><span class="line">  <span class="keyword">int</span> msock, ssock;        <span class="comment">/* master &amp; slave sockets         */</span></span><br><span class="line">  <span class="keyword">char</span> *service = <span class="string">"50500"</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">/* an Internet endpoint address             */</span></span><br><span class="line">  <span class="keyword">int</span> alen;               <span class="comment">/* from-address length                      */</span></span><br><span class="line">  <span class="keyword">char</span> pts[<span class="number">1000</span>];         <span class="comment">/* pointer to time string           */</span></span><br><span class="line">  <span class="keyword">time_t</span> now;             <span class="comment">/* current time                                 */</span></span><br><span class="line"></span><br><span class="line">  msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">// 创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                    <span class="comment">// 返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                     <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                            <span class="comment">// 因特网地址簇(INET-Internet)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;                    <span class="comment">// 监听所有(接口的)IP地址。</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service)); <span class="comment">// 监听的端口号。atoi--把ascii转化为int，htons--主机序到网络序(host to network，s-short 16位)</span></span><br><span class="line">  bind(msock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));   <span class="comment">// 绑定监听的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">  listen(msock, <span class="number">5</span>); <span class="comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;                                                                         <span class="comment">// 检测是否有按键,如果没有则进入循环体执行</span></span><br><span class="line">      alen = <span class="keyword">sizeof</span>(struct sockaddr);                                      <span class="comment">// 取到地址结构的长度</span></span><br><span class="line">      ssock = accept(msock, (struct sockaddr *)&amp;fsin, (<span class="keyword">socklen_t</span> *)&amp;alen); <span class="comment">// 如果在连接请求队列中有连接请求，</span></span><br><span class="line">      socks[now_loc]=<span class="keyword">new</span> <span class="keyword">int</span>(ssock);</span><br><span class="line">      pthread_create(&amp;thread_handles[now_loc],<span class="literal">NULL</span>,serve,(<span class="keyword">void</span>*)now_loc);</span><br><span class="line">      now_loc++;</span><br><span class="line">  &#125;</span><br><span class="line">  close(msock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果:<br><img src="https://i.loli.net/2020/05/15/X2EWRokZ9QuJBUh.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/15/YDWgXzjtUG6s7Tf.png" alt="image.png"></p>
<p>2.服务器程序转发某个客户端发来的消息时都在消息前面加上该客户端的IP地址和端口号以及服务器的当前时间。要求服务器程序把转发的消息也显示出来。</p>
<p>服务器程序(修改部分)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_socks 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> buf_size 1000</span></span><br><span class="line"><span class="keyword">int</span>* socks[max_socks],now_loc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">fsin</span>[<span class="title">max_socks</span>];</span> <span class="comment">/* the from address of a client       */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span>* pts=<span class="keyword">new</span> <span class="keyword">char</span>[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tem=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: "</span>,</span><br><span class="line">    (tem&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(tem&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(tem&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,tem&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock, pts + c1, <span class="number">1000</span>-c1, <span class="number">0</span>);</span><br><span class="line">    pts[c1 + c2] = <span class="string">'\n'</span>;</span><br><span class="line">    pts[c1+c2+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="comment">/* argc: 命令行参数个数， 例如：C:\&gt; TCPServer 8080</span></span></span><br><span class="line"><span class="function"><span class="comment">                  argc=2 argv[0]="TCPServer",argv[1]="8080" */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_handles=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(max_socks*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">int</span> msock, ssock;        <span class="comment">/* master &amp; slave sockets         */</span></span><br><span class="line">  <span class="keyword">char</span> *service = <span class="string">"50500"</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">/* an Internet endpoint address             */</span></span><br><span class="line">  <span class="keyword">int</span> alen;               <span class="comment">/* from-address length                      */</span></span><br><span class="line">  <span class="keyword">char</span> pts[<span class="number">1000</span>];         <span class="comment">/* pointer to time string           */</span></span><br><span class="line">  <span class="keyword">time_t</span> now;             <span class="comment">/* current time                                 */</span></span><br><span class="line"></span><br><span class="line">  msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">// 创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span></span><br><span class="line">                                                    <span class="comment">// 返回：要监听套接字的描述符或INVALID_SOCKET</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                     <span class="comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_family = AF_INET;                            <span class="comment">// 因特网地址簇(INET-Internet)</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;                    <span class="comment">// 监听所有(接口的)IP地址。</span></span><br><span class="line">  <span class="built_in">sin</span>.sin_port = htons((<span class="keyword">unsigned</span> short)atoi(service)); <span class="comment">// 监听的端口号。atoi--把ascii转化为int，htons--主机序到网络序(host to network，s-short 16位)</span></span><br><span class="line">  bind(msock, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));   <span class="comment">// 绑定监听的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">  listen(msock, <span class="number">5</span>); <span class="comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;                                                                         <span class="comment">// 检测是否有按键,如果没有则进入循环体执行</span></span><br><span class="line">      alen = <span class="keyword">sizeof</span>(struct sockaddr);                                      <span class="comment">// 取到地址结构的长度</span></span><br><span class="line">      ssock = accept(msock, (struct sockaddr *)&amp;fsin[now_loc], (<span class="keyword">socklen_t</span> *)&amp;alen); <span class="comment">// 如果在连接请求队列中有连接请求，</span></span><br><span class="line">      socks[now_loc]=<span class="keyword">new</span> <span class="keyword">int</span>(ssock);</span><br><span class="line">      pthread_create(&amp;thread_handles[now_loc],<span class="literal">NULL</span>,serve,(<span class="keyword">void</span>*)now_loc);</span><br><span class="line">      now_loc++;</span><br><span class="line">  &#125;</span><br><span class="line">  close(msock); <span class="comment">// 关闭监听套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏:<br><img src="https://i.loli.net/2020/05/15/voCymHlJwVsk4re.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/15/pZMjuklzbSs2GfE.png" alt="image.png"></p>
<p>3.新客户刚连接时服务器端把“enter”消息（包含客户端IP地址和端口号）发送给所有客户端。<br>服务器程序(修改部分)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只修改了serve函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span> pts[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span> tem[buf_size+<span class="number">1</span>]=<span class="string">"Enter!\n"</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> port=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: %s"</span>,</span><br><span class="line">    (port&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,port&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch,tem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock,tem,buf_size, <span class="number">0</span>);</span><br><span class="line">    tem[c2] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏：<br>第一个客户端启动:<br><img src="https://i.loli.net/2020/05/15/DytxLFilVIW1B37.png" alt="image.png"><br>第二个客户端启动:<br><img src="https://i.loli.net/2020/05/15/8xwAv2zTSJMbUHI.png" alt="image.png"></p>
<p>4.客户端输入exit时退出客户端程序（正常退出），或者客户端直接关闭窗口退出（异常退出），服务器都会把该客户leave的消息广播给所有客户。<br>服务器程序(修改部分)：<br>只修改了serve函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">serve</span><span class="params">(<span class="keyword">void</span>* in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> my_loc=(<span class="keyword">long</span>)in;</span><br><span class="line">  <span class="keyword">int</span> my_sock=*(socks[my_loc]);</span><br><span class="line">  <span class="keyword">char</span> pts[buf_size+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span> tem[buf_size+<span class="number">1</span>]=<span class="string">"Enter!\n"</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> port=fsin[my_loc].sin_addr.s_addr;</span><br><span class="line">    strftime(ch, <span class="keyword">sizeof</span>(ch) - <span class="number">1</span>, <span class="string">"%Y-%m-%d--%H:%M:%S"</span>, localtime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">sprintf</span>(pts, <span class="string">"\nip: %d.%d.%d.%d port: %u\ntime: %s\nmessage: %s"</span>,</span><br><span class="line">    (port&lt;&lt;<span class="number">24</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">16</span>)&gt;&gt;<span class="number">24</span>,(port&lt;&lt;<span class="number">8</span>)&gt;&gt;<span class="number">24</span>,port&gt;&gt;<span class="number">24</span>,fsin[my_loc].sin_port,ch,tem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,pts);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max_socks;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(socks[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        send(*socks[i], pts, <span class="built_in">strlen</span>(pts), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tem,<span class="string">"Leave!\n"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      close(my_sock);</span><br><span class="line">      socks[my_loc]=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c2 = recv(my_sock,tem,buf_size, <span class="number">0</span>);</span><br><span class="line">    tem[c2] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c2==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(tem,<span class="string">"Leave!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截屏：<br>客户端用输入exit离开时:<br><img src="https://i.loli.net/2020/05/15/qFluxBEg2CJRpVA.png" alt="image.png"><br>客户端用Ctrl+C退出时:<br><img src="https://i.loli.net/2020/05/15/oOM3ydBrRLQ16Em.png" alt="image.png"></p>
<p>5.运行客户端程序测试与老师的服务器程序的连接（103.26.79.35:50500）。<br>运行截屏（客户端）：</p>
<p><img src="https://i.loli.net/2020/05/15/5MA6BlNVL9Th1wx.png" alt="image.png"></p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>还是挺有趣的…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reeeeeeeeeein</p>
  <div class="site-description" itemprop="description">SYSU 计算机专业大二在读</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reeeeeeeeeein</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>