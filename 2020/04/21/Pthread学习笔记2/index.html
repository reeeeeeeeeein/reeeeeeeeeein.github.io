<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Pthread学习笔记2临界区问题当多个线程同时修改同一个内存地址时，可能会出现奇奇怪怪的问题。我们根据下面的公式编写一个计算$\pi$的程序:$$\pi&#x3D;4(\sum_{n&#x3D;1}^{\infty}(-1)^{n-1}\frac{1}{2n-1})$$ 1234567891011121314151617181920212223242526272829303132333435363738394041">
<meta property="og:type" content="article">
<meta property="og:title" content="Pthread学习笔记2">
<meta property="og:url" content="http://yoursite.com/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="reeeeeeeeeein的博客">
<meta property="og:description" content="Pthread学习笔记2临界区问题当多个线程同时修改同一个内存地址时，可能会出现奇奇怪怪的问题。我们根据下面的公式编写一个计算$\pi$的程序:$$\pi&#x3D;4(\sum_{n&#x3D;1}^{\infty}(-1)^{n-1}\frac{1}{2n-1})$$ 1234567891011121314151617181920212223242526272829303132333435363738394041">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/20/A7KSVsQU3rCmfB9.png">
<meta property="og:image" content="https://i.loli.net/2020/04/20/C9bXnD8ULhNYq5Q.png">
<meta property="og:image" content="https://i.loli.net/2020/04/20/dwGW8O47tUgKjS9.png">
<meta property="og:image" content="https://i.loli.net/2020/04/20/NW65oQeM3yJRjTf.png">
<meta property="og:image" content="https://i.loli.net/2020/04/20/4KqbjiQeJC1RFW7.png">
<meta property="og:image" content="https://i.loli.net/2020/04/21/rf15jbtTWmpuEoZ.png">
<meta property="article:published_time" content="2020-04-21T01:58:52.937Z">
<meta property="article:modified_time" content="2020-04-21T01:58:52.937Z">
<meta property="article:author" content="reeeeeeeeeein">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/20/A7KSVsQU3rCmfB9.png">

<link rel="canonical" href="http://yoursite.com/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Pthread学习笔记2 | reeeeeeeeeein的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
<div class="bg_content">
<canvas id="canvas"></canvas>
</div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">reeeeeeeeeein的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reeeeeeeeeein">
      <meta itemprop="description" content="SYSU 计算机专业大二在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reeeeeeeeeein的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Pthread学习笔记2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 09:58:52" itemprop="dateCreated datePublished" datetime="2020-04-21T09:58:52+08:00">2020-04-21</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Pthread学习笔记2"><a href="#Pthread学习笔记2" class="headerlink" title="Pthread学习笔记2"></a>Pthread学习笔记2</h1><h2 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h2><p>当多个线程同时修改同一个内存地址时，可能会出现奇奇怪怪的问题。我们根据下面的公式编写一个计算$\pi$的程序:$$\pi=4<em>(\sum_{n=1}^{\infty}(-1)^{n-1}</em>\frac{1}{2n-1})$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %f\n"</span>,sum);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，当线程数大于1的时候会发现，程序输出的结果是不确定的，而且误差也较1个线程的情况大，甚至运行时间也是较长:<br><img src="https://i.loli.net/2020/04/20/A7KSVsQU3rCmfB9.png" alt="image.png"></p>
<p>这种情况被称为临界区问题，当0号线程把sum取到寄存器并执行运算的时候，1号进程也可能同时把sum取到寄存器，然后0号进程把结果写回内存，随后1号进程也把结果写回内存。这样就导致0号进程的计算结果被覆盖掉了，我们称</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样更新共享资源的语句为一个<strong>临界区</strong>。当多个线程尝试更新一个共享资源时，结果可能是无法预测的。更一般地，当多个线程都要访问共享变量或共享文件这样的共享资源时，如果有一个线程执行了更新操作，就可能产生错误，我们称之为<strong>竞争条件</strong>。</p>
<p>临界区问题可以用忙等待、互斥量和信号量等方法来解决。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>一种解决方法是设置一个标记变量，用于指明临界区可以被哪个线程执行，该执行完之后修改这个标记变量，而不能执行临界区的线程必须一直处于忙等待状态。<br>我们可以将代码修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">flag=(flag+<span class="number">1</span>)%thread_count;</span><br></pre></td></tr></table></figure>

<p>flag是我们说到的标记变量，当flag==当前线程号时，可以执行临界区，否则必须处于忙等待状态。执行完之后要修改flag。</p>
<p>运行结果如下:<br><img src="https://i.loli.net/2020/04/20/C9bXnD8ULhNYq5Q.png" alt="image.png"><br>可以看到，结果是正确了，但运行速度满了很多，甚至比单线程的情况还慢。</p>
<p>当然，由于临界区只能被串行执行，我们应该尽量减少临界区执行的次数，比如，我们可以把Thread_sum函数修改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  flag=(flag+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个局部变量来代替sum变量，这样循环的过程中就不会有临界区。<br><img src="https://i.loli.net/2020/04/20/dwGW8O47tUgKjS9.png" alt="image.png"><br>运行结果正确，速度上也有提升。</p>
<p>使用忙等待还会有一个问题:</p>
<p>考虑一个最多可以同时执行2个线程的计算机，我们使用忙等待的方法编写一个5个线程的pthreads程序。假设开始时，操作系统运行0号线程和1号线程，这是没有问题的，此时2,3,4三个线程被挂起。然后假设0号线程运行结束，操作系统将其挂起，然后调度3号线程。由于操作系统的线程调度是随机的，它完全不知道此时只有2号线程能进入临界区，所以3号线程只能一直处于忙等待状态，浪费了时间。</p>
<p>所以，当线程数量大于计算机能同时运行的线程数时，使用忙等待的方法可能会产生问题。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>由于处于忙等待的线程会持续地占用CPU资源，所以忙等待并不是一个特别理想的解决临界区问题的方案。我们可以使用互斥量和信号量。</p>
<p>互斥量是互斥锁的简称，是一个特殊类型的变量，它可以保证每次只有一个线程能进入临界区。</p>
<p>互斥量的变量类型是pthread_mutex_t,必须调用 pthread_mutex_init()函数进行初始化。</p>
<p>当线程执行到临界区前面时，应该调用pthread_mutex_lock()函数。如果此时临界区已经被加了锁(即已经有其他线程执行到了这里)，则它会被卡在临界区外等待；否则它会进入临界区，并把临界区加锁。</p>
<p>当临界区被执行完，线程要用pthread_mutex_unlock函数把临界区解锁。此时，系统会从其他等待的线程选出一个进入临界区。如果有多个等待的线程，操作系统选择哪个线程是随机的的。</p>
<p>互斥量使用完之后要用pthread_mutex_destroy函数将其销毁。</p>
<p>互斥量的示例如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line"><span class="comment">//    printf("%d %d\n",flag,my_rank);</span></span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://i.loli.net/2020/04/20/NW65oQeM3yJRjTf.png" alt="image.png"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量(semaphore)可以认为是一种特殊类型的unsigned int，它的类型是sem_t。信号量可以赋值为0,1,……。大多数情况下，我们只用0和1两个值。这种只有0和1值的信号量也称为二元信号量。0对应上了锁的互斥量，1对应没上锁的互斥量。</p>
<p>初始化信号量的方法是调用sem_init(),它的原型是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中第二个参数直接置为0就可以了，第三个参数是初始值。</p>
<p>如果我们要用信号量来解决临界区问题，可以先创建一个全局信号量，初始值为1。在临界区前调用sem_wait()函数,这个函数的意义是:如果信号量为0则阻塞；如果是非0值则减1然后进入临界区。临界区执行完之后，调用sem_post()函数将信号量置为1。</p>
<p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;//注意要加这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">sem_t</span> my_semaphore;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">double</span> my_sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> factor;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_n=n/thread_count;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_first_i=my_n*my_rank;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> my_last_i=my_first_i+my_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(my_first_i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    factor=<span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> factor=<span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = my_first_i;i&lt;my_last_i;i++,factor=-factor)&#123;</span><br><span class="line">    my_sum+=factor/(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sem_wait(&amp;my_semaphore);</span><br><span class="line">  sum+=my_sum;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %d\n"</span>,my_rank);</span><br><span class="line">  sem_post(&amp;my_semaphore);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  n=strtol(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  sem_init(&amp;my_semaphore,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用信号量还可以控制线程执行的顺序，如发送消息问题。我们可以给每个线程分配一个信号量，初始化为0，给每个线程一个char*，指向收到的消息。每一个线程把消息放到下一个线程后将下一个线程的信号量置为1，然后等待上一个线程的消息。代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MAX 100</span></span><br><span class="line"><span class="keyword">int</span> thread_count,n;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">char</span>** messages;</span><br><span class="line"><span class="keyword">sem_t</span>* semaphores;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Thread_sum</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> my_rank=(<span class="keyword">long</span>)rank;</span><br><span class="line">  <span class="keyword">long</span> dest=(my_rank+<span class="number">1</span>)%thread_count;</span><br><span class="line">  <span class="keyword">char</span>* my_msg=<span class="built_in">malloc</span>(MSG_MAX*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(my_msg,<span class="string">"Hello to %ld from %ld"</span>,dest,my_rank);</span><br><span class="line">  messages[dest]=my_msg;</span><br><span class="line">  sem_post(&amp;semaphores[dest]);</span><br><span class="line">  sem_wait(&amp;semaphores[my_rank]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thread %ld &gt; %s\n"</span>,my_rank,messages[my_rank]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">2</span>)<span class="built_in">abort</span>();</span><br><span class="line">  <span class="keyword">long</span> thread;</span><br><span class="line">  <span class="keyword">pthread_t</span>* thread_handles;</span><br><span class="line">  thread_count=strtol(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">  semaphores=(<span class="keyword">sem_t</span>*)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>));</span><br><span class="line">  messages=(<span class="keyword">char</span>**)<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>,<span class="title">tv2</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">  thread_handles=<span class="built_in">malloc</span>(thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_create(&amp;thread_handles[thread],<span class="literal">NULL</span>,Thread_sum,(<span class="keyword">void</span>*)thread);</span><br><span class="line">  <span class="comment">//printf("Hello from the main thread\n");</span></span><br><span class="line">  <span class="keyword">for</span>(thread=<span class="number">0</span>;thread&lt;thread_count;thread++)pthread_join(thread_handles[thread],<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;m;i++)printf("%f\n",y[i]);</span></span><br><span class="line">  <span class="built_in">free</span>(thread_handles);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  gettimeofday(&amp;tv2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ans: %.8f\n"</span>,<span class="number">4</span>*sum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tv2.tv_sec*<span class="number">1000000</span> + tv2.tv_usec - tv.tv_sec*<span class="number">1000000</span> - tv.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示:<br><img src="https://i.loli.net/2020/04/20/4KqbjiQeJC1RFW7.png" alt="image.png"></p>
<p>但如果我们把sem_wait那一行去掉，会出现这样的变化:<br><img src="https://i.loli.net/2020/04/21/rf15jbtTWmpuEoZ.png" alt="image.png"><br>第0号线程没有收到消息的时候就调用printf函数，自然就得不到想要的结果。</p>
<p>像上面这种一个线程需要等待另一个线程执行某种操作的同步方式，有时称为<strong>生产者-消费者同步模型</strong>。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/20/Pthread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" rel="prev" title="Pthread学习笔记1">
      <i class="fa fa-chevron-left"></i> Pthread学习笔记1
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Pthread学习笔记2"><span class="nav-number">1.</span> <span class="nav-text">Pthread学习笔记2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#临界区问题"><span class="nav-number">1.1.</span> <span class="nav-text">临界区问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#忙等待"><span class="nav-number">1.1.1.</span> <span class="nav-text">忙等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥量"><span class="nav-number">1.1.2.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">1.1.3.</span> <span class="nav-text">信号量</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reeeeeeeeeein</p>
  <div class="site-description" itemprop="description">SYSU 计算机专业大二在读</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reeeeeeeeeein</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>